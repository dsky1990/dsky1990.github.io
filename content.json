[{"title":"react-native 安装教程(Mac)","date":"2018-08-11T13:12:03.000Z","path":"2018/08/11/react-native-install/","text":"ios版 安装 yarn global add react-native-cli react-native No bundle URL present解决办法 https://blog.csdn.net/c_kite/article/details/79215023 运行 1react-native run-ios android版本 安装java8 12brew tap caskroom/versionsbrew cask install java8 安装genymotion 安装android studio 配置ANDROID_HOME环境参数 123456# 打开文件vi ~/.bash_profile# 添加配置export ANDROID_HOME=~/Library/Android/sdk# 使其立即生效source ~/.bash_profile 将Android SDK的Tools目录添加到PATH变量中(你可以把Android SDK的tools和platform-tools目录添加到PATH变量中，以便在终端中运行一些Android工具，例如android avd或是adb logcat等) 123456# 打开文件vi ~/.bash_profile# 添加配置export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools# 使其立即生效source ~/.bash_profile genymotion virtualization engine not found 安装 VirtualBox，因为Mac版本的genymotion是没有VirtualBox，我们需要自己安装 Execution failed for task ‘:app:installDebug’. 123456789101112131415161718:app:installDebug FAILEDFAILURE: Build failed with an exception.* What went wrong:Execution failed for task &apos;:app:installDebug&apos;.&gt; com.android.builder.testing.api.DeviceException: No connected devices!* Try:Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.BUILD FAILEDTotal time: 1.865 secsCould not install the app on the device, read the error above for details.Make sure you have an Android emulator running or a device connected and haveset up your Android development environment:https://facebook.github.io/react-native/docs/getting-started.html 碰到这个问题的话，我们首先配置一下Genymotion的设置，Use Android Sdk, 将目录设置为ANDROID_HOME的路径,然后我们打开Genymotion添加设备，并启动虚拟机 运行 1react-native run-android 参考资料","tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"react-native","slug":"react-native","permalink":"http://yoursite.com/tags/react-native/"}]},{"title":"GitLab 服务器搭建","date":"2018-03-25T16:00:00.000Z","path":"2018/03/26/gitLab/","text":"环境安装系统Ubuntu Server 16.04.1 LTS 64位 必要依赖 ruby ngnix 安装方式12sudo apt-get updatesudo apt-get install ruby nginx GitLab 安装 安装依赖包，运行命令 12sudo apt-get updatesudo apt-get install -y curl openssh-server ca-certificates 安装postfix 1sudo apt-get install -y postfix 这个过程中我们会选择Postfix相关配置，这里我们选择Internet Site，然后tab\u001d键切换到ok，\benter选择 添加GitLab\b安装包的源，并安装package 1curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.deb.sh | sudo bash 安装 gitlab-ce 12sudo apt-get updatesudo apt-get install gitlab-ce 然后在这里我们会碰到一个问题，安装完之后，\b会提示我们Unable to locate package gitlab-ce,或者会\b耗时很久，\b解决办法如下: 利用清华大学的镜像来进行主程序的安装，但是有一点需要注意,gitlab-ce 镜像仅支持 x86-64 架构 1、 首先信任 GitLab 的 GPG 公钥: 1curl https://packages.gitlab.com/gpg.key 2&gt; /dev/null | sudo apt-key add - &amp;&gt;/dev/null 2、 利用root用户（不是sudo，而是root），vi打开文件/etc/apt/sources.list.d/gitlab-ce.list，加入下面一行： 123# 这里是Ubuntu Server 16.04.1 LTS 64 的\b，对应系统，在网页在自己选择查看deb https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu xenial main \b创建root用户 12sudo passwd rootsu root 再\b安装 gitlab-ce 12sudo apt-get updatesudo apt-get install gitlab-ce 配置GitLab IP地址1sudo vi /etc/gitlab/gitlab.rb 然后修改external_url为http://ip:port 初始化配置1sudo gitlab-ctl reconfigure 这里大概要耗时5-6分钟 打开 sshd 和 postfix 服务12service sshd start service postfix start 为了GitLab 社区版的 Web 界面可以通过网络进行访问，我们需要允许 80 端口通过防火墙，这个端口是 GitLab 社区版的默认端口。为此需要运行下面的命令 1sudo iptables -A INPUT -p tcp -m tcp --dport 80 -j ACCEPT 检查GitLab是否安装好并且已经正确运行，输入下面的命令1sudo gitlab-ctl status 如果得到类似下面的结果，则说明GitLab运行正常 1234567run: gitlab-workhorse: (pid 1148) 884s; run: log: (pid 1132) 884srun: logrotate: (pid 1150) 884s; run: log: (pid 1131) 884srun: nginx: (pid 1144) 884s; run: log: (pid 1129) 884srun: postgresql: (pid 1147) 884s; run: log: (pid 1130) 884srun: redis: (pid 1146) 884s; run: log: (pid 1133) 884srun: sidekiq: (pid 1145) 884s; run: log: (pid 1128) 884srun: unicorn: (pid 1149) 885s; run: log: (pid 1134) 885s 到这里我们的配置基本完成了，然后我们可以访问我们之前\b配置对地址，设置完成密码后进行登陆，默认username为root 配置 swap 交换分区由于 GitLab 较为消耗资源，我们需要先创建交换分区，以降低物理内存的压力，新建 2 GB 大小的交换分区： 1dd if=/dev/zero of=/root/swapfile bs=1M count=2048 格式化为交换分区文件并启用:12mkswap /root/swapfileswapon /root/swapfile 添加自启用。打开 /etc/fstab 文件1/root/swapfile swap swap defaults 0 0 参考资料https://www.zybuluo.com/lovemiffy/note/418758，https://cloud.tencent.com/developer/labs/lab/10288","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"gitLab","slug":"gitLab","permalink":"http://yoursite.com/tags/gitLab/"}]},{"title":"本地开启服务器https","date":"2016-06-17T16:00:00.000Z","path":"2016/06/18/https/","text":"今天在使用geolocation的时候，在chrome下面发现获取不到经纬度信息，提示基于安全问题，需要在https环境下，那我们就来在本地安装https然后代理访问。 安装nginx首先我们来安装Homebrew，安装方法如下1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 接下来安装nginx1brew install nginx Nginx SSL/HTTPS 配置 生成RSA密钥的方法 首先我们得选择安装路径，例如我就是选择的desktop/dsky 12cd dskyopenssl genrsa -des3 -out privkey.pem 2048 这个命令会生成一个2048位的密钥，同时有一个des3方法加密的密码，如果你不想要每次都输入密码，可以改成：1openssl genrsa -out privkey.pem 2048 生成一个证书请求 1openssl req -new -key privkey.pem -out cert.csr 这个命令将会生成一个证书请求，当然，用到了前面生成的密钥privkey.pem文件这里将生成一个新的文件cert.csr，即一个证书请求文件，你可以拿着这个文件去数字证书颁发机构（即CA）申请一个数字证书。CA会给你一个新的文件cacert.pem，那才是你的数字证书。 因为是自己做测试，那么证书的申请机构和颁发机构都是自己。就可以用下面这个命令来生成证书：1openssl req -new -x509 -key privkey.pem -out cacert.pem -days 1095 这个命令将用上面生成的密钥privkey.pem生成一个数字证书cacert.pem 配置nginx首先我们打开nginx的目录12cd /usr/local/etc/nginx/open . 然后打开nginx.conf文件，找到https的配置123456789101112131415161718192021# HTTPS server # server &#123; listen 8443 ssl; server_name localhost; ssl_certificate /Users/gujia/Desktop/dsky/project/cacert.pem; ssl_certificate_key /Users/gujia/Desktop/dsky/project/privkey.pem; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; # root html; # index index.html index.php; proxy_pass http://localhost:3000; &#125; &#125; 接下来任何访问8443的端口的url，都会跳转到http://localhost:3000 文章参考Nginx SSL/HTTPS 配置","tags":[{"name":"https","slug":"https","permalink":"http://yoursite.com/tags/https/"},{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}]},{"title":"preventDefault事件对input type为checkbox或radio时的click影响","date":"2016-06-10T16:00:00.000Z","path":"2016/06/11/input-preventDefault/","text":"最近做项目的时候发现了一个问题，在document上绑定clcik事件后，input type为checkbox或radio的状态不会改变，但是绑定的事件会执行，Demo如下： JS Bin on jsbin.com 可以看到，在执行完$(this).attr(&#39;checked&#39;,true);后到alert时，checkbox的状态是选中的，而且弹出的状态也是checked，也就是说，这个时候，checkbox是选中的。但是为什么我们在点击确定之后，checkbox又变回了未选中了呢？在相应事件结束之后，一定还有什么东西让它改回去了？其实，这是checkbox的默认click事件的做的。也许大家会问，我不是通过e.preventDefault()把默认事件去掉了吗？为什么还有默认事件？难道e.preventDefault()没有生效？ 在这里需要说明下：一般的默认事件，会在我们绑定的响应事件之后执行（这样说不准确，默认事件和自己绑定的响应事件是在一起执行的，只不过，它的真正的作用一般会在所有事件内容做完之后才会体现出来，因此，在这就简单理解成在绑定的事件之后执行吧）。有了这个说明，我们再来说下这个现象。这不是浏览器的bug，也不是没有禁掉默认事件。由于checkbox是系统的组件，因此它的实现机理比较复杂，在这里不讨论，这个问题的主要原因是：checkbox的click事件的默认事件是将修改的选中状态生效。解释一下，如果在鼠标点击之前，checkbox的状态是选中，那么在点击checkbox时，它会将当前的状态取反即取消选中，然后执行响应事件，最后默认事件将这个状态生效。 上面的这个代码中，由于去掉了默认事件，因此，在执行响应事件时，checkbox确实选中了，alert出来的也是选中的，但是在事件结束时，由于没有没有默认事件，那么这个checkbox就回到了点击之前的状态。我们如果将input写成：&lt;input type=&quot;checkbox&quot; id=&quot;id1&quot; checked /&gt;，即在点击之前就选中它，那么点击之后，checkbox就是选中的状态了。当然，这个选中状态不是因为$(this).attr(&#39;checked&#39;,true);造成的，而是没有默认事件，它又重置回之前的状态了。这里我们将代码改成$(this).attr(&#39;checked&#39;,false);在执行完之后，仍然会是选中状态的。 这个问题充分体现出了默认事件的重要性，我们之前去掉过很多默认事件，但是大部分的默认事件如我们想象的那样，去掉之后，基本功能就不存在了。但是checkbox的click默认事件不是让它没有反应，而是将修改后的状态生效（注意：仅仅是click事件，mousedown和mouseup事件是没有这个特点的）。因此，在我们不知道这个问题之前，如果禁掉了它的click事件，就会出现一些问题了。当然，这知识针对checkbox和radio而言。w3c的文档也证实了这一点，它的文档上有明确的说明： Note: During the handling of a click event on an input element with a type attribute that has the value “radio” or “checkbox”, some implementations may change the value of this property before the event is being dispatched in the document. If the default action of the event is canceled, the value of the property may be changed back to its original value. This means that the value of this property during the handling of click events is implementation dependent. 原文地址：http://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-6043025","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"javascript闭包浅析","date":"2016-06-04T16:00:00.000Z","path":"2016/06/05/javascript-closure/","text":"闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现，接下来简单说说闭包的相关知识和如何实现闭包。 变量的作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。变量的作用域无非就是两种：全局变量和局部变量。Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。12345678910111213var a = \"111\";function aaa()&#123; console.log(a);&#125;aaa(); // 111console.log(a); // 111function bbb()&#123; var b = \"222\"; console.log(b);&#125;bbb(); // 222console.log(b); // b is not defined 我们可以看到，函数内部是可以访问外部的变量的，但是外部是不能访问内部的变量的，闭包就是用来使得可以在函数外部读取函数内部变量的函数或者方法。 闭包的定义及其优缺点闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量。 闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。 闭包是javascript语言的一大特点，主要应用闭包场合主要是为了：设计私有的方法和变量。 闭包的经典问题我们先看一个经典的的例子：1234567891011121314151617181920function demo()&#123; var result = []; for (var i=0;i&lt; 10;i++)&#123; result[i] = function()&#123; return i; &#125;; &#125; return result;&#125;var result = demo();console.log(result[0]()); // 10console.log(result[1]()); // 10console.log(result[2]()); // 10console.log(result[3]()); // 10console.log(result[4]()); // 10console.log(result[5]()); // 10console.log(result[6]()); // 10console.log(result[7]()); // 10console.log(result[8]()); // 10console.log(result[9]()); // 10 这个函数返回的每一个数组的值都是10，因为每个函数的作用域链中都保存着demo()的对象，所以他们引用的都是一个变量i，所以当demo()函数返回后，变量i的值是10，所以返回的都是10。为了解决这个问题，我们可以创建另外一个匿名函数强制让闭包的行为符合预期：12345678910111213141516171819202122function demo()&#123; var result = []; for (var i=0;i&lt; 10;i++)&#123; result[i] = (function(num)&#123; return function()&#123; return num; &#125;; &#125;)(i); &#125; return result;&#125;var result = demo();console.log(result[0]()); // 0console.log(result[1]()); // 1console.log(result[2]()); // 2console.log(result[3]()); // 3console.log(result[4]()); // 4console.log(result[5]()); // 5console.log(result[6]()); // 6console.log(result[7]()); // 7console.log(result[8]()); // 8console.log(result[9]()); // 9 通过匿名函数我们实现了闭包，接下来说说闭包实现的几种方式。 访问函数内部变量的方法方法一123456function fun()&#123; var a = \"aaa\"; return a;&#125;var result = fun();console.log(result); // aaa 方法二1234567var result = null;function fun()&#123; var a = \"aaa\"; this.result = a;&#125;fun();console.log(result); // aaa 方法三12345678var getResult = &#123; aaa: function()&#123; var a = \"aaa\"; return a; &#125;&#125;;var result = getResult.aaa();console.log(result); // aaa 方法四12345678function Demo()&#123; this.getResult = function()&#123; var a = \"aaa\"; return a; &#125;;&#125;var demo = new Demo();console.log(demo.getResult()); // aaa 内存泄露问题由于IE的js对象和DOM对象使用不同的垃圾收集方法，因此闭包在IE中会导致内存泄露问题，也就是无法销毁驻留在内存中的元素。123456function demo()&#123; var element = document.getElementById(\"aaa\"); element.onclick = function()&#123; alert(element.id); &#125;&#125; 以上代码创建了一个作为element元素事件处理的闭包，而这个闭包又创建了一个循环引用，由于匿名函数保存了一个对demo的活动对象的引用，因此就会导致无法减少element的引用数，只要匿名函数存在，element的引用至少是1，那么内存永远不会被回收，我们可以改写代码12345678function demo()&#123; var element = document.getElementById(\"aaa\"); var id = element.id; element.onclick = function()&#123; alert(id); &#125; element = null;&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"closure","slug":"closure","permalink":"http://yoursite.com/tags/closure/"}]},{"title":"ES6学习笔记之module","date":"2016-05-28T16:00:00.000Z","path":"2016/05/29/es6-module/","text":"ModuleES6的Class只是面向对象编程的语法糖，升级了ES5的构造函数的原型链继承的写法，并没有解决模块化问题。Module功能就是为了解决这个问题而提出的。 历史上，JavaScript一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如Ruby的require、Python的import，甚至就连CSS都有@import，但是JavaScript任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。 在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。 ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。 123456// CommonJS模块let &#123; stat, exists, readFile &#125; = require('fs');// 等同于let _fs = require('fs');let stat = _fs.stat, exists = _fs.exists, readfile = _fs.readfile; 上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。 ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时也采用静态命令的形式。 12// ES6模块import &#123; stat, exists, readFile &#125; from 'fs'; 上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”，即ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。 由于ES6模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽JavaScript的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。除了静态加载带来的各种好处，ES6模块还有以下好处。 不再需要UMD模块格式了，将来服务器和浏览器都会支持ES6模块格式。目前，通过各种工具库，其实已经做到了这一点。 将来浏览器的新API就能用模块格式提供，不再必要做成全局变量或者navigator对象的属性。 不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。 浏览器使用ES6模块的语法如下： 1&lt;script type=\"module\" src=\"foo.js\"&gt;&lt;/script&gt; 上面代码在网页中插入一个模块foo.js，由于type属性设为module，所以浏览器知道这是一个ES6模块。 严格模式ES6的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”;,严格模式主要有以下限制。 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀0表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） export命令模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个JS文件，里面使用export命令输出变量。 1234// profile.jsexport var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958; 上面代码是profile.js文件，保存了用户信息。ES6将其视为一个模块，里面用export命令对外部输出了三个变量。export的写法，除了像上面这样，还有另外一种。 123456// profile.jsvar firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123;firstName, lastName, year&#125;; 上面代码在export命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在var语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。 export命令除了输出变量，还可以输出函数或类（class）。 123export function multiply(x, y) &#123; return x * y;&#125;; 上面代码对外输出一个函数multiply。通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。 12345678function v1() &#123; ... &#125;function v2() &#123; ... &#125;export &#123; v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion&#125;; 上面代码使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。 需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。 123456// 报错export 1;// 报错var m = 1;export m; 上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出1，第二种写法通过变量m，还是直接输出1。1只是一个值，不是接口。正确的写法是下面这样。 12345678910// 写法一export var m = 1;// 写法二var m = 1;export &#123;m&#125;;// 写法三var n = 1;export &#123;n as m&#125;; 上面三种写法都是正确的，规定了对外的接口m。其他脚本可以通过这个接口，取到值1。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。同样的，function和class的输出，也必须遵守这样的写法。 12345678910// 报错function f() &#123;&#125;export f;// 正确export function f() &#123;&#125;;// 正确function f() &#123;&#125;export &#123;f&#125;; 另外，export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。 12export var foo = 'bar';setTimeout(() =&gt; foo = 'baz', 500); 上面代码输出变量foo，值为bar，500毫秒之后变成baz。这一点与CommonJS规范完全不同。CommonJS模块输出的是值的缓存，不存在动态更新。 最后，export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。 1234function foo() &#123; export default 'bar' // SyntaxError&#125;foo() import命令使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。 1234567// main.jsimport &#123;firstName, lastName, year&#125; from './profile';function setName(element) &#123; element.textContent = firstName + ' ' + lastName;&#125; 上面代码的import命令，就用于加载profile.js文件，并从中输入变量。import命令接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。 如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。 1import &#123; lastName as surname &#125; from './profile'; 注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。 12345export &#123; es6 as default &#125; from './someModule';// 等同于import &#123; es6 &#125; from './someModule';export default es6; 模块的整体加载除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。下面是一个circle.js文件，它输出两个方法area和circumference。 123456789// circle.jsexport function area(radius) &#123; return Math.PI * radius * radius;&#125;export function circumference(radius) &#123; return 2 * Math.PI * radius;&#125; 现在，加载这个模块。 123456// main.jsimport &#123; area, circumference &#125; from './circle';console.log('圆面积：' + area(4));console.log('圆周长：' + circumference(14)); 上面写法是逐一指定要加载的方法，整体加载的写法如下。 1234import * as circle from './circle';console.log('圆面积：' + circle.area(4));console.log('圆周长：' + circle.circumfe export default命令从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。 1234// export-default.jsexport default function () &#123; console.log('foo');&#125; 上面代码是一个模块文件export-default.js，它的默认输出是一个函数。其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。 123// import-default.jsimport customName from './export-default';customName(); // export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export deault命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能对应一个方法。本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。 123456789101112// modules.jsfunction add(x, y) &#123; return x * y;&#125;export &#123;add as default&#125;;// 等同于// export default add;// app.jsimport &#123; default as xxx &#125; from 'modules';// 等同于// import xxx from 'modules'; 模块的继承模块之间也可以继承。假设有一个circleplus模块，继承了circle模块。 1234567// circleplus.jsexport * from 'circle';export var e = 2.71828182846;export default function(x) &#123; return Math.exp(x);&#125; 上面代码中的export *，表示再输出circle模块的所有属性和方法。注意，export *命令会忽略circle模块的default方法。然后，上面代码又输出了自定义的e变量和默认方法。这时，也可以将circle的属性或方法，改名后再输出。 123// circleplus.jsexport &#123; area as circleArea &#125; from 'circle'; 上面代码表示，只输出circle模块的area方法，且将其改名为circleArea。加载上面模块的写法如下。 12345// main.jsimport * as math from 'circleplus';import exp from 'circleplus';console.log(exp(math.e)); 上面代码中的import exp表示，将circleplus模块的默认方法加载为exp方法。 ES6模块加载的实质ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件lib.js的例子。 123456789// lib.jsvar counter = 3;function incCounter() &#123; counter++;&#125;module.exports = &#123; counter: counter, incCounter: incCounter,&#125;; 上面代码输出内部变量counter和改写这个变量的内部方法incCounter。然后，在main.js里面加载这个模块。 123456// main.jsvar mod = require('./lib');console.log(mod.counter); // 3mod.incCounter();console.log(mod.counter); // 3 上面代码说明，lib.js模块加载以后，它的内部变化就影响不到输出的mod.counter了。这是因为mod.counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。 1234567891011// lib.jsvar counter = 3;function incCounter() &#123; counter++;&#125;module.exports = &#123; get counter() &#123; return counter &#125;, incCounter: incCounter,&#125;; 上面代码中，输出的counter属性实际上是一个取值器函数。现在再执行main.js，就可以正确读取内部变量counter的变动了。 123$ node main.js34 ES6模块的运行机制与CommonJS不一样，它遇到模块加载命令import时，不会去执行模块，而是只生成一个动态的只读引用。等到真的需要用到时，再到模块里面去取值，换句话说，ES6的输入有点像Unix系统的“符号连接”，原始值变了，import输入的值也会跟着变。因此，ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 1234567891011// lib.jsexport let counter = 3;export function incCounter() &#123; counter++;&#125;// main.jsimport &#123; counter, incCounter &#125; from './lib';console.log(counter); // 3incCounter();console.log(counter); // 4 由于ES6输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。 12345678// lib.jsexport let obj = &#123;&#125;;// main.jsimport &#123; obj &#125; from './lib';obj.prop = 123; // OKobj = &#123;&#125;; // TypeError export通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。 123456789101112// mod.jsfunction C() &#123; this.sum = 0; this.add = function () &#123; this.sum += 1; &#125;; this.show = function () &#123; console.log(this.sum); &#125;;&#125;export let c = new C(); 上面的脚本mod.js，输出的是一个C的实例。不同的脚本加载这个模块，得到的都是同一个实例。 1234567891011// x.jsimport &#123;c&#125; from './mod';c.add();// y.jsimport &#123;c&#125; from './mod';c.show();// main.jsimport './x';import './y'; 现在执行main.js，输出的是1。 12$ babel-node main.js1 这就证明了x.js和y.js加载的都是C 的同一个实例。 循环加载“循环加载”（circular dependency）指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。 12345// a.jsvar b = require('b');// b.jsvar a = require('a'); 通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。 但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现a依赖b，b依赖c，c又依赖a这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。 对于JavaScript语言来说，目前最常见的两种模块格式CommonJS和ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。 CommonJS模块的加载原理介绍ES6如何处理”循环加载”之前，先介绍目前最流行的CommonJS模块格式的加载原理。 CommonJS的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。 123456&#123; id: '...', exports: &#123; ... &#125;, loaded: true, ...&#125; 上面代码就是Node内部加载模块后生成的一个对象。该对象的id属性是模块名，exports属性是模块输出的各个接口，loaded属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。 以后需要用到这个模块的时候，就会到exports属性上面取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。 CommonJS模块的循环加载CommonJS模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。 让我们来看，Node官方文档里面的例子。脚本文件a.js代码如下。 12345exports.done = false;var b = require('./b.js');console.log('在 a.js 之中，b.done = %j', b.done);exports.done = true;console.log('a.js 执行完毕'); 上面代码之中，a.js脚本先输出一个done变量，然后加载另一个脚本文件b.js。注意，此时a.js代码就停在这里，等待b.js执行完毕，再往下执行。 再看b.js的代码。 12345exports.done = false;var a = require('./a.js');console.log('在 b.js 之中，a.done = %j', a.done);exports.done = true;console.log('b.js 执行完毕'); 上面代码之中，b.js执行到第二行，就会去加载a.js，这时，就发生了“循环加载”。系统会去a.js模块对应对象的exports属性取值，可是因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。 a.js已经执行的部分，只有一行。 1exports.done = false; 因此，对于b.js来说，它从a.js只输入一个变量done，值为false。 然后，b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。于是，a.js接着往下执行，直到执行完毕。我们写一个脚本main.js，验证这个过程。 123var a = require('./a.js');var b = require('./b.js');console.log('在 main.js 之中, a.done=%j, b.done=%j', a.done, b.done); 执行main.js，运行结果如下。 1234567$ node main.js在 b.js 之中，a.done = falseb.js 执行完毕在 a.js 之中，b.done = truea.js 执行完毕在 main.js 之中, a.done=true, b.done=true 另外，由于CommonJS模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。 12345678910var a = require('a'); // 安全的写法var foo = require('a').foo; // 危险的写法exports.good = function (arg) &#123; return a.foo('good', arg); // 使用的是 a.foo 的最新值&#125;;exports.bad = function (arg) &#123; return foo('bad', arg); // 使用的是一个部分加载时的值&#125;; 上面代码中，如果发生循环加载，require(&#39;a&#39;).foo的值很可能后面会被改写，改用require(‘a’)会更保险一点。 ES6模块的循环加载ES6处理“循环加载”与CommonJS有本质的不同。ES6模块是动态引用，如果使用import从一个模块加载变量（即import foo from &#39;foo&#39;），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。 请看下面这个例子。 1234567891011// a.js如下import &#123;bar&#125; from './b.js';console.log('a.js');console.log(bar);export let foo = 'foo';// b.jsimport &#123;foo&#125; from './a.js';console.log('b.js');console.log(foo);export let bar = 'bar'; 上面代码中，a.js加载b.js，b.js又加载a.js，构成循环加载。执行a.js，结果如下。 12345$ babel-node a.jsb.jsundefineda.jsbar 上面代码中，由于a.js的第一行是加载b.js，所以先执行的是b.js。而b.js的第一行又是加载a.js，这时由于a.js已经开始执行了，所以不会重复执行，而是继续往下执行b.js，所以第一行输出的是b.js。 接着，b.js要打印变量foo，这时a.js还没执行完，取不到foo的值，导致打印出来是undefined。b.js执行完，开始执行a.js，这时就一切正常了。再看一个稍微复杂的例子 1234567891011121314151617// a.jsimport &#123;bar&#125; from './b.js';export function foo() &#123; console.log('foo'); bar(); console.log('执行完毕');&#125;foo();// b.jsimport &#123;foo&#125; from './a.js';export function bar() &#123; console.log('bar'); if (Math.random() &gt; 0.5) &#123; foo(); &#125;&#125; 按照CommonJS规范，上面的代码是没法执行的。a先加载b，然后b又加载a，这时a还没有任何执行结果，所以输出结果为null，即对于b.js来说，变量foo的值等于null，后面的foo()就会报错。 但是，ES6可以执行上面的代码。 123456789101112$ babel-node a.jsfoobar执行完毕// 执行结果也有可能是foobarfoobar执行完毕执行完毕 上面代码中，a.js之所以能够执行，原因就在于ES6加载的变量，都是动态引用其所在的模块。只要引用存在，代码就能执行。 下面，我们详细分析这段代码的运行过程。 1234567891011121314151617181920212223242526272829// a.js// 这一行建立一个引用，// 从`b.js`引用`bar`import &#123;bar&#125; from './b.js';export function foo() &#123; // 执行时第一行输出 foo console.log('foo'); // 到 b.js 执行 bar bar(); console.log('执行完毕');&#125;foo();// b.js// 建立`a.js`的`foo`引用import &#123;foo&#125; from './a.js';export function bar() &#123; // 执行时，第二行输出 bar console.log('bar'); // 递归执行 foo，一旦随机数 // 小于等于0.5，就停止执行 if (Math.random() &gt; 0.5) &#123; foo(); &#125;&#125; 我们再来看ES6模块加载器SystemJS给出的一个例子。 12345678910111213// even.jsimport &#123; odd &#125; from './odd'export var counter = 0;export function even(n) &#123; counter++; return n == 0 || odd(n - 1);&#125;// odd.jsimport &#123; even &#125; from './even';export function odd(n) &#123; return n != 0 &amp;&amp; even(n - 1);&#125; 上面代码中，even.js里面的函数even有一个参数n，只要不等于0，就会减去1，传入加载的odd()。odd.js也会做类似操作。 运行上面这段代码，结果如下。 12345678910$ babel-node&gt; import * as m from &apos;./even.js&apos;;&gt; m.even(10);true&gt; m.counter6&gt; m.even(20)true&gt; m.counter17 上面代码中，参数n从10变为0的过程中，even()一共会执行6次，所以变量counter等于6。第二次调用even()时，参数n从20变为0，even()一共会执行11次，加上前面的6次，所以变量counter等于17。 这个例子要是改写成CommonJS，就根本无法执行，会报错。 1234567891011121314// even.jsvar odd = require('./odd');var counter = 0;exports.counter = counter;exports.even = function(n) &#123; counter++; return n == 0 || odd(n - 1);&#125;// odd.jsvar even = require('./even').even;module.exports = function(n) &#123; return n != 0 &amp;&amp; even(n - 1);&#125; 上面代码中，even.js加载odd.js，而odd.js又去加载even.js，形成“循环加载”。这时，执行引擎就会输出even.js已经执行的部分（不存在任何结果），所以在odd.js之中，变量even等于null，等到后面调用even(n-1)就会报错。 1234$ node&gt; var m = require(&apos;./even&apos;);&gt; m.even(10)TypeError: even is not a function 跨模块常量上面说过，const声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），可以采用下面的写法。 1234567891011121314// constants.js 模块export const A = 1;export const B = 3;export const C = 4;// test1.js 模块import * as constants from './constants';console.log(constants.A); // 1console.log(constants.B); // 3// test2.js 模块import &#123;A, B&#125; from './constants';console.log(A); // 1console.log(B); // 3 文章参考ECMAScript 6 入门","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6学习笔记之Class","date":"2016-05-27T16:00:00.000Z","path":"2016/05/28/es6-class/","text":"Class基本语法概述JavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。 12345678910function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')';&#125;;var p = new Point(1, 2); 上面这种写法跟传统的面向对象语言差异很大，很容易让新学习这门语言的程序员感到困惑。ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的类改写，就是下面这样。 1234567891011//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; 上面代码定义了一个类，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5的构造函数Point，对应ES6的Point类的构造方法。Point类除了构造方法，还定义了一个toString方法。注意，定义类的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。ES6的类，完全可以看作构造函数的另一种写法。 123456class Point &#123; // ...&#125;typeof Point // \"function\"Point === Point.prototype.constructor // true 上面代码表明，类的数据类型就是函数，类本身就指向构造函数。使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。 12345678class Bar &#123; doStuff() &#123; console.log('stuff'); &#125;&#125;var b = new Bar();b.doStuff() // \"stuff\" 构造函数的prototype属性，在ES6的类上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。 1234567891011121314151617181920class Point &#123; constructor()&#123; // ... &#125; toString()&#123; // ... &#125; toValue()&#123; // ... &#125;&#125;// 等同于Point.prototype = &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;; 类的内部所有定义的方法，都是不可枚举的（non-enumerable）。 1234567891011121314class Point &#123; constructor(x, y) &#123; // ... &#125; toString() &#123; // ... &#125;&#125;Object.keys(Point.prototype)// []Object.getOwnPropertyNames(Point.prototype)// [\"constructor\",\"toString\"] 上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。 123456789101112var Point = function (x, y) &#123; // ...&#125;;Point.prototype.toString = function() &#123; // ...&#125;;Object.keys(Point.prototype)// [\"toString\"]Object.getOwnPropertyNames(Point.prototype)// [\"constructor\",\"toString\"] 上面代码采用ES5的写法，toString方法就是可枚举的。 类的属性名，可以采用表达式。 12345678910let methodName = \"getArea\";class Square&#123; constructor(length) &#123; // ... &#125; [methodName]() &#123; // ... &#125;&#125; constructor方法constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。constructor方法默认返回实例对象（即this），但是可以指定返回另外一个对象。 12345678class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;new Foo() instanceof Foo// false 类的实例对象与ES5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。 12345678910111213141516171819202122//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;var point = new Point(2, 3);point.toString() // (2, 3)point.hasOwnProperty('x') // truepoint.hasOwnProperty('y') // truepoint.hasOwnProperty('toString') // falsepoint.__proto__.hasOwnProperty('toString') // true 上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与ES5的行为保持一致。 与ES5一样，类的所有实例共享一个原型对象。 12345var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__ === p2.__proto__//true 上面代码中，p1和p2都是Point的实例，它们的原型都是Point，所以__proto__属性是相等的。这也意味着，可以通过实例的__proto__属性为Class添加方法。 12345678910var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__.printName = function () &#123; return 'Oops' &#125;;p1.printName() // \"Oops\"p2.printName() // \"Oops\"var p3 = new Point(4,2);p3.printName() // \"Oops\" 上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变Class的原始定义，影响到所有实例。 不存在变量提升Class不存在变量提升（hoist），这一点与ES5完全不同。 12new Foo(); // ReferenceErrorclass Foo &#123;&#125; 上面代码中，Foo类使用在前，定义在后，这样会报错，因为ES6不会把变量声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。 Class表达式与函数一样，Class也可以使用表达式的形式定义。 12345const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;; 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。 123let inst = new MyClass();inst.getClassName() // MeMe.name // ReferenceError: Me is not defined 上面代码表示，Me只在Class内部有定义。如果Class内部没用到的话，可以省略Me，也就是可以写成下面的形式。 1const MyClass = class &#123; /* ... */ &#125;; 采用Class表达式，可以写出立即执行的Class。 12345678910let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;('张三');person.sayName(); // \"张三\" 私有方法私有方法是常见需求，但ES6不提供，只能通过变通方法模拟实现。 一种做法是在命名上加以区别。 1234567891011121314class Widget &#123; // 公有方法 foo (baz) &#123; this._bar(baz); &#125; // 私有方法 _bar(baz) &#123; return this.snaf = baz; &#125; // ...&#125; 上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。 另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。 1234567891011class Widget &#123; foo (baz) &#123; bar.call(this, baz); &#125; // ...&#125;function bar(baz) &#123; return this.snaf = baz;&#125; 上面代码中，foo是公有方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。 还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。 12345678910111213141516const bar = Symbol('bar');const snaf = Symbol('snaf');export default subclassFactory(&#123; // 共有方法 foo (baz) &#123; this[bar](baz); &#125; // 私有方法 [bar](baz) &#123; return this[snaf] = baz; &#125;&#125;); Class的继承基本用法Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。 1class ColorPoint extends Point &#123;&#125; 上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。 12345678910class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + ' ' + super.toString(); // 调用父类的toString() &#125;&#125; 上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 12345678class Point &#123; /* ... */ &#125;class ColorPoint extends Point &#123; constructor() &#123; &#125;&#125;let cp = new ColorPoint(); // ReferenceError 上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。 ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。 123constructor(...args) &#123; super(...args);&#125; 另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。 1234567891011121314class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; this.color = color; // ReferenceError super(x, y); this.color = color; // 正确 &#125;&#125; 上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。 下面是生成子类实例的代码。 1234let cp = new ColorPoint(25, 8, 'green');cp instanceof ColorPoint // truecp instanceof Point // true 上面代码中，实例对象cp同时是ColorPoint``Point两个类的实例，这与ES5的行为完全一致。 类的prototype属性和proto属性大多数浏览器的ES5实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。 （1）子类的proto属性，表示构造函数的继承，总是指向父类。 （2）子类prototype属性的proto属性，表示方法的继承，总是指向父类的prototype属性。 12345678class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A // trueB.prototype.__proto__ === A.prototype // true 上面代码中，子类B的__proto__属性指向父类A，子类B的prototype属性的__proto__属性指向父类A的prototype属性。这样的结果是因为，类的继承是按照下面的模式实现的。 1234567891011class A &#123;&#125;class B &#123;&#125;// B的实例继承A的实例Object.setPrototypeOf(B.prototype, A.prototype);// B继承A的静态属性Object.setPrototypeOf(B, A); super关键字super这个关键字，有两种用法，含义不同。 （1）作为函数调用时（即super(...args)），super代表父类的构造函数。 （2）作为对象调用时（即super.prop或super.method()），super代表父类。注意，此时super即可以引用父类实例的属性和方法，也可以引用父类的静态方法。 12345678class B extends A &#123; get m() &#123; return this._p * super._p; &#125; set m() &#123; throw new Error('该属性只读'); &#125;&#125; 原生构造函数的继承原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript的原生构造函数大致有下面这些。 Boolean() Number() String() Array() Date() Function() RegExp() Error() Object() 以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。 123456789101112function MyArray() &#123; Array.apply(this, arguments);&#125;MyArray.prototype = Object.create(Array.prototype, &#123; constructor: &#123; value: MyArray, writable: true, configurable: true, enumerable: true &#125;&#125;); 上面代码定义了一个继承Array的MyArray类。但是，这个类的行为与Array完全不一致。 123456var colors = new MyArray();colors[0] = \"red\";colors.length // 0colors.length = 0;colors[0] // \"red\" 之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。ES5是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新length属性，这个内部属性无法在子类获取，导致子类的length属性行为不正常。 ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。 123456789101112class MyArray extends Array &#123; constructor(...args) &#123; super(...args); &#125;&#125;var arr = new MyArray();arr[0] = 12;arr.length // 1arr.length = 0;arr[0] // undefined 下面是一个自定义Error子类的例子。 1234567891011121314151617181920212223class ExtendableError extends Error &#123; constructor(message) &#123; super(); this.message = message; this.stack = (new Error()).stack; this.name = this.constructor.name; &#125;&#125;class MyError extends ExtendableError &#123; constructor(m) &#123; super(m); &#125;&#125;var myerror = new MyError('ll');myerror.message // \"ll\"myerror instanceof Error // truemyerror.name // \"MyError\"myerror.stack// Error// at MyError.ExtendableError// ... 注意，继承Object的子类，有一个行为差异。 1234567class NewObj extends Object&#123; constructor()&#123; super(...arguments); &#125;&#125;var o = new NewObj(&#123;attr: true&#125;);console.log(o.attr === true); // false 上面代码中，NewObj继承了Object，但是无法通过super方法向父类Object传参。这是因为ES6改变了Object构造函数的行为，一旦发现Object方法不是通过new Object()这种形式调用，ES6规定Object构造函数会忽略参数。 Class的取值函数（getter）和存值函数（setter）与ES5一样，在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 12345678910111213141516171819class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return 'getter'; &#125; set prop(value) &#123; console.log('setter: '+value); &#125;&#125;let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop// 'getter' Class的Generator方法如果某个方法之前加上星号（*），就表示该方法是一个Generator函数。 12345678910111213141516class Foo &#123; constructor(...args) &#123; this.args = args; &#125; * [Symbol.iterator]() &#123; for (let arg of this.args) &#123; yield arg; &#125; &#125;&#125;for (let x of new Foo('hello', 'world')) &#123; console.log(x);&#125;// hello// world Class的静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 1234567891011class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;Foo.classMethod() // 'hello'var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function 上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。 父类的静态方法，可以被子类继承。 12345678910class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod(); // 'hello' 静态方法也是可以从super对象上调用的。 12345678910111213class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123; static classMethod() &#123; return super.classMethod() + ', too'; &#125;&#125;Bar.classMethod(); Class的静态属性和实例属性静态属性指的是Class本身的属性，即Class.propname，而不是定义在实例对象（this）上的属性。 12345class Foo &#123;&#125;Foo.prop = 1;Foo.prop // 1 上面的写法为Foo类定义了一个静态属性prop。目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。 12345678910// 以下两种写法都无效class Foo &#123; // 写法一 prop: 2 // 写法二 static prop: 2&#125;Foo.prop // undefined new.target属性new是从构造函数生成实例的命令。ES6为new命令引入了一个new.target属性，（在构造函数中）返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。 12345678910111213141516171819function Person(name) &#123; if (new.target !== undefined) &#123; this.name = name; &#125; else &#123; throw new Error('必须使用new生成实例'); &#125;&#125;// 另一种写法function Person(name) &#123; if (new.target === Person) &#123; this.name = name; &#125; else &#123; throw new Error('必须使用new生成实例'); &#125;&#125;var person = new Person('张三'); // 正确var notAPerson = Person.call(person, '张三'); // 报错 上面代码确保构造函数只能通过new命令调用。Class内部调用new.target，返回当前Class。 123456789class Rectangle &#123; constructor(length, width) &#123; console.log(new.target === Rectangle); this.length = length; this.width = width; &#125;&#125;var obj = new Rectangle(3, 4); // 输出 true 需要注意的是，子类继承父类时，new.target会返回子类。 1234567891011121314class Rectangle &#123; constructor(length, width) &#123; console.log(new.target === Rectangle); // ... &#125;&#125;class Square extends Rectangle &#123; constructor(length) &#123; super(length, length); &#125;&#125;var obj = new Square(3); // 输出 false 上面代码中，new.target会返回子类。利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。 1234567891011121314151617class Shape &#123; constructor() &#123; if (new.target === Shape) &#123; throw new Error('本类不能实例化'); &#125; &#125;&#125;class Rectangle extends Shape &#123; constructor(length, width) &#123; super(); // ... &#125;&#125;var x = new Shape(); // 报错var y = new Rectangle(3, 4); // 正确 上面代码中，Shape类不能被实例化，只能用于继承。注意，在函数外部，使用new.target会报错。 Mixin模式的实现Mixin模式指的是，将多个类的接口“混入”（mix in）另一个类。它在ES6的实现如下。 12345678910111213141516171819202122function mix(...mixins) &#123; class Mix &#123;&#125; for (let mixin of mixins) &#123; copyProperties(Mix, mixin); copyProperties(Mix.prototype, mixin.prototype); &#125; return Mix;&#125;function copyProperties(target, source) &#123; for (let key of Reflect.ownKeys(source)) &#123; if ( key !== \"constructor\" &amp;&amp; key !== \"prototype\" &amp;&amp; key !== \"name\" ) &#123; let desc = Object.getOwnPropertyDescriptor(source, key); Object.defineProperty(target, key, desc); &#125; &#125;&#125; 上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。 123class DistributedEdit extends mix(Loggable, Serializable) &#123; // ...&#125; 文章参考ECMAScript 6 入门","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6学习笔记之异步操作和Async函数","date":"2016-05-21T16:00:00.000Z","path":"2016/05/22/es6-async/","text":"异步操作和Async函数异步编程对JavaScript语言太重要。Javascript语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。 ES6诞生以前，异步编程的方法，大概有下面四种。 回调函数 事件监听 发布/订阅 Promise 对象 ES6将JavaScript异步编程带入了一个全新的阶段，ES7的Async函数更是提出了异步编程的终极解决方案。 基本概念异步所谓”异步”，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。 比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。 相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。 回调函数JavaScript语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。它的英语名字callback，直译过来就是”重新调用”。 读取文件进行处理，是这样写的。 1234fs.readFile('/etc/passwd', function (err, data) &#123; if (err) throw err; console.log(data);&#125;); 上面代码中，readFile函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了/etc/passwd这个文件以后，回调函数才会执行。 Promise回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。 12345fs.readFile(fileA, function (err, data) &#123; fs.readFile(fileB, function (err, data) &#123; // ... &#125;);&#125;); 不难想象，如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为”回调函数噩梦”（callback hell）。 Promise就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用Promise，连续读取多个文件，写法如下。 123456789101112131415var readFile = require('fs-readfile-promise');readFile(fileA).then(function(data)&#123; console.log(data.toString());&#125;).then(function()&#123; return readFile(fileB);&#125;).then(function(data)&#123; console.log(data.toString());&#125;).catch(function(err) &#123; console.log(err);&#125;); Promise 的最大问题是代码冗余，原来的任务被Promise 包装了一下，不管什么操作，一眼看去都是一堆 then，原来的语义变得很不清楚。 Generator函数协程之前介绍过，这里就简单描述下。 传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。 协程有点像函数，又有点像线程。它的运行流程大致如下。 第一步，协程A开始执行。 第二步，协程A执行到一半，进入暂停，执行权转移到协程B。 第三步，（一段时间后）协程B交还执行权。 第四步，协程A恢复执行。 Thunk函数参数的求值策略Thunk函数早在上个世纪60年代就诞生了。 那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是”求值策略”，即函数的参数到底应该何时求值。 1234567var x = 1;function f(m)&#123; return m * 2;&#125;f(x + 5) 上面代码先定义函数f，然后向它传入表达式x + 5。请问，这个表达式应该何时求值？ 一种意见是”传值调用”（call by value），即在进入函数体之前，就计算x + 5的值（等于6），再将这个值传入函数f 。C语言就采用这种策略。 123f(x + 5)// 传值调用时，等同于f(6) 另一种意见是”传名调用”（call by name），即直接将表达式x + 5传入函数体，只在用到它的时候求值。Haskell语言采用这种策略。 123f(x + 5)// 传名调用时，等同于(x + 5) * 2 传值调用和传名调用，哪一种比较好？回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。 12345function f(a, b)&#123; return b;&#125;f(3 * x * x - 2 * x - 1, x); 上面代码中，函数f的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于”传名调用”，即只在执行时求值。 Thunk函数的含义编译器的”传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做Thunk函数。 123456789101112131415function f(m)&#123; return m * 2;&#125;f(x + 5);// 等同于var thunk = function () &#123; return x + 5;&#125;;function f(thunk)&#123; return thunk() * 2;&#125; 上面代码中，函数f的参数x + 5被一个函数替换了。凡是用到原参数的地方，对Thunk函数求值即可。 这就是Thunk函数的定义，它是”传名调用”的一种实现策略，用来替换某个表达式。 JavaScript语言的Thunk函数JavaScript语言是传值调用，它的Thunk函数含义有所不同。在JavaScript语言中，Thunk函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。 123456789101112// 正常版本的readFile（多参数版本）fs.readFile(fileName, callback);// Thunk版本的readFile（单参数版本）var readFileThunk = Thunk(fileName);readFileThunk(callback);var Thunk = function (fileName)&#123; return function (callback)&#123; return fs.readFile(fileName, callback); &#125;;&#125;; 上面代码中，fs模块的readFile方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做Thunk函数。 任何函数，只要参数有回调函数，就能写成Thunk函数的形式。下面是一个简单的Thunk函数转换器。 12345678910111213141516171819// ES5版本var Thunk = function(fn)&#123; return function ()&#123; var args = Array.prototype.slice.call(arguments); return function (callback)&#123; args.push(callback); return fn.apply(this, args); &#125; &#125;;&#125;;// ES6版本var Thunk = function(fn) &#123; return function (...args) &#123; return function (callback) &#123; return fn.call(this, ...args, callback); &#125; &#125;;&#125;; Thunk函数的自动流程管理Thunk函数真正的威力，在于可以自动执行Generator函数。下面就是一个基于Thunk函数的Generator执行器。 1234567891011121314151617function run(fn) &#123; var gen = fn(); function next(err, data) &#123; var result = gen.next(data); if (result.done) return; result.value(next); &#125; next();&#125;function* g() &#123; // ...&#125;run(g); 上面代码的run函数，就是一个Generator函数的自动执行器。内部的next函数就是Thunk的回调函数。next函数先将指针移到Generator函数的下一步（gen.next方法），然后判断Generator函数是否结束（result.done属性），如果没结束，就将next函数再传入Thunk函数（result.value属性），否则就直接退出。 有了这个执行器，执行Generator函数方便多了。不管内部有多少个异步操作，直接把Generator函数传入run函数即可。当然，前提是每一个异步操作，都要是Thunk函数，也就是说，跟在yield命令后面的必须是Thunk函数。 12345678var g = function* ()&#123; var f1 = yield readFile('fileA'); var f2 = yield readFile('fileB'); // ... var fn = yield readFile('fileN');&#125;;run(g); 上面代码中，函数g封装了n个异步的读取文件操作，只要执行run函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。 co模块基本用法co模块是著名程序员TJ Holowaychuk于2013年6月发布的一个小工具，用于Generator函数的自动执行。 比如，有一个Generator函数，用于依次读取两个文件。 123456var gen = function* ()&#123; var f1 = yield readFile('/etc/fstab'); var f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; co模块可以让你不用编写Generator函数的执行器。 12var co = require('co');co(gen); co函数返回一个Promise对象，因此可以用then方法添加回调函数。 123co(gen).then(function ()&#123; console.log('Generator 函数执行完成');&#125;); co模块的源码co它的源码只有几十行，非常简单。首先，co函数接受Generator函数作为参数，返回一个 Promise 对象。 123456function co(gen) &#123; var ctx = this; return new Promise(function(resolve, reject) &#123; &#125;);&#125; 在返回的Promise对象里面，co先检查参数gen是否为Generator函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将Promise对象的状态改为resolved。 12345678function co(gen) &#123; var ctx = this; return new Promise(function(resolve, reject) &#123; if (typeof gen === 'function') gen = gen.call(ctx); if (!gen || typeof gen.next !== 'function') return resolve(gen); &#125;);&#125; 接着，co将Generator函数的内部指针对象的next方法，包装成onFulfilled函数。这主要是为了能够捕捉抛出的错误。 12345678910111213141516171819function co(gen) &#123; var ctx = this; return new Promise(function(resolve, reject) &#123; if (typeof gen === 'function') gen = gen.call(ctx); if (!gen || typeof gen.next !== 'function') return resolve(gen); onFulfilled(); function onFulfilled(res) &#123; var ret; try &#123; ret = gen.next(res); &#125; catch (e) &#123; return reject(e); &#125; next(ret); &#125; &#125;);&#125; 最后，就是关键的next函数，它会反复调用自身。 1234567function next(ret) &#123; if (ret.done) return resolve(ret.value); var value = toPromise.call(ctx, ret.value); if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected); return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, ' + 'but the following object was passed: \"' + String(ret.value) + '\"'));&#125; 处理并发的异步操作co支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。这时，要把并发的操作都放在数组或对象里面，跟在yield语句后面。 1234567891011121314151617// 数组的写法co(function* () &#123; var res = yield [ Promise.resolve(1), Promise.resolve(2) ]; console.log(res);&#125;).catch(onerror);// 对象的写法co(function* () &#123; var res = yield &#123; 1: Promise.resolve(1), 2: Promise.resolve(2), &#125;; console.log(res);&#125;).catch(onerror); 下面是另一个例子。 123456789co(function* () &#123; var values = [n1, n2, n3]; yield values.map(somethingAsync);&#125;);function* somethingAsync(x) &#123; // do something async return y&#125; 上面的代码允许并发三个somethingAsync异步操作，等到它们全部完成，才会进行下一步。 async函数async函数是非常新的语法功能，新到都不属于 ES6，而是属于 ES7。目前，它仍处于提案阶段，但是转码器Babel和regenerator都已经支持，转码后就能使用。 含义ES7提供了async函数，使得异步操作变得更加方便。async函数是什么？一句话，async函数就是Generator函数的语法糖。 前文有一个Generator函数，依次读取两个文件 1234567891011121314151617var fs = require('fs');var readFile = function (fileName) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(fileName, function(error, data) &#123; if (error) reject(error); resolve(data); &#125;); &#125;);&#125;;var gen = function* ()&#123; var f1 = yield readFile('/etc/fstab'); var f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 写成async函数，就是下面这样。 123456var asyncReadFile = async function ()&#123; var f1 = await readFile('/etc/fstab'); var f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 一比较就会发现，async函数就是将Generator函数的星号（*）替换成async，将yield替换成await，仅此而已。 async函数对 Generator 函数的改进，体现在以下四点。 （1）内置执行器。Generator函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。 1var result = asyncReadFile(); 上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像Generator函数，需要调用next方法，或者用co模块，才能得到真正执行，得到最后结果。 （2）更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 （3）更广的适用性。 co模块约定，yield命令后面只能是Thunk函数或Promise对象，而async函数的await命令后面，可以是Promise对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 （4）返回值是Promise。async函数的返回值是Promise对象，这比Generator函数的返回值是Iterator对象方便多了。你可以用then方法指定下一步的操作。 进一步说，async函数完全可以看作多个异步操作，包装成的一个Promise对象，而await命令就是内部then命令的语法糖。 语法async函数的语法规则总体上比较简单，难点是错误处理机制。 （1）async函数返回一个Promise对象。 async函数内部return语句返回的值，会成为then方法回调函数的参数。 123456async function f() &#123; return 'hello world';&#125;f().then(v =&gt; console.log(v))// \"hello world\" async函数内部抛出错误，会导致返回的Promise对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。 123456789async function f() &#123; throw new Error('出错了');&#125;f().then( v =&gt; console.log(v), e =&gt; console.log(e))// Error: 出错了 （2）async函数返回的Promise对象，必须等到内部所有await命令的Promise对象执行完，才会发生状态改变。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。 1234567async function getTitle(url) &#123; let response = await fetch(url); let html = await response.text(); return html.match(/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i)[1];&#125;getTitle('https://tc39.github.io/ecma262/').then(console.log)// \"ECMAScript 2017 Language Specification\" （3）正常情况下，await命令后面是一个Promise对象。如果不是，会被转成一个立即resolve的Promise对象。 123456async function f() &#123; return await 123;&#125;f().then(v =&gt; console.log(v))// 123 上面代码中，await命令的参数是数值123，它被转成Promise对象，并立即resolve。 await命令后面的Promise对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。 12345678async function f() &#123; await Promise.reject('出错了');&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// 出错了 注意，上面代码中，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果在await前面加上return，效果是一样的。 只要一个await语句后面的Promise变为reject，那么整个async函数都会中断执行。 1234async function f() &#123; await Promise.reject('出错了'); await Promise.resolve('hello world'); // 不会执行&#125; 为了避免这个问题，可以将第一个await放在try...catch结构里面，这样第二个await就会执行。 1234567891011async function f() &#123; try &#123; await Promise.reject('出错了'); &#125; catch(e) &#123; &#125; return await Promise.resolve('hello world');&#125;f().then(v =&gt; console.log(v))// hello world 另一种方法是await后面的Promise对象再跟一个catch方法，处理前面可能出现的错误。 12345678910async function f() &#123; await Promise.reject('出错了') .catch(e =&gt; console.log(e)); return await Promise.resolve('hello world');&#125;f().then(v =&gt; console.log(v))// 出错了// hello world 如果有多个await命令，可以统一放在try...catch结构中。 123456789101112async function main() &#123; try &#123; var val1 = await firstStep(); var val2 = await secondStep(val1); var val3 = await thirdStep(val1, val2); console.log('Final: ', val3); &#125; catch (err) &#123; console.error(err); &#125;&#125; （4）如果await后面的异步操作出错，那么等同于async函数返回的Promise对象被reject。 12345678910async function f() &#123; await new Promise(function (resolve, reject) &#123; throw new Error('出错了'); &#125;);&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// Error：出错了 上面代码中，async函数f执行后，await后面的Promise对象会抛出一个错误对象，导致catch方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的async函数的实现。 防止出错的方法，也是将其放在try...catch代码块之中。 123456789async function f() &#123; try &#123; await new Promise(function (resolve, reject) &#123; throw new Error('出错了'); &#125;); &#125; catch(e) &#123; &#125; return await('hello world');&#125; 注意点 （1）await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中。 12345678910111213141516async function myFunction() &#123; try &#123; await somethingThatReturnsAPromise(); &#125; catch (err) &#123; console.log(err); &#125;&#125;// 另一种写法async function myFunction() &#123; await somethingThatReturnsAPromise() .catch(function (err) &#123; console.log(err); &#125;);&#125; （2）多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。 12345678// 写法一let [foo, bar] = await Promise.all([getFoo(), getBar()]);// 写法二let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise; 与Promise、Generator的比较我们通过一个例子，来看Async函数与Promise、Generator函数的区别。假定某个DOM元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。 首先是Promise的写法。 1234567891011121314151617181920212223function chainAnimationsPromise(elem, animations) &#123; // 变量ret用来保存上一个动画的返回值 var ret = null; // 新建一个空的Promise var p = Promise.resolve(); // 使用then方法，添加所有动画 for(var anim of animations) &#123; p = p.then(function(val) &#123; ret = val; return anim(elem); &#125;); &#125; // 返回一个部署了错误捕捉机制的Promise return p.catch(function(e) &#123; /* 忽略错误，继续执行 */ &#125;).then(function() &#123; return ret; &#125;);&#125; 虽然Promise的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是Promise的API（then、catch等等），操作本身的语义反而不容易看出来。 接着是Generator函数的写法。 1234567891011121314function chainAnimationsGenerator(elem, animations) &#123; return spawn(function*() &#123; var ret = null; try &#123; for(var anim of animations) &#123; ret = yield anim(elem); &#125; &#125; catch(e) &#123; /* 忽略错误，继续执行 */ &#125; return ret; &#125;);&#125; 上面代码使用Generator函数遍历了每个动画，语义比Promise写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行Generator函数，上面代码的spawn函数就是自动执行器，它返回一个Promise对象，而且必须保证yield语句后面的表达式，必须返回一个Promise。 最后是Async函数的写法。 1234567891011async function chainAnimationsAsync(elem, animations) &#123; var ret = null; try &#123; for(var anim of animations) &#123; ret = await anim(elem); &#125; &#125; catch(e) &#123; /* 忽略错误，继续执行 */ &#125; return ret;&#125; 可以看到Async函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将Generator写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用Generator写法，自动执行器需要用户自己提供。 文章参考ECMAScript 6 入门","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6学习笔记之Promise对象","date":"2016-05-20T16:00:00.000Z","path":"2016/05/21/es6-promise/","text":"Promise对象Promise的含义Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 如果某些事件不断地反复发生，一般来说，使用stream模式是比部署Promise更好的选择。 基本用法ES6规定，Promise对象是一个构造函数，用来生成Promise实例。下面代码创造了一个Promise实例。 123456789var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。 12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。下面是一个Promise对象的简单例子。 123456789function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, 'done'); &#125;);&#125;timeout(100).then((value) =&gt; &#123; console.log(value);&#125;); 上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为Resolved，就会触发then方法绑定的回调函数。 Promise新建后就会立即执行。 1234567891011121314let promise = new Promise(function(resolve, reject) &#123; console.log('Promise'); resolve();&#125;);promise.then(function() &#123; console.log('Resolved.');&#125;);console.log('Hi!');// Promise// Hi!// Resolved 上面代码中，Promise新建后立即执行，所以首先输出的是“Promise”。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以“Resolved”最后输出。 下面是异步加载图片的例子。 123456789101112131415function loadImageAsync(url) &#123; return new Promise(function(resolve, reject) &#123; var image = new Image(); image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error('Could not load image at ' + url)); &#125;; image.src = url; &#125;);&#125; 上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。 下面是一个用Promise对象实现的Ajax操作的例子。 1234567891011121314151617181920212223242526272829var getJSON = function(url) &#123; var promise = new Promise(function(resolve, reject)&#123; var client = new XMLHttpRequest(); client.open(\"GET\", url); client.onreadystatechange = handler; client.responseType = \"json\"; client.setRequestHeader(\"Accept\", \"application/json\"); client.send(); function handler() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; &#125;); return promise;&#125;;getJSON(\"/posts.json\").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;); 上面代码中，getJSON是对XMLHttpRequest对象的封装，用于发出一个针对JSON数据的HTTP请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个Promise实例，表示异步操作的结果有可能是一个值，也有可能是另一个异步操作，比如像下面这样。 12345678var p1 = new Promise(function (resolve, reject) &#123; // ...&#125;);var p2 = new Promise(function (resolve, reject) &#123; // ... resolve(p1);&#125;) 上面代码中，p1和p2都是Promise的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。 注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是Pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是Resolved或者Rejected，那么p2的回调函数将会立刻执行。 123456789101112ar p1 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('fail')), 3000)&#125;)var p2 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; resolve(p1), 1000)&#125;)p2 .then(result =&gt; console.log(result)) .catch(error =&gt; console.log(error))// Error: fail 上面代码中，p1是一个Promise，3秒之后变为rejected。p2的状态在1秒之后改变，resolve方法返回的是p1。此时，由于p2返回的是另一个Promise，所以后面的then语句都变成针对后者（p1）。又过了2秒，p1变为rejected，导致触发catch方法指定的回调函数。 Promise.prototype.then()Promise实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 12345getJSON(\"/posts.json\").then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; // ...&#125;); 上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 1234567getJSON(\"/post/1.json\").then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function funcA(comments) &#123; console.log(\"Resolved: \", comments);&#125;, function funcB(err)&#123; console.log(\"Rejected: \", err);&#125;); 上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为Resolved，就调用funcA，如果状态变为Rejected，就调用funcB。 如果采用箭头函数，上面的代码可以写得更简洁。 123456getJSON(\"/post/1.json\").then( post =&gt; getJSON(post.commentURL)).then( comments =&gt; console.log(\"Resolved: \", comments), err =&gt; console.log(\"Rejected: \", err)); Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 123456getJSON(\"/posts.json\").then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error);&#125;); 上面代码中，getJSON方法返回一个Promise对象，如果该对象状态变为Resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为Rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。 1234567p.then((val) =&gt; console.log(\"fulfilled:\", val)) .catch((err) =&gt; console.log(\"rejected:\", err));// 等同于p.then((val) =&gt; console.log(\"fulfilled:\", val)) .then(null, (err) =&gt; console.log(\"rejected:\", err)); 如果Promise状态已经变成Resolved，再抛出错误是无效的。 12345678var promise = new Promise(function(resolve, reject) &#123; resolve('ok'); throw new Error('test');&#125;);promise .then(function(value) &#123; console.log(value) &#125;) .catch(function(error) &#123; console.log(error) &#125;);// ok 上面代码中，Promise在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。 Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 1234567getJSON(\"/post/1.json\").then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function(comments) &#123; // some code&#125;).catch(function(error) &#123; // 处理前面三个Promise产生的错误&#125;); 一般来说，不要在then方法里面定义Reject状态的回调函数（即then的第二个参数），总是使用catch方法。 12345678910111213141516// badpromise .then(function(data) &#123; // success &#125;, function(err) &#123; // error &#125;);// goodpromise .then(function(data) &#123; //cb // success &#125;) .catch(function(err) &#123; // error &#125;); 跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。 12345678910var someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;;someAsyncThing().then(function() &#123; console.log('everything is great');&#125;); 上面代码中，someAsyncThing函数产生的Promise对象会报错，但是由于没有指定catch方法，这个错误不会被捕获，也不会传递到外层代码，导致运行后没有任何输出。注意，Chrome浏览器不遵守这条规定，它会抛出错误ReferenceError: x is not defined。 1234567var promise = new Promise(function(resolve, reject) &#123; resolve(\"ok\"); setTimeout(function() &#123; throw new Error('test') &#125;, 0)&#125;);promise.then(function(value) &#123; console.log(value) &#125;);// ok// Uncaught Error: test 上面代码中，Promise指定在下一轮“事件循环”再抛出错误，结果由于没有指定使用try...catch语句，就冒泡到最外层，成了未捕获的错误。因为此时，Promise的函数体已经运行结束了，所以这个错误是在Promise函数体外抛出的。 需要注意的是，catch方法返回的还是一个Promise对象，因此后面还可以接着调用then方法。 12345678910111213141516var someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;;someAsyncThing().catch(function(error) &#123; console.log('oh no', error);&#125;).then(function() &#123; console.log('carry on');&#125;);// oh no [ReferenceError: x is not defined]// carry on 上面代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。如果没有报错，则会跳过catch方法。 Promise.all()Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。 1var p = Promise.all([p1, p2, p3]); 上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise对象的实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。） p的状态由p1、p2、p3决定，分成两种情况。 （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 下面是一个具体的例子。 12345678910// 生成一个Promise对象的数组var promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123; return getJSON(\"/post/\" + id + \".json\");&#125;);Promise.all(promises).then(function (posts) &#123; // ...&#125;).catch(function(reason)&#123; // ...&#125;); 上面代码中，promises是包含6个Promise实例的数组，只有这6个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.allv方法后面的回调函数。 Promise.race()Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。 1var p = Promise.race([p1,p2,p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p 的回调函数。 Promise.race方法的参数与Promise.all方法一样，如果不是Promise实例，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。 下面是一个例子，如果指定时间内没有获得结果，就将Promise的状态变为reject，否则变为resolve。 12345678var p = Promise.race([ fetch('/resource-that-may-take-a-while'), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('request timeout')), 5000) &#125;)])p.then(response =&gt; console.log(response))p.catch(error =&gt; console.log(error)) 上面代码中，如果5秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。 Promise.resolve()有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。 1var jsPromise = Promise.resolve($.ajax('/whatever.json')); 上面代码将jQuery生成的deferred对象，转为一个新的Promise对象。Promise.resolve等价于下面的写法。 123Promise.resolve('foo')// 等价于new Promise(resolve =&gt; resolve('foo')) Promise.resolve方法的参数分成四种情况。 （1）参数是一个Promise实例 如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 （2）参数是一个thenable对象 thenable对象指的是具有then方法的对象，比如下面这个对象。 12345let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;; Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法。 12345678910let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function(value) &#123; console.log(value); // 42&#125;); 上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出42。 （3）参数不是具有then方法的对象，或根本就不是对象 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为Resolved。 123456var p = Promise.resolve('Hello');p.then(function (s)&#123; console.log(s)&#125;);// Hello 上面代码生成一个新的Promise对象的实例p。由于字符串Hello不属于异步操作（判断方法是它不是具有then方法的对象），返回Promise实例的状态从一生成就是Resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。 （4）不带有任何参数 Promise.resolve方法允许调用时不带参数，直接返回一个Resolved状态的Promise对象。所以，如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法。 12345var p = Promise.resolve();p.then(function () &#123; // ...&#125;); 上面代码的变量p就是一个Promise对象。需要注意的是，立即resolve的Promise对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。 12345678910111213setTimeout(function () &#123; console.log('three');&#125;, 0);Promise.resolve().then(function () &#123; console.log('two');&#125;);console.log('one');// one// two// three 上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(&#39;one&#39;)则是立即执行，因此最先输出。 Promise.reject()Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。它的参数用法与Promise.resolve方法完全一致。 12345678var p = Promise.reject('出错了');// 等同于var p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s)&#123; console.log(s)&#125;);// 出错了 上面代码生成一个Promise对象的实例p，状态为rejected，回调函数会立即执行。 两个有用的附加方法ES6的Promise API提供的方法不是很多，有些有用的方法可以自己部署。下面介绍如何部署两个不在ES6之中、但很有用的方法。 done()Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。 12345asyncFunc() .then(f1) .catch(r1) .then(f2) .done(); 它的实现代码相当简单。 1234567Promise.prototype.done = function (onFulfilled, onRejected) &#123; this.then(onFulfilled, onRejected) .catch(function (reason) &#123; // 抛出一个全局错误 setTimeout(() =&gt; &#123; throw reason &#125;, 0); &#125;);&#125;; 从上面代码可见，done方法的使用，可以像then方法那样用，提供Fulfilled和Rejected状态的回调函数，也可以不提供任何参数。但不管怎样，done都会捕捉到任何可能出现的错误，并向全局抛出。 finally()finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。 下面是一个例子，服务器使用Promise处理请求，然后使用finally方法关掉服务器。 12345server.listen(0) .then(function () &#123; // run test &#125;) .finally(server.stop); 它的实现也很简单。 1234567Promise.prototype.finally = function (callback) &#123; let P = this.constructor; return this.then( value =&gt; P.resolve(callback()).then(() =&gt; value), reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) );&#125;; 上面代码中，不管前面的Promise是fulfilled还是rejected，都会执行回调函数callback。 应用加载图片我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。 12345678const preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; var image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;);&#125;; Generator函数与Promise的结合使用Generator函数管理流程，遇到异步操作的时候，通常返回一个Promise对象 1234567891011121314151617181920212223242526272829303132function getFoo () &#123; return new Promise(function (resolve, reject)&#123; resolve('foo'); &#125;);&#125;var g = function* () &#123; try &#123; var foo = yield getFoo(); console.log(foo); &#125; catch (e) &#123; console.log(e); &#125;&#125;;function run (generator) &#123; var it = generator(); function go(result) &#123; if (result.done) return result.value; return result.value.then(function (value) &#123; return go(it.next(value)); &#125;, function (error) &#123; return go(it.throw(error)); &#125;); &#125; go(it.next());&#125;run(g); 上面代码的Generator函数g之中，有一个异步操作getFoo，它返回的就是一个Promise对象。函数run用来处理这个Promise对象，并调用下一个next方法。 文章参考ECMAScript 6 入门","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6学习笔记之Generator 函数","date":"2016-05-14T16:00:00.000Z","path":"2016/05/15/es6-generator/","text":"Generator 函数简介基本概念Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。 Generator函数有多种理解角度。从语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。 执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。 形式上，Generator函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield语句，定义不同的内部状态（yield语句在英语里的意思就是“产出”）。 1234567function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator(); 上面代码定义了一个Generator函数helloWorldGenerator，它内部有两个yield语句“hello”和“world”，即该函数有三个状态：hello，world和return语句（结束执行）。 然后，Generator函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象Iterator Object。 下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。换言之，Generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行。 1234567891011hw.next()// &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; ES6没有规定，function关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。 1234567function * foo(x, y) &#123; ··· &#125;function *foo(x, y) &#123; ··· &#125;function* foo(x, y) &#123; ··· &#125;function*foo(x, y) &#123; ··· &#125; 由于Generator函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在function关键字后面。 yield语句由于Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield语句就是暂停标志。 遍历器对象的next方法的运行逻辑如下。 （1）遇到yield语句，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 （2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield语句。 （3）如果没有再遇到新的yield语句，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 （4）如果该函数没有return语句，则返回的对象的value属性值为undefined。 需要注意的是，yield语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为JavaScript提供了手动的“惰性求值”Lazy Evaluation的语法功能。 123function* gen() &#123; yield 123 + 456;&#125; 上面代码中，yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值。 另外需要注意，yield语句不能用在普通函数中，否则会报错。 1234(function ()&#123; yield 1;&#125;)()// SyntaxError: Unexpected number 上面代码在一个普通函数中使用yield语句，结果产生一个句法错误。另外，yield语句如果用在一个表达式之中，必须放在圆括号里面。 12345console.log('Hello' + yield); // SyntaxErrorconsole.log('Hello' + yield 123); // SyntaxErrorconsole.log('Hello' + (yield)); // OKconsole.log('Hello' + (yield 123)); // OK yield语句用作函数参数或赋值表达式的右边，可以不加括号。 12foo(yield 'a', yield 'b'); // OKlet input = yield; // OK 与Iterator接口的关系上一章说过，任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。 由于Generator函数就是遍历器生成函数，因此可以把Generator赋值给对象的Symbol.iterator属性，从而使得该对象具有Iterator接口。 12345678var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3] 上面代码中，Generator函数赋值给Symbol.iterator属性，从而使得myIterable对象具有了Iterator接口，可以被...运算符遍历了。 Generator函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。 12345678function* gen()&#123; // some code&#125;var g = gen();g[Symbol.iterator]() === g// true 上面代码中，gen是一个Generator函数，调用它会生成一个遍历器对象g。它的Symbol.iterator属性，也是一个遍历器对象生成函数，执行后返回它自己。 next方法的参数yield句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值。 123456789101112function* f() &#123; for(var i=0; true; i++) &#123; var reset = yield i; if(reset) &#123; i = -1; &#125; &#125;&#125;var g = f();g.next() // &#123; value: 0, done: false &#125;g.next() // &#123; value: 1, done: false &#125;g.next(true) // &#123; value: 0, done: false &#125; 上面代码先定义了一个可以无限运行的Generator函数f，如果next方法没有参数，每次运行到yield语句，变量reset的值总是undefined。当next方法带一个参数true时，当前的变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。 这个功能有很重要的语法意义。Generator函数从暂停状态到恢复运行，它的上下文状态context是不变的。通过next方法的参数，就有办法在Generator函数开始运行之后，继续向函数体内部注入值。也就是说，可以在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。 123456789101112131415function* foo(x) &#123; var y = 2 * (yield (x + 1)); var z = yield (y / 3); return (x + y + z);&#125;var a = foo(5);a.next() // Object&#123;value:6, done:false&#125;a.next() // Object&#123;value:NaN, done:false&#125;a.next() // Object&#123;value:NaN, done:true&#125;var b = foo(5);b.next() // &#123; value:6, done:false &#125;b.next(12) // &#123; value:8, done:false &#125;b.next(13) // &#123; value:42, done:true &#125; 上面代码第一次调用a的next方法时，返回x+1的值6；第二次运行next方法的时候不带参数，导致y的值等于2 * undefined（即NaN），除以3以后还是NaN，因此返回对象的value属性也等于NaN。第三次运行next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + NaN + undefined，即NaN。 上面代码第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield语句的值设为12，因此y等于24，返回y / 3的值8；第三次调用next方法，将上一次yield语句的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。 注意，由于next方法的参数表示上一个yield语句的返回值，所以第一次使用next方法时，不能带有参数。V8引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。 如果想要第一次调用next方法时，就能够输入值，可以在Generator函数外面再包一层。 123456789101112131415function wrapper(generatorFunction) &#123; return function (...args) &#123; let generatorObject = generatorFunction(...args); generatorObject.next(); return generatorObject; &#125;;&#125;const wrapped = wrapper(function* () &#123; console.log(`First input: $&#123;yield&#125;`); return 'DONE';&#125;);wrapped().next('hello!')// First input: hello! 再看一个通过next方法的参数，向Generator函数内部输入值的例子。 1234567891011121314function* dataConsumer() &#123; console.log('Started'); console.log(`1. $&#123;yield&#125;`); console.log(`2. $&#123;yield&#125;`); return 'result';&#125;let genObj = dataConsumer();genObj.next();// StartedgenObj.next('a')// 1. agenObj.next('b')// 2. b for…of循环for...of循环可以自动遍历调用Generator函数时生成的Iterator对象，且此时不再需要调用next方法。 12345678910111213function *foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let v of foo()) &#123; console.log(v);&#125;// 1 2 3 4 5 上面代码使用for...of循环，依次显示5个yield语句的值。这里需要注意，一旦next方法的返回对象的done属性为true，for...of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for...of循环之中。 下面是一个利用Generator函数和for…of循环，实现斐波那契数列的例子。 123456789101112function* fibonacci() &#123; let [prev, curr] = [0, 1]; for (;;) &#123; [prev, curr] = [curr, prev + curr]; yield curr; &#125;&#125;for (let n of fibonacci()) &#123; if (n &gt; 1000) break; console.log(n);&#125; 利用for...of循环，可以写出遍历任意对象的方法。原生的JavaScript对象没有遍历接口，无法使用for...of循环，通过Generator函数为它加上这个接口，就可以用了。 123456789101112131415function* objectEntries(obj) &#123; let propKeys = Reflect.ownKeys(obj); for (let propKey of propKeys) &#123; yield [propKey, obj[propKey]]; &#125;&#125;let jane = &#123; first: 'Jane', last: 'Doe' &#125;;for (let [key, value] of objectEntries(jane)) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe Generator.prototype.throw()Generator函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在Generatorbbxb函数体内捕获。 12345678910111213141516171819var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log('内部捕获', e); &#125;&#125;;var i = g();i.next();try &#123; i.throw('a'); i.throw('b');&#125; catch (e) &#123; console.log('外部捕获', e);&#125;// 内部捕获 a// 外部捕获 b 上面代码中，遍历器对象i连续抛出两个错误。第一个错误被Generator函数体内的catch语句捕获。i第二次抛出错误，由于Generator函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了Generator函数体，被函数体外的catch语句捕获。 注意，不要混淆遍历器对象的throw方法和全局的throw命令。上面代码的错误，是用遍历器对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获。 123456789101112131415161718192021var g = function* () &#123; while (true) &#123; try &#123; yield; &#125; catch (e) &#123; if (e != 'a') throw e; console.log('内部捕获', e); &#125; &#125;&#125;;var i = g();i.next();try &#123; throw new Error('a'); throw new Error('b');&#125; catch (e) &#123; console.log('外部捕获', e);&#125;// 外部捕获 [Error: a] 上面代码之所以只捕获了a，是因为函数体外的catch语句块，捕获了抛出的a错误以后，就不会再继续try代码块里面剩余的语句了。 如果Generator函数内部部署了try...catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历，否则遍历直接终止。 123456789101112131415var gen = function* gen()&#123; try &#123; yield console.log('hello'); &#125; catch (e) &#123; // ... &#125; yield console.log('world');&#125;var g = gen();g.next();g.throw();g.next();// hello// world 一旦Generator执行过程中抛出错误，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即JavaScript引擎认为这个Generator已经运行结束了。 123456789101112131415161718192021222324252627282930313233343536373839function* g() &#123; yield 1; console.log('throwing an exception'); throw new Error('generator broke!'); yield 2; yield 3;&#125;function log(generator) &#123; var v; console.log('starting generator'); try &#123; v = generator.next(); console.log('第一次运行next方法', v); &#125; catch (err) &#123; console.log('捕捉错误', v); &#125; try &#123; v = generator.next(); console.log('第二次运行next方法', v); &#125; catch (err) &#123; console.log('捕捉错误', v); &#125; try &#123; v = generator.next(); console.log('第三次运行next方法', v); &#125; catch (err) &#123; console.log('捕捉错误', v); &#125; console.log('caller done');&#125;log(g());// starting generator// 第一次运行next方法 &#123; value: 1, done: false &#125;// throwing an exception// 捕捉错误 &#123; value: 1, done: false &#125;// 第三次运行next方法 &#123; value: undefined, done: true &#125;// caller done 上面代码一共三次运行next方法，第二次运行的时候会抛出错误，然后第三次运行的时候，Generator函数就已经结束了，不再执行下去了。 Generator.prototype.return()Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。 1234567891011function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return('foo') // &#123; value: \"foo\", done: true &#125;g.next() // &#123; value: undefined, done: true &#125; 如果return方法调用时，不提供参数，则返回值的value属性为undefined。 12345678910function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return() // &#123; value: undefined, done: true &#125; 如果Generator函数内部有try...finally代码块，那么return方法会推迟到finally代码块执行完再执行。 1234567891011121314151617function* numbers () &#123; yield 1; try &#123; yield 2; yield 3; &#125; finally &#123; yield 4; yield 5; &#125; yield 6;&#125;var g = numbers()g.next() // &#123; done: false, value: 1 &#125;g.next() // &#123; done: false, value: 2 &#125;g.return(7) // &#123; done: false, value: 4 &#125;g.next() // &#123; done: false, value: 5 &#125;g.next() // &#123; done: true, value: 7 &#125; yield*语句如果在Generater函数内部，调用另一个Generator函数，默认情况下是没有效果的。 12345678910111213141516function* foo() &#123; yield 'a'; yield 'b';&#125;function* bar() &#123; yield 'x'; foo(); yield 'y';&#125;for (let v of bar())&#123; console.log(v);&#125;// \"x\"// \"y\" 上面代码中，foo和bar都是Generator函数，在bar里面调用foo，是不会有效果的。这个就需要用到yield*语句，用来在一个Generator函数里面执行另一个Generator函数 123456789101112131415161718192021222324252627282930function* bar() &#123; yield 'x'; yield* foo(); yield 'y';&#125;// 等同于function* bar() &#123; yield 'x'; yield 'a'; yield 'b'; yield 'y';&#125;// 等同于function* bar() &#123; yield 'x'; for (let v of foo()) &#123; yield v; &#125; yield 'y';&#125;for (let v of bar())&#123; console.log(v);&#125;// \"x\"// \"a\"// \"b\"// \"y\" 从语法角度看，如果yield命令后面跟的是一个遍历器对象，需要在yield命令后面加上星号，表明它返回的是一个遍历器对象。这被称为yield*语句。 123456789101112131415161718let delegatedIterator = (function* () &#123; yield 'Hello!'; yield 'Bye!';&#125;());let delegatingIterator = (function* () &#123; yield 'Greetings!'; yield* delegatedIterator; yield 'Ok, bye.';&#125;());for(let value of delegatingIterator) &#123; console.log(value);&#125;// \"Greetings!// \"Hello!\"// \"Bye!\"// \"Ok, bye.\" 上面代码中，delegatingIterator是代理者，delegatedIterator是被代理者。由于yield* delegatedIterator语句得到的值，是一个遍历器，所以要用星号表示。运行结果就是使用一个遍历器，遍历了多个Generator函数，有递归的效果。 yield*后面的Generator函数（没有return语句时），等同于在Generator函数内部，部署一个for...of循环。 123456789101112131415function* concat(iter1, iter2) &#123; yield* iter1; yield* iter2;&#125;// 等同于function* concat(iter1, iter2) &#123; for (var value of iter1) &#123; yield value; &#125; for (var value of iter2) &#123; yield value; &#125;&#125; 上面代码说明，yield* 后面的Generator函数（没有return语句时），不过是for...of的一种简写形式，完全可以用后者替代前者。反之，则需要用var value = yield* iterator的形式获取return语句的值。 实际上，任何数据结构只要有Iterator接口，就可以被yield*遍历。 1234567let read = (function* () &#123; yield 'hello'; yield* 'hello';&#125;)();read.next().value // \"hello\"read.next().value // \"h\" 上面代码中，yield命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。 yield*命令可以很方便地取出嵌套数组的所有成员。 1234567891011121314151617181920function* iterTree(tree) &#123; if (Array.isArray(tree)) &#123; for(let i=0; i &lt; tree.length; i++) &#123; yield* iterTree(tree[i]); &#125; &#125; else &#123; yield tree; &#125;&#125;const tree = [ 'a', ['b', 'c'], ['d', 'e'] ];for(let x of iterTree(tree)) &#123; console.log(x);&#125;// a// b// c// d// e 下面是一个稍微复杂的例子，使用yield*语句遍历完全二叉树。 1234567891011121314151617181920212223242526272829303132333435// 下面是二叉树的构造函数，// 三个参数分别是左树、当前节点和右树function Tree(left, label, right) &#123; this.left = left; this.label = label; this.right = right;&#125;// 下面是中序（inorder）遍历函数。// 由于返回的是一个遍历器，所以要用generator函数。// 函数体内采用递归算法，所以左树和右树要用yield*遍历function* inorder(t) &#123; if (t) &#123; yield* inorder(t.left); yield t.label; yield* inorder(t.right); &#125;&#125;// 下面生成二叉树function make(array) &#123; // 判断是否为叶节点 if (array.length == 1) return new Tree(null, array[0], null); return new Tree(make(array[0]), array[1], make(array[2]));&#125;let tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);// 遍历二叉树var result = [];for (let node of inorder(tree)) &#123; result.push(node);&#125;//result// ['a', 'b', 'c', 'd', 'e', 'f', 'g'] Generator函数的thisGenerator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的prototype对象上的方法。 12345678910function* g() &#123;&#125;g.prototype.hello = function () &#123; return 'hi!';&#125;;let obj = g();obj instanceof g // trueobj.hello() // 'hi!' 上面代码表明，Generator函数g返回的遍历器obj，是g的实例，而且继承了g.prototype。但是，如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。 123456function* g() &#123; this.a = 11;&#125;let obj = g();obj.a // undefined 上面代码中，Generator函数g在this对象上面添加了一个属性a，但是obj对象拿不到这个属性。Generator函数也不能跟new命令一起用，会报错。 1234567function* F() &#123; yield this.x = 2; yield this.y = 3;&#125;new F()// TypeError: F is not a constructor 那么，有没有办法让Generator函数返回一个正常的对象实例，既可以用next方法，又可以获得正常的this？ 下面是一个变通方法。首先，生成一个空对象，使用bind方法绑定Generator函数内部的this。这样，构造函数调用以后，这个空对象就是Generator函数的实例对象了。 123456789101112131415function* F() &#123; this.a = 1; yield this.b = 2; yield this.c = 3;&#125;var obj = &#123;&#125;;var f = F.call(obj);f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;obj.a // 1obj.b // 2obj.c // 3 上面代码中，首先是F内部的this对象绑定obj对象，然后调用它，返回一个Iterator对象。这个对象执行三次next方法（因为F内部有两个yield语句），完成F内部所有代码的运行。这时，所有内部属性都绑定在obj对象上了，因此obj对象也就成了F的实例。 上面代码中，执行的是遍历器对象f，但是生成的对象实例是obj ，有没有办法将这两个对象统一呢？一个办法就是将obj换成F.prototype。 1234567891011121314function* F() &#123; this.a = 1; yield this.b = 2; yield this.c = 3;&#125;var f = F.call(F.prototype);f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3 再将F改成构造函数，就可以对它执行new命令了。 12345678910111213141516171819function* gen() &#123; this.a = 1; yield this.b = 2; yield this.c = 3;&#125;function F() &#123; return gen.call(gen.prototype);&#125;var f = new F();f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3 含义Generator与状态机Generator是实现状态机的最佳结构。比如，下面的clock函数就是一个状态机。 12345678var ticking = true;var clock = function() &#123; if (ticking) console.log('Tick!'); else console.log('Tock!'); ticking = !ticking;&#125; 上面代码的clock函数一共有两种状态（Tick和Tock），每运行一次，就改变一次状态。这个函数如果用Generator实现，就是下面这样。 12345678var clock = function*() &#123; while (true) &#123; console.log('Tick!'); yield; console.log('Tock!'); yield; &#125;&#125;; 上面的Generator实现与ES5实现对比，可以看到少了用来保存状态的外部变量ticking，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。 Generator与协程协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。 （1）协程与子例程的差异 传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。 从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。 （2）协程与普通线程的差异 不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。 由于ECMAScript是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。 Generator函数是ECMAScript 6对协程的实现，但属于不完全实现。Generator函数被称为“半协程”（semi-coroutine），意思是只有Generator函数的调用者，才能将程序的执行权还给Generator函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。 如果将Generator函数当作协程，完全可以将多个需要互相协作的任务写成Generator函数，它们之间使用yield语句交换控制权。 应用Generator可以暂停函数执行，返回任意表达式的值。这种特点使得Generator有多种应用场景。 （1）异步操作的同步化表达Generator函数的暂停执行的效果，意味着可以把异步操作写在yield语句里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield语句下面，反正要等到调用next方法时再执行。所以，Generator函数的一个重要实际意义就是用来处理异步操作，改写回调函数。 1234567891011121314151617181920212223242526function* loadUI() &#123; showLoadingScreen(); yield loadUIDataAsynchronously(); hideLoadingScreen();&#125;function showLoadingScreen () &#123; console.log(\"showLoadingScreen\");&#125;function loadUIDataAsynchronously () &#123; console.log(\"loadUIDataAsynchronously\");&#125;function hideLoadingScreen () &#123; console.log(\"hideLoadingScreen\");&#125;var loader = loadUI();// 加载UIloader.next()// 卸载UIloader.next()// showLoadingScreen// loadUIDataAsynchronously// hideLoadingScreen// &#123;value: undefined, done: true&#125; 上面代码表示，第一次调用loadUI函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用next方法，则会显示Loading界面，并且异步加载数据。等到数据加载完成，再一次使用next方法，则会隐藏Loading界面。可以看到，这种写法的好处是所有Loading界面的逻辑，都被封装在一个函数，按部就班非常清晰。 Ajax是典型的异步操作，通过Generator函数部署Ajax操作，可以用同步的方式表达。 1234567891011121314function* main() &#123; var result = yield request(\"http://some.url\"); var resp = JSON.parse(result); console.log(resp.value);&#125;function request(url) &#123; makeAjaxCall(url, function(response)&#123; it.next(response); &#125;);&#125;var it = main();it.next(); 上面代码的main函数，就是通过Ajax操作获取数据。可以看到，除了多了一个yield，它几乎与同步操作的写法完全一样。注意，makeAjaxCall函数中的next方法，必须加上response参数，因为yield语句构成的表达式，本身是没有值的，总是等于undefined。 下面是另一个例子，通过Generator函数逐行读取文本文件。 12345678910function* numbers() &#123; let file = new FileReader(\"numbers.txt\"); try &#123; while(!file.eof) &#123; yield parseInt(file.readLine(), 10); &#125; &#125; finally &#123; file.close(); &#125;&#125; （2）控制流管理如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。 123456789step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // Do something with value4 &#125;); &#125;); &#125;);&#125;); 采用Promise改写上面的代码。 12345678910Q.fcall(step1) .then(step2) .then(step3) .then(step4) .then(function (value4) &#123; // Do something with value4 &#125;, function (error) &#123; // Handle any error from step1 through step4 &#125;) .done(); 上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量Promise的语法。Generator函数可以进一步改善代码运行流程。 1234567891011function* longRunningTask() &#123; try &#123; var value1 = yield step1(); var value2 = yield step2(value1); var value3 = yield step3(value2); var value4 = yield step4(value3); // Do something with value4 &#125; catch (e) &#123; // Handle any error from step1 through step4 &#125;&#125; 然后，使用一个函数，按次序自动执行所有步骤。 123456789101112scheduler(longRunningTask());function scheduler(task) &#123; setTimeout(function() &#123; var taskObj = task.next(task.value); // 如果Generator函数未结束，就继续调用 if (!taskObj.done) &#123; task.value = taskObj.value scheduler(task); &#125; &#125;, 0);&#125; 注意，yield语句是同步运行，不是异步运行（否则就失去了取代回调函数的设计目的了）。实际操作中，一般让yield语句返回Promise对象。 1234567891011var Q = require('q');function delay(milliseconds) &#123; var deferred = Q.defer(); setTimeout(deferred.resolve, milliseconds); return deferred.promise;&#125;function* f()&#123; yield delay(100);&#125;; 上面代码使用Promise的函数库Q，yield语句返回的就是一个Promise对象。如果yield语句后面的参数，是一个具有遍历器接口的对象，yield会遍历这个对象，再往下执行。这意味着，多个任务按顺序一个接一个执行时，yield语句可以按顺序排列。多个任务需要并列执行时（比如只有A任务和B任务都执行完，才能执行C任务），可以采用数组的写法。 1234567function* parallelTasks() &#123; let [resultA, resultB] = yield [ taskA(), taskB() ]; console.log(resultA, resultB);&#125; 上面代码中，yield语句的参数是一个数组，成员就是两个任务taskA和taskB，只有等这两个任务都完成了，才会接着执行下面的语句。 （3）部署iterator接口利用Generator函数，可以在任意对象上部署iterator接口。 12345678910111213141516function* iterEntries(obj) &#123; let keys = Object.keys(obj); for (let i=0; i &lt; keys.length; i++) &#123; let key = keys[i]; yield [key, obj[key]]; &#125;&#125;let myObj = &#123; foo: 3, bar: 7 &#125;;for (let [key, value] of iterEntries(myObj)) &#123; console.log(key, value);&#125;// foo 3// bar 7 上述代码中，myObj是一个普通对象，通过iterEntries函数，就有了iterator接口。也就是说，可以在任意对象上部署next方法。 下面是一个对数组部署Iterator接口的例子，尽管数组原生具有这个接口。 12345678910111213function* makeSimpleGenerator(array)&#123; var nextIndex = 0; while(nextIndex &lt; array.length)&#123; yield array[nextIndex++]; &#125;&#125;var gen = makeSimpleGenerator(['yo', 'ya']);gen.next().value // 'yo'gen.next().value // 'ya'gen.next().done // true （4）作为数据结构Generator可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为Generator函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。 12345function *doStuff() &#123; yield fs.readFile.bind(null, 'hello.txt'); yield fs.readFile.bind(null, 'world.txt'); yield fs.readFile.bind(null, 'and-such.txt');&#125; 上面代码就是依次返回三个函数，但是由于使用了Generator函数，导致可以像处理数组那样，处理这三个返回的函数。 123for (task of doStuff()) &#123; // task是一个函数，可以像回调函数那样使用它&#125; 文章参考ECMAScript 6 入门","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6学习笔记之Iterator和for...of循环","date":"2016-05-13T16:00:00.000Z","path":"2016/05/14/es6-iterator/","text":"Iterator和for…of循环Iterator（遍历器）的概念JavaScript原有的表示“集合”的数据结构，主要是数组Array和对象Object，ES6又添加了Map和Set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。 遍历器Iterator就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 Iterator的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费。 Iterator的遍历过程是这样的： （1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 （2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。 （3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。 （4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。 每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。 下面是一个模拟next方法返回值的例子。 12345678910111213141516var it = makeIterator(['a', 'b']);it.next() // &#123; value: \"a\", done: false &#125;it.next() // &#123; value: \"b\", done: false &#125;it.next() // &#123; value: undefined, done: true &#125;function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function() &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125;;&#125; 上面代码定义了一个makeIterator函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组[&#39;a&#39;, &#39;b&#39;]执行这个函数，就会返回该数组的遍历器对象（即指针对象）it。 指针对象的next方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用next方法，指针就会指向数组的下一个成员。第一次调用，指向a；第二次调用，指向b。 next方法返回一个对象，表示当前数据成员的信息。这个对象具有value和done两个属性，value属性返回当前位置的成员，done属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next方法。 总之，调用指针对象的next方法，就可以遍历事先给定的数据结构。 对于遍历器对象来说，done: false和value: undefined属性都是可以省略的，因此上面的makeIterator函数可以简写成下面的形式。 12345678910function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function() &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++]&#125; : &#123;done: true&#125;; &#125; &#125;;&#125; 由于Iterator只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。下面是一个无限运行的遍历器对象的例子。 12345678910111213141516var it = idMaker();it.next().value // '0'it.next().value // '1'it.next().value // '2'// ...function idMaker() &#123; var index = 0; return &#123; next: function() &#123; return &#123;value: index++, done: false&#125;; &#125; &#125;;&#125; 在ES6中，有些数据结构原生具备Iterator接口（比如数组），即不用任何处理，就可以被for...of循环遍历，有些就不行（比如对象）。原因在于，这些数据结构原生部署了Symbol.iterator属性，另外一些数据结构没有。凡是部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。 数据结构的默认Iterator接口Iterator接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for...of循环。当使用for...of循环遍历某种数据结构时，该循环会自动去寻找Iterator接口。 ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”iterable。调用Symbol.iterator方法，就会得到当前数据结构默认的遍历器生成函数。Symbol.iterator本身是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为Symbol的特殊值，所以要放在方括号内。 在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。 1234567let arr = ['a', 'b', 'c'];let iter = arr[Symbol.iterator]();iter.next() // &#123; value: 'a', done: false &#125;iter.next() // &#123; value: 'b', done: false &#125;iter.next() // &#123; value: 'c', done: false &#125;iter.next() // &#123; value: undefined, done: true &#125; 原生就部署Iterator接口的数据结构有三类，对于这三类数据结构，不用自己写遍历器生成函数，for...of循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的Iterator接口，都需要自己在Symbol.iterator属性上面部署，这样才会被for...of循环遍历。 对象（Object）之所以没有默认部署Iterator接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作Map结构使用，ES5没有Map结构，而ES6原生提供了。 一个对象如果要有可被for...of循环调用的Iterator接口，就必须在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。 1234567891011121314151617181920212223242526class RangeIterator &#123; constructor(start, stop) &#123; this.value = start; this.stop = stop; &#125; [Symbol.iterator]() &#123; return this; &#125; next() &#123; var value = this.value; if (value &lt; this.stop) &#123; this.value++; return &#123;done: false, value: value&#125;; &#125; else &#123; return &#123;done: true, value: undefined&#125;; &#125; &#125;&#125;function range(start, stop) &#123; return new RangeIterator(start, stop);&#125;for (var value of range(0, 3)) &#123; console.log(value);&#125; 上面代码是一个类部署Iterator接口的写法。Symbol.iterator属性对应一个函数，执行后返回当前对象的遍历器对象。下面是通过遍历器实现指针结构的例子。 123456789101112131415161718192021222324252627282930313233343536373839404142function Obj(value) &#123; this.value = value; this.next = null;&#125;Obj.prototype[Symbol.iterator] = function() &#123; var iterator = &#123; next: next &#125;; var current = this; function next() &#123; if (current) &#123; var value = current.value; current = current.next; return &#123; done: false, value: value &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125; &#125; return iterator;&#125;var one = new Obj(1);var two = new Obj(2);var three = new Obj(3);one.next = two;two.next = three;for (var i of one)&#123; console.log(i);&#125;// 1// 2// 3 上面代码首先在构造函数的原型链上部署Symbol.iterator方法，调用该方法会返回遍历器对象iterator，调用该对象的next方法，在返回一个值的同时，自动将内部指针移到下一个实例。 下面是另一个为对象添加Iterator接口的例子。 12345678910111213141516171819let obj = &#123; data: [ 'hello', 'world' ], [Symbol.iterator]() &#123; const self = this; let index = 0; return &#123; next() &#123; if (index &lt; self.data.length) &#123; return &#123; value: self.data[index++], done: false &#125;; &#125; else &#123; return &#123; value: undefined, done: true &#125;; &#125; &#125; &#125;; &#125;&#125;; 对于类似数组的对象（存在数值键名和length属性），部署Iterator接口，有一个简便方法，就是Symbol.iterator方法直接引用数组的Iterator接口。 12345NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];// 或者NodeList.prototype[Symbol.iterator] = [][Symbol.iterator];[...document.querySelectorAll('div')] // 可以执行了 下面是类似数组的对象调用数组的Symbol.iterator方法的例子。 12345678910let iterable = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator]&#125;;for (let item of iterable) &#123; console.log(item); // 'a', 'b', 'c'&#125; 注意，普通对象部署数组的Symbol.iterator方法，并无效果。 12345678910let iterable = &#123; a: 'a', b: 'b', c: 'c', length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator]&#125;;for (let item of iterable) &#123; console.log(item); // undefined, undefined, undefined&#125; 如果Symbol.iterator方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。 12345var obj = &#123;&#125;;obj[Symbol.iterator] = () =&gt; 1;[...obj] // TypeError: [] is not a function 上面代码中，变量obj的Symbol.iterator方法对应的不是遍历器生成函数，因此报错。 调用Iterator接口的场合有一些场合会默认调用Iterator接口（即Symbol.iterator方法），除了下文会介绍的for...of循环，还有几个别的场合。 （1）解构赋值对数组和Set结构进行解构赋值时，会默认调用Symbol.iterator方法。 1234567let set = new Set().add('a').add('b').add('c');let [x,y] = set;// x='a'; y='b'let [first, ...rest] = set;// first='a'; rest=['b','c']; （2）扩展运算符扩展运算符（…）也会调用默认的iterator接口。 12345678// 例一var str = 'hello';[...str] // ['h','e','l','l','o']// 例二let arr = ['b', 'c'];['a', ...arr, 'd']// ['a', 'b', 'c', 'd'] （3）yield*yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。 1234567891011121314let generator = function* () &#123; yield 1; yield* [2,3,4]; yield 5;&#125;;var iterator = generator();iterator.next() // &#123; value: 1, done: false &#125;iterator.next() // &#123; value: 2, done: false &#125;iterator.next() // &#123; value: 3, done: false &#125;iterator.next() // &#123; value: 4, done: false &#125;iterator.next() // &#123; value: 5, done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125; （4）其他场合由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。 for…of Array.from() Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])） Promise.all() Promise.race() 字符串的Iterator接口字符串是一个类似数组的对象，也原生具有Iterator接口。 123456789var someString = \"hi\";typeof someString[Symbol.iterator]// \"function\"var iterator = someString[Symbol.iterator]();iterator.next() // &#123; value: \"h\", done: false &#125;iterator.next() // &#123; value: \"i\", done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125; 上面代码中，调用Symbol.iterator方法返回一个遍历器对象，在这个遍历器上可以调用next方法，实现对于字符串的遍历。 可以覆盖原生的Symbol.iterator方法，达到修改遍历器行为的目的。 1234567891011121314151617181920var str = new String(\"hi\");[...str] // [\"h\", \"i\"]str[Symbol.iterator] = function() &#123; return &#123; next: function() &#123; if (this._first) &#123; this._first = false; return &#123; value: \"bye\", done: false &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125; &#125;, _first: true &#125;;&#125;;[...str] // [\"bye\"]str // \"hi\" Iterator接口与Generator函数Symbol.iterator方法的最简单实现，还是使用下一章要介绍的Generator函数。 1234567891011121314151617181920212223var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3]// 或者采用下面的简洁写法let obj = &#123; * [Symbol.iterator]() &#123; yield 'hello'; yield 'world'; &#125;&#125;;for (let x of obj) &#123; console.log(x);&#125;// hello// world 遍历器对象的return()，throw()遍历器对象除了具有next方法，还可以具有return方法和throw方法。如果你自己写遍历器对象生成函数，那么next方法是必须部署的，return方法和throw方法是否部署是可选的。 return方法的使用场合是，如果for...of循环提前退出（通常是因为出错，或者有break语句或continue语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。 1234567891011121314function readLinesSync(file) &#123; return &#123; next() &#123; if (file.isAtEndOfFile()) &#123; file.close(); return &#123; done: true &#125;; &#125; &#125;, return() &#123; file.close(); return &#123; done: true &#125;; &#125;, &#125;;&#125; 上面代码中，函数readLinesSync接受一个文件对象作为参数，返回一个遍历器对象，其中除了next方法，还部署了return方法。下面，我们让文件的遍历提前返回，这样就会触发执行return方法。 1234for (let line of readLinesSync(fileName)) &#123; console.log(x); break;&#125; 注意，return方法必须返回一个对象，这是Generator规格决定的。 throw方法主要是配合Generator函数使用，一般的遍历器对象用不到这个方法。 for…of循环一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口，就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的Symbol.iterator方法。 for...of循环可以使用的范围包括数组、Set和Map结构、某些类似数组的对象（比如arguments对象、DOM NodeList对象）、后文的Generator对象，以及字符串。 与其他遍历语法的比较以数组为例，JavaScript提供多种遍历语法。最原始的写法就是for循环 123for (var index = 0; index &lt; myArray.length; index++) &#123; console.log(myArray[index]);&#125; 这种写法比较麻烦，因此数组提供内置的forEach方法。 123myArray.forEach(function (value) &#123; console.log(value);&#125;); 这种写法的问题在于，无法中途跳出forEach循环，break命令或return命令都不能奏效。 for...in循环可以遍历数组的键名。 123for (var index in myArray) &#123; console.log(myArray[index]);&#125; for...in循环有几个缺点。 数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等。 for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。 某些情况下，for…in循环会以任意顺序遍历键名。 下面是一个使用break语句，跳出for…of循环的例子。 12345for (var n of fibonacci) &#123; if (n &gt; 1000) break; console.log(n);&#125; 上面的例子，会输出斐波纳契数列小于等于1000的项。如果当前项大于1000，就会使用break语句跳出for...of循环。 总之，for...in循环主要是为遍历对象而设计的，不适用于遍历数组。 文章参考ECMAScript 6 入门","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"JavaScript模块化开发（四）——ES6模块","date":"2016-05-09T16:00:00.000Z","path":"2016/05/10/Javascript-module-es6/","text":"模块基础一个 ES6 的模块是一个包含了 JS 代码的文件。ES6 里没有所谓的 module关键字。一个模块看起来就和一个普通的脚本文件一样，除了以下两个区别： ES6 的模块自动开启严格模式，即使你没有写 ‘use strict’。 你可以在模块中使用 import 和 export。 让我们先来看看 export。在模块中声明的任何东西都是默认私有的，如果你想对其他模块 Public，你必须 export那部分代码。我们有几种实现方法，最简单的方式是添加一个 export 关键字。1234567891011121314// a.jsexport function detectCats(canvas, options) &#123; var kittydar = new Kittydar(options); return kittydar.detectCats(canvas);&#125;export class Kittydar &#123; // code here &#125;// This helper function isn't exported.function resizeCanvas() &#123; // code here&#125; 你可以在 function、class、var、let 或 const 前添加 export。在另外一个文件中，我们可以导入这个模块并且使用 detectCats() 函数：12345678// b.jsimport &#123;detectCats&#125; from \"a.js\";function go() &#123; var canvas = document.getElementById(\"catpix\"); var cats = detectCats(canvas); drawRectangles(canvas, cats);&#125; 要导入多个模块中的接口，你可以这样写：1import &#123;detectCats, Kittydar&#125; from \"kittydar.js\"; 当你运行一个包含 import 声明的模块，被引入的模块会先被导入并加载，然后根据依赖关系，每一个模块的内容会使用深度优先的原则进行遍历。跳过已经执行过的模块，以此避免依赖循环。 导出表如果你觉得在每个要导出的部分前都写上 export很麻烦，你可以只写一行你想要导出的变量列表，再用花括号包起来。12345export &#123;detectCats, Kittydar&#125;;// no `export` keyword required herefunction detectCats(canvas, options) &#123; ... &#125;class Kittydar &#123; ... &#125; 导出表不一定要出现在文件的第一行，它可以出现在模块顶级作用域中的任何一行。你可以写多个导出表，也可以在列表中再写上其他export声明，只要没有变量名被重复导出即可。 重名命导出和导入如果导入的变量名恰好和你模块中的变量名冲突了，ES6 允许你给你导入的东西重命名：12import &#123;flip as flipOmelet&#125; from \"eggs.js\";import &#123;flip as flipHouse&#125; from \"real-estate.js\"; 类似地，你在导出变量的时候也能重命名。这个特性在你想将同一个变量名导出两次的场景下十分方便，举个例子：12345678function v1() &#123; ... &#125;function v2() &#123; ... &#125;export &#123; v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion&#125;; 默认导出新一代的标准的设计理念是兼容现有的 CommonJS 和 AMD 模块。所以如果你有一个 Node 项目，并且刚刚执行完 npm install lodash，你的 ES6 代码可以独立引入 Lodash 中的函数：123import &#123;each, map&#125; from \"lodash\";each([3, 2, 1], x =&gt; console.log(x)); 如果你想写自己的默认导出，那也很简单：123456789101112let myObject = &#123; field1: value1, field2: value2&#125;;export &#123;myObject as default&#125;;// orexport default &#123; field1: value1, field2: value2&#125;; export default 关键字后可以跟随任何值：函数，对象，对象字面量，任何你能说得出的东西。\\ 模块对象当你 import *，被引入进来的是一个 module namespace object。1import * as cows from \"cows\"; 它的属性是那个模块的导出，所以如果 “cows” 模块导出了一个名为 moo() 的函数，当你像这样引入了 “cows” 之后，你可以这样写 cows.moo()。 聚合模块有时候一个包的主模块会引入许多其他模块，然后再将它们以一个统一的方式导出。为了简化这样的代码，我们有一个 import-and-export 的简写方法：12345678// import \"sri-lanka\" and re-export some of its exportsexport &#123;Tea, Cinnamon&#125; from \"sri-lanka\";// import \"equatorial-guinea\" and re-export some of its exportsexport &#123;Coffee, Cocoa&#125; from \"equatorial-guinea\";// import \"singapore\" and export ALL of its exportsexport * from \"singapore\";","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"module","slug":"module","permalink":"http://yoursite.com/tags/module/"},{"name":"AMD","slug":"AMD","permalink":"http://yoursite.com/tags/AMD/"},{"name":"CommonJS","slug":"CommonJS","permalink":"http://yoursite.com/tags/CommonJS/"}]},{"title":"JavaScript模块化开发（三）——AMD规范","date":"2016-05-08T16:00:00.000Z","path":"2016/05/09/Javascript-module-amd/","text":"AMD是Asynchronous Module Definition的缩写，意思就是异步模块定义。从名称上就可以看出，它是通过异步方式加载模块的，模块的加载不影响后续语句的执行，所有依赖加载中的模块的语句，都会放在一个回调函数中，等到该模块加载完成后，这个回调函数才运行，AMD规范的API非常简单：1define(id?, dependencies?, factory); AMD定义了一个define函数，它用来定义一个模块。它包含三个参数，前两个参数都是可选的： id：是一个string字符串，它表示模块的标识（也就是模块的路径，通过id才能知道从什么位置去加载依赖的模块） dependencies：是一个数组，成员是依赖模块的id factory：是一个回调函数，在依赖的模块加载成功后，会执行这个回调函数，它的参数是所有依赖模块的引用，如果回调函数有返回值，会导出出来 一个完整的模块定义包含模块名称，模块的依赖和回调函数，比如下面的代码：1234567define(\"adder\", [\"math\"], function (math) &#123; return &#123; addTen : function (x) &#123; return math.add(x, 10); &#125; &#125;;&#125;); 如果这个模块并没有依赖，那么默认的依赖是[“require”, “exports”, “module”]，这时模块可以改写为：12345define(\"adder\", function (require, exports) &#123; exports.addTen = function (x) &#123; return x + 10; &#125;;&#125;); 如果省略第一个参数，则会定义一个匿名模块，见代码：1234567define([\"math\"], function (math) &#123; return &#123; addTen : function (x) &#123; return math.add(x, 10); &#125; &#125;;&#125;); 在实际中，使用的更多的是匿名模块定义方式，因为这样更加的灵活，模块的标识和它的源代码不再相关，开发人员可以把这个模块放在任意的位置而不需要修改代码。一般只有在要使用工具打包模块到一个文件中时，才会声明第一个参数，所以应该尽量避免给模块命名。 在写模块的时候，也有可能没有依赖或者稍后才需要加载依赖，也就是说我们可以省略第一个和第二个参数，下面代码展示了这种用法，这也是CommonJS的写法，算是一种兼容：12345678910define(function (require, exports, module) &#123; // code here var a = require('a'), b = require('b'); exports.action = function () &#123; // code here &#125;;&#125;);","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"module","slug":"module","permalink":"http://yoursite.com/tags/module/"},{"name":"AMD","slug":"AMD","permalink":"http://yoursite.com/tags/AMD/"},{"name":"CommonJS","slug":"CommonJS","permalink":"http://yoursite.com/tags/CommonJS/"}]},{"title":"JavaScript模块化开发（二）——CommonJS规范","date":"2016-05-07T16:00:00.000Z","path":"2016/05/08/Javascript-module-commonjs/","text":"模块化规范，主要是为了统一模块化的编写方式，比如不同团队的Java代码，总能用import的方式来加载，C#的话也有using，avaScript本身没有内置的模块系统（ES6中引入了模块系统，接下来会介绍），JavaScript的模块化规范，一般都是致力于提高 JavaScript程序的可移植性和可交换性，朝着统一模块化交互方式的方向而努力。 CommonJS的目标是定义一套普通应用程序使用的API，从而填补原生JavaScript标准库过少的缺点。终极目标是实现一个像python，java中含有的标准库。node.js实际上就是CommonJS 的一个实现。 CommonJS 标准大致如下： CommonJS有一个全局性的方法 require()，主要用于加载模块，加载后，就可以调用模块的方法：123var math = require('math');math.add(2,3); math 模块的add方法是怎么定义的呢，CommonJS还有一个全局变量 exports，它用来导入模块的方法，通过它导入的方法，便是这个模块的API，可供调用：12345678//math.jsexports.add = function() &#123; var sum = 0, i = 0, args = arguments, l = args.length; while (i &lt; l) &#123; sum += args[i++]; &#125; return sum;&#125;; 在模块里，还有一个变量module，它有一个只读的id属性，还有一个uri属性。 通过 CommonJS 的规范和代码可以看出，require 是同步的，模块系统需要同步读取模块文件内容，并编译执行以得到模块接口。在服务端，比如node.js，这一般来说没有问题，文件请求都是本地获取，对性能没有什么影响。但是放在浏览器端，问题就出来了，等到所有模块同步加载完毕，时间不知道要过去多久了。 CommonJS 最早叫做 ServerJS，Modules 1.0规范在node.js上实践的很好，由于知道自身在浏览器中的不足，CommonJS社区把名字改为CommonJS，意为想统一服务器端和浏览器端，但是要实现浏览器端，就要有新的版本的标准，在新的版本制定过程中，社区出现了分歧，在这个分歧中，分出了AMD规范。 由于风格和机制的差异，最终，AMD从CommonJS社区中独立了出来，成为了现在最受欢迎的规范。接下来的文章里，会介绍这个规范。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"module","slug":"module","permalink":"http://yoursite.com/tags/module/"},{"name":"AMD","slug":"AMD","permalink":"http://yoursite.com/tags/AMD/"},{"name":"CommonJS","slug":"CommonJS","permalink":"http://yoursite.com/tags/CommonJS/"}]},{"title":"JavaScript模块化开发（一）——基础知识","date":"2016-05-06T16:00:00.000Z","path":"2016/05/07/Javascript-module-basics/","text":"随着前段JavaScript代码越来越重，如何组织JavaScript代码变得非常重要，好的组织方式，可以让别人和自己很好的理解代码，也便于维护和测试。模块化是一种非常好的代码组织方式，本文试着对JavaScript模块化开发的一些基础知识做一些阐释。 对象字面量（Object Literals）对象字面量表示，其实就是用一对大括号括起来的键值对，也就是JavaScript声明对象的方式：123456var myObject = &#123; variableKey : variableValue, functionKey : function() &#123; /* code */ &#125;&#125; 比较一下下面代码声明方式，使用对象字面量表示，可以减少全局变量的污染，一般来说，强烈建议在任何时候都不要使用下面的声明方式：12345678var variableName = ...;function name1()&#123; /* code */&#125;function name2()&#123; /* code */&#125; 立即执行函数（IIFE Immediately-Invoked Function Expressions）立即执行函数是现在非常流行的写法，大部分JS库都使用了这种技巧，主要是防止全局变量的污染。 当我们在声明类似于 var name1 = function (){ … } 这样的函数时，在后面加一对括号 ()，就可以让它立即执行，但是如果是 function name1() { … }这样的函数，则会有问题：123function name1()&#123; console.log(\"dsky\");&#125;(); 上面代码在执行时会抛出错误，Unexpected token（意外的标记），因为后面的()会被解析为分组操作符。解决上面的问题，只需要加上括号将function代码全部括住即可，下面就是立即执行函数的声明方式：123456(function () &#123; /* code */ &#125; ());(function () &#123; /* code */ &#125;)();!function()&#123;/* code */&#125;();~function()&#123;/* code */&#125;();-function()&#123;/* code */&#125;();+function()&#123;/* code */&#125;(); 上面两种方式都是可以的，主要看个人习惯，区别在于立即执行函数可以不对外暴露私有变量，比如：123456789101112131415161718192021var myObject = &#123; name : \"dsky\", getName : function()&#123; return this.name; &#125;&#125;;myObject.name; // dskymyObject.getName(); // dskyvar myObject = (function()&#123; var name = \"dsky\"; return &#123; getName : function()&#123; return name; &#125; &#125;&#125;)();myObject.name; // undefinedmyObject.getName(); // dsky 导入全局变量把全局变量作为参数传递给一个立即执行函数，这样就完成了全局变量的导入，立即执行函数中可以使用此全局变量的方法，并可以修改（简化）全局变量的名称：123456789101112131415var myModule = (function (#) &#123; function method1()&#123; #(\".container\").html(\"test\"); &#125; return&#123; publicMethod: function()&#123; method1(); &#125; &#125;;&#125;)( jQuery );myModule.publicMethod(); 模块导出当然，有导入也可以有导出，有时我们不仅要导入全局变量，也要把模块导出到全局空间供其他模块使用。通过在立即执行函数中返回一个Object，就可以实现模块导出功能：12345678910111213141516var myModule = (function () &#123; var module = &#123;&#125;, privateVariable = \"Feeldesign\"; function privateMethod() &#123; /* code */ &#125; module.publicProperty = \"FeeldesignStudio\"; module.publicMethod = function () &#123; console.log( privateVariable ); &#125;; return module;&#125;)(); 扩展模块在开发中，我们经常会对一些模块进行扩展，扩展当然可以直接修改模块的源代码，但是这不是一个好的方法，比如我们要给 myModule 模块增加几个方法，通过前面的立即执行函数、导入全局变量、模块导出的知识，我们可以推导出下面的扩展方式：123456789var myModule = (function ( my ) &#123; my.xxMethod = function () &#123; /* code */ &#125;; return my;&#125;)( myModule ); 面的代码可以很好地对 myModule 进行扩展，不过前提是 myModule 必须已经定义，如果扩展的 xxMethod 方法和 myModule 本身没有任何的依赖，那么要求 myModule 必须已经定义就毫无必要了，怎么解决这个问题呢，非常简单，只需要或一个空对象：12345678910//松散扩展var myModule = (function ( my ) &#123; my.xxMethod = function () &#123; /* code */ &#125;; return my;&#125;)( myModule || &#123;&#125; ); 上述代码还存在一个问题，那就是如果a.js中声明了 var myModule = …，b.js中也声明了 var myModule = …，这样在引入a.js和b.js时，后者会将前者覆盖，这并不是我们期望的，所以对上述代码，可以再加改进：1234567(function ( my ) &#123; my.xxMethod = function () &#123; /* code */ &#125;&#125;)( window.myModule = window.myModule || &#123;&#125; );","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"module","slug":"module","permalink":"http://yoursite.com/tags/module/"},{"name":"AMD","slug":"AMD","permalink":"http://yoursite.com/tags/AMD/"},{"name":"CommonJS","slug":"CommonJS","permalink":"http://yoursite.com/tags/CommonJS/"}]},{"title":"ES6学习笔记之Set && Map","date":"2016-04-22T16:00:00.000Z","path":"2016/04/23/es6-set-and-map/","text":"Set和Map数据结构Set基本用法ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set本身是一个构造函数，用来生成Set数据结构。 12345678var s = new Set();[2, 3, 5, 4, 5, 2, 2].map(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 上面代码通过add方法向Set结构加入成员，结果表明Set结构不会添加重复的值。Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化 1234567891011121314151617181920// 例一var set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]// 例二var items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三function divs () &#123; return [...document.querySelectorAll('div')];&#125;var set = new Set(divs());set.size // 56// 类似于divs().forEach(div =&gt; set.add(div));set.size // 56 上面代码中，例一和例二都是Set函数接受数组作为参数，例三是接受类似数组的对象作为参数。上面代码中，也展示了一种去除数组重复成员的方法。 12// 去除数组的重复成员[...new Set(array)] 向Set加入值的时候，不会发生类型转换，所以5和&quot;5&quot;是两个不同的值。Set内部判断两个值是否不同，使用的算法叫做Same-value equality，它类似于精确相等运算符===，主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。 123456let set = new Set();let a = NaN;let b = NaN;set.add(a);set.add(b);set // Set &#123;NaN&#125; 上面代码向Set实例添加了两个NaN，但是只能加入一个。这表明，在Set内部，两个NaN是相等。另外，两个对象总是不相等的。 1234567let set = new Set();set.add(&#123;&#125;);set.size // 1set.add(&#123;&#125;);set.size // 2 上面代码表示，由于两个空对象不相等，所以它们被视为两个值。 Set实例的属性和方法Set结构的实例有以下属性。 Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。 add(value)：添加某个值，返回Set结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 上面这些属性和方法的实例如下。 1234567891011s.add(1).add(2).add(2);// 注意2被加入了两次s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // false 下面是一个对比，看看在判断是否包括一个键上面，Object结构和Set结构的写法不同。 12345678910111213141516171819// 对象的写法var properties = &#123; 'width': 1, 'height': 1&#125;;if (properties[someName]) &#123; // do something&#125;// Set的写法var properties = new Set();properties.add('width');properties.add('height');if (properties.has(someName)) &#123; // do something&#125; Array.from方法可以将Set结构转为数组。 12var items = new Set([1, 2, 3, 4, 5]);var array = Array.from(items); 这就提供了去除数组重复成员的另一种方法。 12345function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]) // [1, 2, 3] 遍历操作Set结构的实例有四个遍历方法，可以用于遍历成员。 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 需要特别指出的是，Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用Set保存一个回调函数列表，调用时就能保证按照添加顺序调用。 （1）keys()，values()，entries()key方法、value方法、entries方法返回的都是遍历器对象（详见《Iterator对象》一章）。由于Set结构没有键名，只有键值（或者说键名和键值是同一个值），所以key方法和value方法的行为完全一致。 12345678910111213141516171819202122let set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// [\"red\", \"red\"]// [\"green\", \"green\"]// [\"blue\", \"blue\"] 上面代码中，entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。 Set结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。 12Set.prototype[Symbol.iterator] === Set.prototype.values// true 这意味着，可以省略values方法，直接用for...of循环遍历Set。 12345678let set = new Set(['red', 'green', 'blue']);for (let x of set) &#123; console.log(x);&#125;// red// green// blue 上面代码中，entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。 （2）forEach()Set结构的实例的forEach方法，用于对每个成员执行某种操作，没有返回值。 12345let set = new Set([1, 2, 3]);set.forEach((value, key) =&gt; console.log(value * 2) )// 2// 4// 6 上面代码说明，forEach方法的参数就是一个处理函数。该函数的参数依次为键值、键名、集合本身（上例省略了该参数）。另外，forEach方法还可以有第二个参数，表示绑定的this对象。 （3）遍历的应用扩展运算符...内部使用for...of循环，所以也可以用于Set结构。 123let set = new Set(['red', 'green', 'blue']);let arr = [...set];// ['red', 'green', 'blue'] 扩展运算符和Set结构相结合，就可以去除数组的重复成员。 123let arr = [3, 5, 2, 2, 5, 5];let unique = [...new Set(arr)];// [3, 5, 2] 而且，数组的map和filter方法也可以用于Set了。 1234567let set = new Set([1, 2, 3]);set = new Set([...set].map(x =&gt; x * 2));// 返回Set结构：&#123;2, 4, 6&#125;let set = new Set([1, 2, 3, 4, 5]);set = new Set([...set].filter(x =&gt; (x % 2) == 0));// 返回Set结构：&#123;2, 4&#125; 因此使用Set可以很容易地实现并集Union、交集Intersect和差集Difference。 1234567891011121314let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// [1, 2, 3, 4]// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// [2, 3]// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// [1] 如果想在遍历操作中，同步改变原来的Set结构，目前没有直接的方法，但有两种变通方法。一种是利用原Set结构映射出一个新的结构，然后赋值给原来的Set结构；另一种是利用Array.from方法。 123456789// 方法一let set = new Set([1, 2, 3]);set = new Set([...set].map(val =&gt; val * 2));// set的值是2, 4, 6// 方法二let set = new Set([1, 2, 3]);set = new Set(Array.from(set, val =&gt; val * 2));// set的值是2, 4, 6 WeakSetWeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。 首先，WeakSet的成员只能是对象，而不能是其他类型的值。 其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。 WeakSet是一个构造函数，可以使用new命令，创建WeakSet数据结构。 1var ws = new WeakSet(); 作为构造函数，WeakSet可以接受一个数组或类似数组的对象作为参数。实际上，任何具有iterable接口的对象，都可以作为WeakSet的参数。该数组的所有成员，都会自动成为WeakSet实例对象的成员。 12var a = [[1,2], [3,4]];var ws = new WeakSet(a); 上面代码中，a是一个数组，它有两个成员，也都是数组。将a作为WeakSet构造函数的参数，a的成员会自动成为WeakSet的成员。注意，是a数组的成员成为WeakSet的成员，而不是a数组本身。这意味着，数组的成员只能是对象。 123var b = [3, 4];var ws = new WeakSet(b);// Uncaught TypeError: Invalid value used in weak set(…) 上面代码中，数组b的成员不是对象，加入WeaKSet就会报错。 WeakSet结构有以下三个方法。 WeakSet.prototype.add(value)：向WeakSet实例添加一个新成员。 WeakSet.prototype.delete(value)：清除WeakSet实例的指定成员。 WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在WeakSet实例之中。 下面是一个例子。 123456789101112var ws = new WeakSet();var obj = &#123;&#125;;var foo = &#123;&#125;;ws.add(window);ws.add(obj);ws.has(window); // truews.has(foo); // falsews.delete(window);ws.has(window); // false WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。 1234567891011const foos = new WeakSet()class Foo &#123; constructor() &#123; foos.add(this) &#125; method () &#123; if (!foos.has(this)) &#123; throw new TypeError('Foo.prototype.method 只能在Foo的实例上调用！'); &#125; &#125;&#125; 上面代码保证了Foo的实例方法，只能在Foo的实例上调用。这里使用WeakSet的好处是，foos对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑foos，也不会出现内存泄漏。 MapMap结构的目的和基本用法JavaScript的对象Object，本质上是键值对的集合Hash结构，但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。 12345var data = &#123;&#125;;var element = document.getElementById(\"myDiv\");data[element] = metadata;data[\"[Object HTMLDivElement]\"] // metadata 上面代码原意是将一个DOM节点作为对象data的键，但是由于对象只接受字符串作为键名，所以element被自动转为字符串[Object HTMLDivElement]。 为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。 123456789var m = new Map();var o = &#123;p: \"Hello World\"&#125;;m.set(o, \"content\")m.get(o) // \"content\"m.has(o) // truem.delete(o) // truem.has(o) // false 上面代码使用set方法，将对象o当作m的一个键，然后又使用get方法读取这个键，接着使用delete方法删除了这个键。 作为构造函数，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。 1234567var map = new Map([['name', '张三'], ['title', 'Author']]);map.size // 2map.has('name') // truemap.get('name') // \"张三\"map.has('title') // truemap.get('title') // \"Author\" 上面代码在新建Map实例时，就指定了两个键name和title。 Map构造函数接受数组作为参数，实际上执行的是下面的算法。 123456var items = [ ['name', '张三'], ['title', 'Author']];var map = new Map();items.forEach(([key, value]) =&gt; map.set(key, value)); 如果对同一个键多次赋值，后面的值将覆盖前面的值。 1234567let map = new Map();map.set(1, 'aaa').set(1, 'bbb');map.get(1) // \"bbb\" 注意，只有对同一个对象的引用，Map结构才将其视为同一个键。这一点要非常小心。 1234var map = new Map();map.set(['a'], 555);map.get(['a']) // undefined 上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined。 同理，同样的值的两个实例，在Map结构中被视为两个键。 1234567891011var map = new Map();var k1 = ['a'];var k2 = ['a'];map.set(k1, 111).set(k2, 222);map.get(k1) // 111map.get(k2) // 222 上面代码中，变量k1和k2的值是一样的，但是它们在Map结构中被视为两个键。 由上可知，Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。 如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键，包括0和-0。另外，虽然NaN不严格相等于自身，但Map将其视为同一个键。 1234567let map = new Map();map.set(NaN, 123);map.get(NaN) // 123map.set(-0, 123);map.get(+0) // 123 实例的属性和操作方法Map结构的实例有以下属性和操作方法。 （1）size属性 size属性返回Map结构的成员总数。 12345let map = new Map();map.set('foo', true);map.set('bar', false);map.size // 2 （2）set(key, value) set方法设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。 12345var m = new Map();m.set(\"edition\", 6) // 键是字符串m.set(262, \"standard\") // 键是数值m.set(undefined, \"nah\") // 键是undefined set方法返回的是Map本身，因此可以采用链式写法。 1234let map = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c'); （3）get(key) get方法读取key对应的键值，如果找不到key，返回undefined。 123456var m = new Map();var hello = function() &#123;console.log(\"hello\");&#125;m.set(hello, \"Hello ES6!\") // 键是函数m.get(hello) // Hello ES6! （4）has(key) has方法返回一个布尔值，表示某个键是否在Map数据结构中。 12345678910var m = new Map();m.set(\"edition\", 6);m.set(262, \"standard\");m.set(undefined, \"nah\");m.has(\"edition\") // truem.has(\"years\") // falsem.has(262) // truem.has(undefined) // true （5）delete(key) delete方法删除某个键，返回true。如果删除失败，返回false。 123456var m = new Map();m.set(undefined, \"nah\");m.has(undefined) // truem.delete(undefined)m.has(undefined) // false （6）clear() clear方法清除所有成员，没有返回值。 1234567let map = new Map();map.set('foo', true);map.set('bar', false);map.size // 2map.clear()map.size // 0 遍历方法Map原生提供三个遍历器生成函数和一个遍历方法。 keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回所有成员的遍历器。 forEach()：遍历Map的所有成员。 需要特别注意的是，Map的遍历顺序就是插入顺序。 1234567891011121314151617181920212223242526272829303132let map = new Map([ ['F', 'no'], ['T', 'yes'],]);for (let key of map.keys()) &#123; console.log(key);&#125;// \"F\"// \"T\"for (let value of map.values()) &#123; console.log(value);&#125;// \"no\"// \"yes\"for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125;// \"F\" \"no\"// \"T\" \"yes\"// 或者for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125;// 等同于使用map.entries()for (let [key, value] of map) &#123; console.log(key, value);&#125; 上面代码最后的那个例子，表示Map结构的默认遍历器接口Symbol.iterator属性，就是entries方法。 Map结构转为数组结构，比较快速的方法是结合使用扩展运算符...。 1234567891011121314151617let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);[...map.keys()]// [1, 2, 3][...map.values()]// ['one', 'two', 'three'][...map.entries()]// [[1,'one'], [2, 'two'], [3, 'three']][...map]// [[1,'one'], [2, 'two'], [3, 'three']] 结合数组的map方法、filter方法，可以实现Map的遍历和过滤（Map本身没有map和filter方法）。 123456789101112let map0 = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c');let map1 = new Map( [...map0].filter(([k, v]) =&gt; k &lt; 3));// 产生Map结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;let map2 = new Map([...map0].map(([k, v]) =&gt; [k * 2, '_' + v]));// 产生Map结构 &#123;2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'&#125; 此外，Map还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。 123map.forEach(function(value, key, map)) &#123; console.log(\"Key: %s, Value: %s\", key, value);&#125;; WeakMapWeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。 12345var map = new WeakMap()map.set(1, 2)// TypeError: 1 is not an object!map.set(Symbol(), 2)// TypeError: Invalid value used as weak map key 上面代码中，如果将1和Symbol作为WeakMap的键名，都会报错。 WeakMap的设计目的在于，键名是对象的弱引用（垃圾回收机制不将该引用考虑在内），所以其所对应的对象可能会被自动回收。当对象被回收后，WeakMap自动移除对应的键值对。典型应用是，一个对应DOM元素的WeakMap结构，当某个DOM元素被清除，其所对应的WeakMap记录就会自动被移除。基本上，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。 下面是WeakMap结构的一个例子，可以看到用法上与Map几乎一样。 123456789var wm = new WeakMap();var element = document.querySelector(\".element\");wm.set(element, \"Original\");wm.get(element) // \"Original\"element.parentNode.removeChild(element);element = null;wm.get(element) // undefined WeakMap的另一个用处是部署私有属性。 123456789101112131415161718192021222324let _counter = new WeakMap();let _action = new WeakMap();class Countdown &#123; constructor(counter, action) &#123; _counter.set(this, counter); _action.set(this, action); &#125; dec() &#123; let counter = _counter.get(this); if (counter &lt; 1) return; counter--; _counter.set(this, counter); if (counter === 0) &#123; _action.get(this)(); &#125; &#125;&#125;let c = new Countdown(2, () =&gt; console.log('DONE'));c.dec()c.dec()// DONE 上面代码中，Countdown类的两个内部属性_counter和_action，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。 文章参考ECMAScript 6 入门","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6学习笔记之Proxy && Reflect","date":"2016-04-15T16:00:00.000Z","path":"2016/04/16/es6-proxy-and-reflect/","text":"ProxyProxy概述Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种元编程（meta programming），即对编程语言进行编程。 Proxy可以理解成，在目标对象之前架设一层拦截，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy这个词的原意是代理，用在这里表示由它来代理某些操作，可以译为代理器。 12345678910var obj = new Proxy(&#123;&#125;, &#123; get: function (target, key, receiver) &#123; console.log(`getting $&#123;key&#125;!`); return Reflect.get(target, key, receiver); &#125;, set: function (target, key, value, receiver) &#123; console.log(`setting $&#123;key&#125;!`); return Reflect.set(target, key, value, receiver); &#125;&#125;); 上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。对设置了拦截行为的对象obj，去读写它的属性，就会得到下面的结果。 123456obj.count = 1// setting count!++obj.count// getting count!// setting count!// 2 上面代码说明，Proxy实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。 ES6原生提供Proxy构造函数，用来生成Proxy实例。 1var proxy = new Proxy(target, handler); Proxy对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。下面是另一个拦截读取属性行为的例子。 123456789var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);proxy.time // 35proxy.name // 35proxy.title // 35 上面代码中，配置对象有一个get方法，用来拦截对目标对象属性的访问请求。get方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回35，所以访问任何属性都得到35。 注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。 如果handler没有设置任何拦截，那就等同于直接通向原对象。 12345var target = &#123;&#125;;var handler = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.a = 'b';target.a // \"b\" 上面代码中，handler是一个空对象，没有任何拦截效果，访问handeler就等同于访问target。 一个技巧是将Proxy对象，设置到object.proxy属性，从而可以在object对象上调用。 1var object = &#123; proxy: new Proxy(target, handler) &#125;; Proxy实例也可以作为其他对象的原型对象。 12345678var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);let obj = Object.create(proxy);obj.time // 35 上面代码中，proxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象上读取该属性，导致被拦截。同一个拦截器函数，可以设置拦截多个操作。 12345678910111213141516171819202122232425var handler = &#123; get: function(target, name) &#123; if (name === 'prototype') &#123; return Object.prototype; &#125; return 'Hello, ' + name; &#125;, apply: function(target, thisBinding, args) &#123; return args[0]; &#125;, construct: function(target, args) &#123; return &#123;value: args[1]&#125;; &#125;&#125;;var fproxy = new Proxy(function(x, y) &#123; return x + y;&#125;, handler);fproxy(1, 2) // 1new fproxy(1,2) // &#123;value: 2&#125;fproxy.prototype === Object.prototype // truefproxy.foo // \"Hello, foo\" 下面是Proxy支持的拦截操作一览。对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。 （1）get(target, propKey, receiver) 拦截对象属性的读取，比如proxy.foo和proxy[&#39;foo&#39;]，返回类型不限。最后一个参数receiver可选，当target对象设置了propKey属性的get函数时，receiver对象会绑定get函数的this对象。 （2）set(target, propKey, value, receiver) 拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。 （3）has(target, propKey) 拦截propKey in proxy的操作，以及对象的hasOwnProperty方法，返回一个布尔值。 （4）deleteProperty(target, propKey) 拦截delete proxy[propKey]的操作，返回一个布尔值。 （5）ownKeys(target) 拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回对象所有自身的属性，而Object.keys()仅返回对象可遍历的属性。 （6）getOwnPropertyDescriptor(target, propKey) 拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 （7）defineProperty(target, propKey, propDesc) 拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 （8）preventExtensions(target) 拦截Object.preventExtensions(proxy)，返回一个布尔值。 （9）getPrototypeOf(target) 拦截Object.getPrototypeOf(proxy)，返回一个对象。 （10）isExtensible(target) 拦截Object.isExtensible(proxy)，返回一个布尔值。 （11）setPrototypeOf(target, proto) 拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 （12）apply(target, object, args) 拦截Proxy实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。 （13）construct(target, args) 拦截Proxy实例作为构造函数调用的操作，比如new proxy(...args)。 Proxy实例的方法下面是上面这些拦截方法的详细介绍。 get()get方法用于拦截某个属性的读取操作。上文已经有一个例子，下面是另一个拦截读取操作的例子。 12345678910111213141516var person = &#123; name: \"张三\"&#125;;var proxy = new Proxy(person, &#123; get: function(target, property) &#123; if (property in target) &#123; return target[property]; &#125; else &#123; throw new ReferenceError(\"Property \\\"\" + property + \"\\\" does not exist.\"); &#125; &#125;&#125;);proxy.name // \"张三\"proxy.age // 抛出一个错误 上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回undefined。 get方法可以继承。 123456789let proto = new Proxy(&#123;&#125;, &#123; get(target, propertyKey, receiver) &#123; console.log('GET '+propertyKey); return target[propertyKey]; &#125;&#125;);let obj = Object.create(proto);obj.xxx // \"GET xxx\" 上面代码中，拦截操作定义在Prototype对象上面，所以如果读取obj对象继承的属性时，拦截会生效。 set()set方法用来拦截某个属性的赋值操作。假定Person对象有一个age属性，该属性应该是一个不大于200的整数，那么可以使用Proxy保证age的属性值符合要求。 12345678910111213141516171819202122let validator = &#123; set: function(obj, prop, value) &#123; if (prop === 'age') &#123; if (!Number.isInteger(value)) &#123; throw new TypeError('The age is not an integer'); &#125; if (value &gt; 200) &#123; throw new RangeError('The age seems invalid'); &#125; &#125; // 对于age以外的属性，直接保存 obj[prop] = value; &#125;&#125;;let person = new Proxy(&#123;&#125;, validator);person.age = 100;person.age // 100person.age = 'young' // 报错person.age = 300 // 报错 有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合get和set方法，就可以做到防止这些内部属性被外部读写。 123456789101112131415161718192021var handler = &#123; get (target, key) &#123; invariant(key, 'get'); return target[key]; &#125;, set (target, key, value) &#123; invariant(key, 'set'); return true; &#125;&#125;;function invariant (key, action) &#123; if (key[0] === '_') &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private \"$&#123;key&#125;\" property`); &#125;&#125;var target = &#123;&#125;;var proxy = new Proxy(target, handler);proxy._prop// Error: Invalid attempt to get private \"_prop\" propertyproxy._prop = 'c'// Error: Invalid attempt to set private \"_prop\" property 上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。 apply()apply方法拦截函数的调用、call和apply操作。apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。下面是一个例子。 1234567891011121314var target = function () &#123; return 'I am the target'; &#125;;var handler = &#123; apply: function () &#123; return 'I am the proxy'; &#125;&#125;;var p = new Proxy(target, handler);p()// \"I am the proxy\"// 另外，直接调用Reflect.apply方法，也会被拦截。Reflect.apply(proxy, null, [9, 10]) // 38 上面代码中，变量p是Proxy的实例，当它作为函数调用时p()，就会被apply方法拦截，返回一个字符串。 has()has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。下面的例子使用has方法隐藏某些属性，不被in运算符发现。 1234567891011var handler = &#123; has (target, key) &#123; if (key[0] === '_') &#123; return false; &#125; return key in target; &#125;&#125;;var target = &#123; _prop: 'foo', prop: 'foo' &#125;;var proxy = new Proxy(target, handler);'_prop' in proxy // false 上面代码中，如果原对象的属性名的第一个字符是下划线，proxy.has就会返回false，从而不会被in运算符发现。 如果原对象不可配置或者禁止扩展，这时has拦截会报错。 123456789var obj = &#123; a: 10 &#125;;Object.preventExtensions(obj);var p = new Proxy(obj, &#123; has: function(target, prop) &#123; return false; &#125;&#125;);'a' in p // TypeError is thrown 上面代码中，obj对象禁止扩展，结果使用has拦截就会报错。 值得注意的是，has方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has方法不判断一个属性是对象自身的属性，还是继承的属性。由于for...in操作内部也会用到HasProperty操作，所以has方法在for...in循环时也会生效。 123456789101112131415161718192021222324252627let stu1 = &#123;name: 'Owen', score: 59&#125;;let stu2 = &#123;name: 'Mark', score: 99&#125;;let handler = &#123; has(target, prop) &#123; if (prop === 'score' &amp;&amp; target[prop] &lt; 60) &#123; console.log(`$&#123;target.name&#125; 不及格`); return false; &#125; return prop in target; &#125;&#125;let oproxy1 = new Proxy(stu1, handler);let oproxy2 = new Proxy(stu2, handler);for (let a in oproxy1) &#123; console.log(oproxy1[a]);&#125;// Owen// Owen 不及格for (let b in oproxy2) &#123; console.log(oproxy2[b]);&#125;// Mark// Mark 99 上面代码中，for...in循环时，has拦截会生效，导致不符合要求的属性被排除在for...in循环之外。 construct()construct方法用于拦截new命令，下面是拦截对象的写法。 12345var handler = &#123; construct (target, args, newTarget) &#123; return new target(...args); &#125;&#125;; construct方法可以接受两个参数。 target: 目标对象 args：构建函数的参数对象 12345678910var p = new Proxy(function() &#123;&#125;, &#123; construct: function(target, args) &#123; console.log('called: ' + args.join(', ')); return &#123; value: args[0] * 10 &#125;; &#125;&#125;);new p(1).value// \"called: 1\"// 10 construct方法返回的必须是一个对象，否则会报错。 1234567var p = new Proxy(function() &#123;&#125;, &#123; construct: function(target, argumentsList) &#123; return 1; &#125;&#125;);new p() // 报错 deleteProperty()deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。 12345678910111213141516var handler = &#123; deleteProperty (target, key) &#123; invariant(key, 'delete'); return true; &#125;&#125;;function invariant (key, action) &#123; if (key[0] === '_') &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private \"$&#123;key&#125;\" property`); &#125;&#125;var target = &#123; _prop: 'foo' &#125;;var proxy = new Proxy(target, handler);delete proxy._prop// Error: Invalid attempt to delete private \"_prop\" property 上面代码中，deleteProperty方法拦截了delete操作符，删除第一个字符为下划线的属性会报错。 defineProperty()defineProperty方法拦截了Object.defineProperty操作。 123456789var handler = &#123; defineProperty (target, key, descriptor) &#123; return false; &#125;&#125;;var target = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.foo = 'bar'// TypeError: proxy defineProperty handler returned false for property '\"foo\"' 上面代码中，defineProperty方法返回false，导致添加新属性会抛出错误。 getOwnPropertyDescriptor()getOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor，返回一个属性描述对象或者undefined。 12345678910111213141516var handler = &#123; getOwnPropertyDescriptor (target, key) &#123; if (key[0] === '_') &#123; return; &#125; return Object.getOwnPropertyDescriptor(target, key); &#125;&#125;;var target = &#123; _foo: 'bar', baz: 'tar' &#125;;var proxy = new Proxy(target, handler);Object.getOwnPropertyDescriptor(proxy, 'wat')// undefinedObject.getOwnPropertyDescriptor(proxy, '_foo')// undefinedObject.getOwnPropertyDescriptor(proxy, 'baz')// &#123; value: 'tar', writable: true, enumerable: true, configurable: true &#125; 上面代码中，handler.getOwnPropertyDescriptor方法对于第一个字符为下划线的属性名会返回undefined。 getPrototypeOf()getPrototypeOf方法主要用来拦截Object.getPrototypeOf()运算符，以及其他一些操作。 Object.prototype.__proto__ Object.prototype.isPrototypeOf() Object.getPrototypeOf() Reflect.getPrototypeOf() instanceof 1234567var proto = &#123;&#125;;var p = new Proxy(&#123;&#125;, &#123; getPrototypeOf(target) &#123; return proto; &#125;&#125;);Object.getPrototypeOf(p) === proto // true 上面代码中，getPrototypeOf方法拦截Object.getPrototypeOf()，返回proto对象。 isExtensible()isExtensible方法拦截Object.isExtensible操作。 12345678910var p = new Proxy(&#123;&#125;, &#123; isExtensible: function(target) &#123; console.log(\"called\"); return true; &#125;&#125;);Object.isExtensible(p)// \"called\"// true 上面代码设置了isExtensible方法，在调用Object.isExtensible时会输出called。 这个方法有一个强限制，如果不能满足下面的条件，就会抛出错误。 1Object.isExtensible(proxy) === Object.isExtensible(target) 下面是一个例子。 1234567var p = new Proxy(&#123;&#125;, &#123; isExtensible: function(target) &#123; return false; &#125;&#125;);Object.isExtensible(p) // 报错 ownKeys()ownKeys方法用来拦截Object.keys()操作。 123456789101112let target = &#123;&#125;;let handler = &#123; ownKeys(target) &#123; return ['hello', 'world']; &#125;&#125;;let proxy = new Proxy(target, handler);Object.keys(proxy)// [ 'hello', 'world' ] 上面代码拦截了对于target对象的Object.keys()操作，返回预先设定的数组。 下面的例子是拦截第一个字符为下划线的属性名。 1234567891011121314151617let target = &#123; _bar: 'foo', _prop: 'bar', prop: 'baz'&#125;;let handler = &#123; ownKeys (target) &#123; return Reflect.ownKeys(target).filter(key =&gt; key[0] !== '_'); &#125;&#125;;let proxy = new Proxy(target, handler);for (let key of Object.keys(proxy)) &#123; console.log(target[key]);&#125;// \"baz\" preventExtensions()preventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值。 这个方法有一个限制，只有当Object.isExtensible(proxy)为false（即不可扩展）时，proxy.preventExtensions才能返回true，否则会报错。 1234567var p = new Proxy(&#123;&#125;, &#123; preventExtensions: function(target) &#123; return true; &#125;&#125;);Object.preventExtensions(p) // 报错 上面代码中，proxy.preventExtensions方法返回true，但这时Object.isExtensible(proxy)会返回true，因此报错。 为了防止出现这个问题，通常要在proxy.preventExtensions方法里面，调用一次Object.preventExtensions。 1234567891011var p = new Proxy(&#123;&#125;, &#123; preventExtensions: function(target) &#123; console.log(\"called\"); Object.preventExtensions(target); return true; &#125;&#125;);Object.preventExtensions(p)// \"called\"// true setPrototypeOf()setPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。下面是一个例子。 12345678910var handler = &#123; setPrototypeOf (target, proto) &#123; throw new Error('Changing the prototype is forbidden'); &#125;&#125;;var proto = &#123;&#125;;var target = function () &#123;&#125;;var proxy = new Proxy(target, handler);proxy.setPrototypeOf(proxy, proto);// Error: Changing the prototype is forbidden 上面代码中，只要修改target的原型对象，就会报错。 Proxy.revocable()Proxy.revocable方法返回一个可取消的Proxy实例。 12345678910et target = &#123;&#125;;let handler = &#123;&#125;;let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);proxy.foo = 123;proxy.foo // 123revoke();proxy.foo // TypeError: Revoked Proxy.revocable方法返回一个对象，该对象的proxy属性是Proxy实例，revoke属性是一个函数，可以取消Proxy实例。上面代码中，当执行revoke函数之后，再访问Proxy实例，就会抛出一个错误。 Reflect概述Reflect对象与Proxy对象一样，也是ES6为了操作对象而提供的新API。Reflect对象的设计目的有这样几个。 （1）将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。 （2）修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。 1234567891011121314// 老写法try &#123; Object.defineProperty(target, property, attributes); // success&#125; catch (e) &#123; // failure&#125;// 新写法if (Reflect.defineProperty(target, property, attributes)) &#123; // success&#125; else &#123; // failure&#125; （3）让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。 12345// 老写法'assign' in Object // true// 新写法Reflect.has(Object, 'assign') // true （4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。 123456789Proxy(target, &#123; set: function(target, name, value, receiver) &#123; var success = Reflect.set(target,name, value, receiver); if (success) &#123; log('property ' + name + ' on ' + target + ' set to ' + value); &#125; return success; &#125;&#125;); 上面代码中，Proxy方法拦截target对象的属性赋值行为。它采用Reflect.set方法将值赋值给对象的属性，然后再部署额外的功能。 下面是另一个例子。 1234567891011121314var loggedObj = new Proxy(obj, &#123; get(target, name) &#123; console.log('get', target, name); return Reflect.get(target, name); &#125;, deleteProperty(target, name) &#123; console.log('delete' + name); return Reflect.deleteProperty(target, name); &#125;, has(target, name) &#123; console.log('has' + name); return Reflect.has(target, name); &#125;&#125;); 上面代码中，每一个Proxy对象的拦截操作get、delete、has，内部都调用对应的Reflect方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。 有了Reflect对象以后，很多操作会更易读。 12345// 老写法Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1// 新写法Reflect.apply(Math.floor, undefined, [1.75]) // 1 文章参考ECMAScript 6 入门","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6学习笔记之Symbol","date":"2016-04-08T16:00:00.000Z","path":"2016/04/09/es6-symbol/","text":"概述ES5的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是ES6引入Symbol的原因。 ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。12let s = Symbol();typeof s // \"symbol\" 上面代码中，变量s就是一个独一无二的值。typeof运算符的结果，表明变量s是Symbol数据类型，而不是字符串之类的其他类型。 注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。也就是说，由于Symbol值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。 Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 12345678var s1 = Symbol('foo');var s2 = Symbol('bar');s1 // Symbol(foo)s2 // Symbol(bar)s1.toString() // \"Symbol(foo)\"s2.toString() // \"Symbol(bar)\" 注意，Symbol函数的参数只是表示对当前Symbol值的描述，因此相同参数的Symbol函数的返回值是不相等的。1234567891011// 没有参数的情况var s1 = Symbol();var s2 = Symbol();s1 === s2 // false// 有参数的情况var s1 = Symbol(\"foo\");var s2 = Symbol(\"foo\");s1 === s2 // false Symbol值不能与其他类型的值进行运算，会报错。123456var sym = Symbol('My symbol');\"your symbol is \" + sym// TypeError: can't convert symbol to string`your symbol is $&#123;sym&#125;`// TypeError: can't convert symbol to string 但是，Symbol值可以显式转为字符串。1234var sym = Symbol('My symbol');String(sym) // 'Symbol(My symbol)'sym.toString() // 'Symbol(My symbol)' 另外，Symbol值也可以转为布尔值，但是不能转为数值。12345678910var sym = Symbol();Boolean(sym) // true!sym // falseif (sym) &#123; // ...&#125;Number(sym) // TypeErrorsym + 2 // TypeError 作为属性名的Symbol由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。1234567891011121314151617var mySymbol = Symbol();// 第一种写法var a = &#123;&#125;;a[mySymbol] = 'Hello!';// 第二种写法var a = &#123; [mySymbol]: 'Hello!'&#125;;// 第三种写法var a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: 'Hello!' &#125;);// 以上写法都得到同样结果a[mySymbol] // \"Hello!\" 注意，Symbol值作为对象属性名时，不能用点运算符。123456var mySymbol = Symbol();var a = &#123;&#125;;a.mySymbol = 'Hello!';a[mySymbol] // undefineda['mySymbol'] // \"Hello!\" 同理，在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中。1234567let s = Symbol();let obj = &#123; [s]: function (arg) &#123; ... &#125;&#125;;obj[s](123); 实例：消除魔术字符串魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，该由含义清晰的变量代替。1234567891011121314function getArea(shape, options) &#123; var area = 0; switch (shape) &#123; case 'Triangle': // 魔术字符串 area = .5 * options.width * options.height; break; /* ... more code ... */ &#125; return area;&#125;getArea('Triangle', &#123; width: 100, height: 100 &#125;); // 魔术字符串 上面代码中，字符串“Triangle”就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。常用的消除魔术字符串的方法，就是把它写成一个变量。123456789101112131415var shapeType = &#123; triangle: 'Triangle'&#125;;function getArea(shape, options) &#123; var area = 0; switch (shape) &#123; case shapeType.triangle: area = .5 * options.width * options.height; break; &#125; return area;&#125;getArea(shapeType.triangle, &#123; width: 100, height: 100 &#125;); 如果仔细分析，可以发现shapeType.triangle等于哪个值并不重要，只要确保不会跟其他shapeType属性的值冲突即可。因此，这里就很适合改用Symbol值。 123const shapeType = &#123; triangle: Symbol()&#125;; 上面代码中，除了将shapeType.triangle的值设为一个Symbol，其他地方都不用修改。 属性名的遍历Symbol作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有Symbol属性名。Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的Symbol值。 12345678910var obj = &#123;&#125;;var a = Symbol('a');var b = Symbol('b');obj[a] = 'Hello';obj[b] = 'World';var objectSymbols = Object.getOwnPropertySymbols(obj);objectSymbols // [Symbol(a), Symbol(b)] 另一个新的API，Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和Symbol键名。 1234567let obj = &#123; [Symbol('my_key')]: 1, enum: 2, nonEnum: 3&#125;;Reflect.ownKeys(obj) // [Symbol(my_key), 'enum', 'nonEnum'] 由于以Symbol值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。 1234567891011121314151617181920212223242526var size = Symbol('size');class Collection &#123; constructor() &#123; this[size] = 0; &#125; add(item) &#123; this[this[size]] = item; this[size]++; &#125; static sizeOf(instance) &#123; return instance[size]; &#125;&#125;var x = new Collection();Collection.sizeOf(x) // 0x.add('foo');Collection.sizeOf(x) // 1Object.keys(x) // ['0']Object.getOwnPropertyNames(x) // ['0']Object.getOwnPropertySymbols(x) // [Symbol(size)] 上面代码中，对象x的size属性是一个Symbol值，所以Object.keys(x)、Object.getOwnPropertyNames(x)都无法获取它。这就造成了一种非私有的内部方法的效果。 Symbol.for()，Symbol.keyFor()有时，我们希望重新使用同一个Symbol值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。 1234var s1 = Symbol.for('foo');var s2 = Symbol.for('foo');s1 === s2 // true 上面代码中，s1和s2都是Symbol值，但是它们都是同样参数的Symbol.for方法生成的，所以实际上是同一个值。 Symbol.for()与Symbol()这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的Symbol类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(&quot;cat&quot;)30次，每次都会返回同一个Symbol值，但是调用Symbol(&quot;cat&quot;)30次，会返回30个不同的Symbol值。 12345Symbol.for(\"bar\") === Symbol.for(\"bar\")// trueSymbol(\"bar\") === Symbol(\"bar\")// false Symbol.keyFor方法返回一个已登记的Symbol类型值的key。 12345var s1 = Symbol.for(\"foo\");Symbol.keyFor(s1) // \"foo\"var s2 = Symbol(\"foo\");Symbol.keyFor(s2) // undefined 上面代码中，变量s2属于未登记的Symbol值，所以返回undefined。 需要注意的是，Symbol.for为Symbol值登记的名字，是全局环境的，可以在不同的iframe或service worker中取到同一个值。 123456iframe = document.createElement('iframe');iframe.src = String(window.location);document.body.appendChild(iframe);iframe.contentWindow.Symbol.for('foo') === Symbol.for('foo')// true 上面代码中，iframe窗口生成的Symbol值，可以在主页面得到。 内置的Symbol值除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。 Symbol.hasInstance对象的Symbol.hasInstance属性，指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。比如，foo instanceof Foo在语言内部，实际调用的是Foo[Symbol.hasInstance](foo)。 1234567class MyClass &#123; [Symbol.hasInstance](foo) &#123; return foo instanceof Array; &#125;&#125;[1, 2, 3] instanceof new MyClass() // true Symbol.isConcatSpreadable对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象使用Array.prototype.concat()时，是否可以展开。 123456let arr1 = ['c', 'd'];['a', 'b'].concat(arr1, 'e') // ['a', 'b', 'c', 'd', 'e']let arr2 = ['c', 'd'];arr2[Symbol.isConcatSpreadable] = false;['a', 'b'].concat(arr2, 'e') // ['a', 'b', ['c','d'], 'e'] 对于一个类来说，Symbol.isConcatSpreadable属性必须写成实例的属性。 1234567891011121314151617181920class A1 extends Array &#123; constructor(args) &#123; super(args); this[Symbol.isConcatSpreadable] = true; &#125;&#125;class A2 extends Array &#123; constructor(args) &#123; super(args); this[Symbol.isConcatSpreadable] = false; &#125;&#125;let a1 = new A1();a1[0] = 3;a1[1] = 4;let a2 = new A2();a2[0] = 5;a2[1] = 6;[1, 2].concat(a1).concat(a2)// [1, 2, 3, 4, [5, 6]] 上面代码中，类A1是可展开的，类A2是不可展开的，所以使用concat时有不一样的结果。 Symbol.species对象的Symbol.species属性，指向一个方法。该对象作为构造函数创造实例时，会调用这个方法。即如果this.constructor[Symbol.species]存在，就会使用这个属性作为构造函数，来创造新的实例对象。 Symbol.species属性默认的读取器如下。 123static get [Symbol.species]() &#123; return this;&#125; Symbol.match对象的Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。 1234567891011String.prototype.match(regexp)// 等同于regexp[Symbol.match](this)class MyMatcher &#123; [Symbol.match](string) &#123; return 'hello world'.indexOf(string); &#125;&#125;'e'.match(new MyMatcher()) // 1 Symbol.replace对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。 123String.prototype.replace(searchValue, replaceValue)// 等同于searchValue[Symbol.replace](this, replaceValue) Symbol.search对象的Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。 12345678910111213String.prototype.search(regexp)// 等同于regexp[Symbol.search](this)class MySearch &#123; constructor(value) &#123; this.value = value; &#125; [Symbol.search](string) &#123; return string.indexOf(this.value); &#125;&#125;'foobar'.search(new MySearch('foo')) // 0 Symbol.split对象的Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。 123String.prototype.split(separator, limit)// 等同于separator[Symbol.split](this, limit) Symbol.iterator对象的Symbol.iterator属性，指向该对象的默认遍历器方法。 12345678var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3] Symbol.toPrimitive对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。 Symbol.toPrimitive被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。 Number：该场合需要转成数值 String：该场合需要转成字符串 Default：该场合可以转成数值，也可以转成字符串 12345678910111213141516171819let obj = &#123; [Symbol.toPrimitive](hint) &#123; switch (hint) &#123; case 'number': return 123; case 'string': return 'str'; case 'default': return 'default'; default: throw new Error(); &#125; &#125;&#125;;2 * obj // 2463 + obj // '3default'obj == 'default' // trueString(obj) // 'str' Symbol.toStringTag对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个字符串。 12345678910(&#123;[Symbol.toStringTag]: 'Foo'&#125;.toString())// \"[object Foo]\"class Collection &#123; get [Symbol.toStringTag]() &#123; return 'xxx'; &#125;&#125;var x = new Collection();Object.prototype.toString.call(x) // \"[object xxx]\" Symbol.unscopables对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。 123456789101112131415161718192021222324// 没有unscopables时class MyClass &#123; foo() &#123; return 1; &#125;&#125;var foo = function () &#123; return 2; &#125;;with (MyClass.prototype) &#123; foo(); // 1&#125;// 有unscopables时class MyClass &#123; foo() &#123; return 1; &#125; get [Symbol.unscopables]() &#123; return &#123; foo: true &#125;; &#125;&#125;var foo = function () &#123; return 2; &#125;;with (MyClass.prototype) &#123; foo(); // 2&#125; 文章参考ECMAScript 6 入门","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6学习笔记之对象的扩展","date":"2016-04-01T16:00:00.000Z","path":"2016/04/02/es6-object-expansion/","text":"对象的扩展属性的简洁表示法ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 123456var foo = 'bar';var baz = &#123;foo&#125;;baz // &#123;foo: \"bar\"&#125;// 等同于var baz = &#123;foo: foo&#125;; 上面代码表明，ES6允许在对象之中，只写属性名，不写属性值。这时，属性值等于属性名所代表的变量。下面是另一个例子。 1234567891011function f(x, y) &#123; return &#123;x, y&#125;;&#125;// 等同于function f(x, y) &#123; return &#123;x: x, y: y&#125;;&#125;f(1, 2) // Object &#123;x: 1, y: 2&#125; 除了属性简写，方法也可以简写： 12345678910111213var o = &#123; method() &#123; return \"Hello!\"; &#125;&#125;;// 等同于var o = &#123; method: function() &#123; return \"Hello!\"; &#125;&#125;; 下面是一个实际的例子: 12345678910111213var birth = '2000/01/01';var Person = &#123; name: '张三', //等同于birth: birth birth, // 等同于hello: function ()... hello() &#123; console.log('我的名字是', this.name); &#125;&#125;; 这种写法用于函数的返回值，将会非常方便: 12345678function getPoint() &#123; var x = 1; var y = 10; return &#123;x, y&#125;;&#125;getPoint()// &#123;x:1, y:10&#125; 属性名表达式JavaScript语言定义对象的属性，有两种方法: 12345// 方法一obj.foo = true;// 方法二obj['a' + 'bc'] = 123; 但是，如果使用字面量方式定义对象（使用大括号），在ES5中只能使用方法一（标识符）定义属性: 1234var obj = &#123; foo: true, abc: 123&#125;; ES6允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内: 12345678910var lastWord = 'last word';var a = &#123; 'first word': 'hello', [lastWord]: 'world'&#125;;a['first word'] // \"hello\"a[lastWord] // \"world\"a['last word'] // \"world\" 注意，属性名表达式与简洁表示法，不能同时使用，会报错。 12345678// 报错var foo = 'bar';var bar = 'abc';var baz = &#123; [foo] &#125;;// 正确var foo = 'bar';var baz = &#123; [foo]: 'abc'&#125;; Object.is()ES5比较两个值是否相等，只有两个运算符：相等运算符==和严格相等运算符===。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。 ES6提出Same-value equality（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符===的行为基本一致。 1234Object.is('foo', 'foo')// trueObject.is(&#123;&#125;, &#123;&#125;)// false 不同之处只有两个：一是+0不等于-0，二是NaN等于自身。 12345+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true Object.assign()基本用法Object.assign方法用于对象的合并，将源对象source的所有可枚举属性，复制到目标对象target。 1234567var target = &#123; a: 1 &#125;;var source1 = &#123; b: 2 &#125;;var source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。 注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 1234567var target = &#123; a: 1, b: 1 &#125;;var source1 = &#123; b: 2, c: 2 &#125;;var source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 如果只有一个参数，Object.assign会直接返回该参数。 12var obj = &#123;a: 1&#125;;Object.assign(obj) === obj // true 如果该参数不是对象，则会先转成对象，然后返回 1typeof Object.assign(2) // \"object\" 由于undefined和null无法转成对象，所以如果它们作为参数，就会报错 12Object.assign(undefined) // Uncaught TypeError: Cannot convert undefined or null to objectObject.assign(null) // Uncaught TypeError: Cannot convert undefined or null to object 除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。 123456var v1 = 'abc';var v2 = true;var v3 = 10;var obj = Object.assign(&#123;&#125;, v1, v2, v3);console.log(obj); // &#123; \"0\": \"a\", \"1\": \"b\", \"2\": \"c\" &#125; Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性enumerable: false。属性名为Symbol值的属性，也会被Object.assign拷贝。 12345678910Object.assign(&#123;b: 'c'&#125;, Object.defineProperty(&#123;&#125;, 'invisible', &#123; enumerable: false, value: 'hello' &#125;))// &#123; b: 'c' &#125;Object.assign(&#123; a: 'b' &#125;, &#123; [Symbol('c')]: 'd' &#125;)// &#123; a: 'b', Symbol(c): 'd' &#125; 注意点Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 123456789var obj1 = &#123;a: &#123;b: 1&#125;&#125;;var obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;obj2.a.b // 2var target = &#123; a: &#123; b: 'c', d: 'e' &#125; &#125;var source = &#123; a: &#123; b: 'hello' &#125; &#125;Object.assign(target, source)// &#123; a: &#123; b: 'hello' &#125; &#125; 常见用途 为对象添加属性 12345class Point &#123; constructor(x, y) &#123; Object.assign(this, &#123;x, y&#125;); &#125;&#125; 上面方法通过Object.assign方法，将x属性和y属性添加到Point类的对象实例。 为对象添加方法 12345678910111213141516Object.assign(SomeClass.prototype, &#123; someMethod(arg1, arg2) &#123; ··· &#125;, anotherMethod() &#123; ··· &#125;&#125;);// 等同于下面的写法SomeClass.prototype.someMethod = function (arg1, arg2) &#123; ···&#125;;SomeClass.prototype.anotherMethod = function () &#123; ···&#125;; 上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用assign方法添加到SomeClass.prototype之中。 克隆对象 123function clone(origin) &#123; return Object.assign(&#123;&#125;, origin);&#125; 上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。 不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。 1234function clone(origin) &#123; let originProto = Object.getPrototypeOf(origin); return Object.assign(Object.create(originProto), origin);&#125; 合并多个对象 将多个对象合并到某个对象。 1const merge = (target, ...sources) =&gt; Object.assign(target, ...sources); 如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并 1const merge = (...sources) =&gt; Object.assign(&#123;&#125;, ...sources); 为属性指定默认值 12345678const DEFAULTS = &#123; logLevel: 0, outputFormat: 'html'&#125;;function processContent(options) &#123; let options = Object.assign(&#123;&#125;, DEFAULTS, options);&#125; 上面代码中，DEFAULTS对象是默认值，options对象是用户提供的参数。Object.assign方法将DEFAULTS和options合并成一个新对象，如果两者有同名属性，则option的属性值会覆盖DEFAULTS的属性值。 注意，由于存在深拷贝的问题，DEFAULTS对象和options对象的所有属性的值，都只能是简单类型，而不能指向另一个对象。否则，将导致DEFAULTS对象的该属性不起作用。 文章参考ECMAScript 6 入门","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Git搭建静态博客","date":"2016-03-25T16:00:00.000Z","path":"2016/03/26/git-pages/","text":"一直想写篇文章来介绍git-pages的搭建，拖了好久，今天来填下坑。 Git基本配置git config 命令可以对 Git 的使用选项和配置进行设置（记得将下面大写部分的 YOUR_USERNAME 和 YOUR_EMAL@EMAIL.COM 替换为你自己的名字和 Email 地址）。12git config --global user.name &quot; YOUR_USERNAME&quot;git config --global user.email &quot;YOUR_EMAL@EMAIL.COM&quot; 完成上述设置后，我们可以通过 git config -l 命令来查看设置是否生效。 Git添加 SSH 公钥我们通过下面的命令生成密钥，请将命令中的 YOUR_EMAIL@YOUREMAIL.COM替换为你自己的 Email 地址。1ssh-keygen -t rsa -C &quot;YOUR_EMAIL@YOUREMAIL.COM&quot; 在 SSH 生成过程中会出现以下信息，按屏幕的提示操作即可；当提示Enter passphrase ( empty for no passphrase ) : 时，可以直接按两次回车键输入一个空的 passphrase；也可以选择输入一个 passphrase 口令，如果此时你输入了一个 passphrase，请牢记，之后每次提交时都需要输入这个口令来确认，所以建议不填写。 SSH 秘钥生成结束后，你可以在 SSH 目录下看到私钥 id_rsa 和公钥 id_rsa.pub这两个文件，不要把私钥文件 id_rsa 的信息透露给任何人。打开id_rsa.pub，复制里面的内容，打开github里面的setting，点击SSH and GPG keys，在SSH keys中选择New SSH key，将刚才复制的内容粘贴进去，并设置好title，完成上面的操作后，可以通过下面的命令来测试一下是否可以连接 github 服务器。1ssh -T git@github.com 如果你操作的电脑是第一次与 github 建立连接，会出现以下警告，123The authenticity of host &apos;github.com (192.30.**.131)&apos; can&apos;t be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? 输入 yes 后回车。此时，如果你在生成 SSH 密钥时设置了 passphrase 口令，会提示你输入口令，输入后回车即可，之前，，没写的直接回车就好。最后，如果你看到以下信息，说明连接成功。1Hi dsky1990! You&apos;ve successfully authenticated, but GitHub does not provide shell access. hexo现在git的环境已经配置好，接下来我们来写博客，这里我们用markdowm来写，然后用hexo来生成静态页面。12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 然后我们根据提示，可以在http://localhost:4000/打开页面了。写好markdowm文件后，我们可以直接在游览器里面查看，没问题后，就可以用下面的命令1hexo generate 在public文件夹中就会生成对应的静态页面，然后我们可以修改_config.yml文件，然后修改deploy标签，改为 1234deploy: type: github respository: 自己的git仓库地址 branch: master 接下来我们只需要用到下面的命令就可以直接将页面push到仓库了 123hexo cleanhexo generatehexo deploy 如果报错的话，将deploy 的 type 改成 git，然后再在运行以下命令 1npm install hexo-deployer-git --save 再重新来一遍 123hexo cleanhexo generatehexo deploy hexo是可以修改主题的，推荐的话用yilia，至于主题的配置看文档就好了，这里就不多说了，接下来说说如何配置gitpages。 gitpages登录后系统，在github首页，点击页面右下角「New Repository」，填写项目信息，注意project name一定要填写username.github.io，其中username是自己的用户名，比如博主的是dsky100，那么project name一定要填写dsky100.github.io，然后一步步跟着指导走，最后点击「Create Repository」 完成创建。接下来我们在本地：1git clone projectUrl 接着然后我们可以将hexo生成的文件copy过来，然后123git add *git commit -m &quot;message&quot;git push origin master 或者用上面的123hexo cleanhexo generatehexo deploy 提交完后我们就可以在游览器中打开username.github.io查看我们的页面了。","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]},{"title":"Git学习笔记","date":"2016-03-18T16:00:00.000Z","path":"2016/03/19/git/","text":"总结下git的使用方法。 安装Git这里推荐使用git或msysGit这个工具，下载后安装就可以了。 Git 常用指令 初始化仓库 1git init 添加文件 1git add 提交 12git commit -m &apos;message&apos;git commit -a -m &apos;message&apos; // 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤 克隆现有的仓库 1git clone 查看文件状态 1git status 打开文件 1cat .gitignore 工作目录文件对比暂存区域快照 12git diffgit diff --staged // 查看已暂存的将要添加到下次提交里的内容 移除文件 123git rmgit rm -f // 强制删除选项，这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复git rm --cached // 你想让文件保留在磁盘，但是并不想让 Git 继续跟踪 移动文件 1git mv file_from file_to // renamed: file_from -&gt; file_to 查看提交历史 1git log -重新提交1git commit --amend // 最终你只会有一个提交，第二次提交将代替第一次提交的结果。 取消暂存的文件 1git reset 撤消对文件的修改 1git checkout -- [file] //撤消修改，将它还原成上次提交时的样子 查看远程仓库 1git remote 添加远程仓库 1git remote add &lt;shortname&gt; &lt;url&gt; // 添加一个新的远程 Git 仓库 从远程仓库中抓取与拉取 12git fetch [remote-name] // git fetch 命令会将数据拉取到你的本地仓库，它并不会自动合并或修改你当前的工作git pull [remote-name] // git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支 推送到远程仓库 1git push origin master 远程仓库的移除与重命名 12git remote rename pb paul // 将 pb 重命名为 paulgit remote rm paul // 移除paul 标签 1234567git tag //列出标签git tag -a v1.4 -m &apos;my version 1.4&apos; // 创建一个附注标签git show v1.4 // git show 命令可以看到标签信息与对应的提交信息git tag -a v1.2 9fceb02 // 假设在 v1.2 时你忘记给项目打标签，你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）git push origin v1.5 // 默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上git push origin --tags // 把所有不在远程仓库服务器上的标签全部传送到那里git checkout -b version2 v2.0.0 // 如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用 git checkout -b [branchname] [tagname] 在特定的标签上创建一个新分支 分支创建 1git branch 分支切换 12git checkout // 分支切换git checkout -b // 新建一个分支并同时切换 分支合并 1git merge 删除分支 1git branch -d // 前没有 * 号的分支通常可以使用 git branch -d 删除掉 使用图形化工具来解决冲突 1git mergetool 删除远程分支 1git push origin --delete 变基 123git checkout experimentgit rebase master //使用 rebase 命令将提交到某一分支上的所有修改都移至另一分支上git rebase --onto master server client // 取出 client 分支，找出处于 client 分支和 server 分支的共同祖先之后的修改，然后把它们在 master 分支上重演一遍 奇妙的变基也并非完美无缺，要用它得遵守一条准则：不要对在你的仓库外有副本的分支执行变基。变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 git rebase 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"linux下shadowsocks配合SwitchyOmega科学上网","date":"2016-03-12T06:12:03.000Z","path":"2016/03/12/ubuntu-shadowsocks/","text":"shadowsocks客户端的基本使用下载客户端，各平台的客户端都有，windows,linux,mac,android,ios。shadowsocks下载地址访问不了的可以访问这个地址windows，mac，Android以及iPhone的使用都很简单，下面主要说的是Linux上面shadowsocks的使用问题。首先我们下载linux下的客户端，这里推荐下载shadowsocks-qt5因为是图形界面，使用方便。下载完后,我们可以在file&gt;import中引入自己已经配置好的json文件,界面如下:接下来我们下载需要用的到一个插件，SwitchyOmega是chrome下非常好用的代理管理插件，我们就使用这个插件来搭建chrome的代理。首先我们新建一个名为shadowsocks的代理:配置我们的代理，这里设置的是127.0.0.1，端口是1080:接下来在auto switch中，规则列表设置中，勾选autoProxy，规则列表中加入网址https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt,然后勾选规则列表规则，切换到shadowsocks:这样，chrome在linux下也能正常使用shadowsocks了","tags":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://yoursite.com/tags/shadowsocks/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"ES6学习笔记之函数的扩展","date":"2016-03-04T16:00:00.000Z","path":"2016/03/05/es6-function-expansion/","text":"函数的扩展函数参数的默认值基本用法在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。12345678function log(x, y) &#123; y = y || 'World'; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello World 上面代码检查函数log的参数y有没有赋值，如果没有，则指定默认值为World。这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。就像上面代码的最后一行，参数y等于空字符，结果被改为默认值。为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。12345678910function log(x, y) &#123; if (typeof y === 'undefined') &#123; y = 'World'; &#125; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。1234567function log(x, y = 'World') &#123; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello 可以看到，ES6的写法比ES5简洁许多，而且非常自然。除了简洁，ES6的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。 与解构赋值默认值结合使用参数默认值可以与解构赋值的默认值，结合起来使用。12345678function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined, 5foo(&#123;x: 1&#125;) // 1, 5foo(&#123;x: 1, y: 2&#125;) // 1, 2foo() // TypeError: Cannot read property 'x' of undefined 接下来我们来看看下面两种写法有什么差别？123456789// 写法一function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;// 写法二function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125; 上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。123456789101112131415161718// 函数没有参数的情况m1() // [0, 0]m2() // [0, 0]// x和y都有值的情况m1(&#123;x: 3, y: 8&#125;) // [3, 8]m2(&#123;x: 3, y: 8&#125;) // [3, 8]// x有值，y无值的情况m1(&#123;x: 3&#125;) // [3, 0]m2(&#123;x: 3&#125;) // [3, undefined]// x和y都无值的情况m1(&#123;&#125;) // [0, 0];m2(&#123;&#125;) // [undefined, undefined]m1(&#123;z: 3&#125;) // [0, 0]m2(&#123;z: 3&#125;) // [undefined, undefined] 参数默认值的位置通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。12345678910111213141516171819// 例一function f(x = 1, y) &#123; return [x, y];&#125;f() // [1, undefined]f(2) // [2, undefined])f(, 1) // 报错f(undefined, 1) // [1, 1]// 例二function f(x, y = 5, z) &#123; return [x, y, z];&#125;f() // [undefined, 5, undefined]f(1) // [1, 5, undefined]f(1, ,2) // 报错f(1, undefined, 2) // [1, 5, 2] 上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。如果传入undefined，将触发该参数等于默认值，null则没有这个效果。123456function foo(x = 5, y = 6)&#123; console.log(x, y);&#125;foo(undefined, null)// 5 null 函数的length属性指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。123(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。12(function (a = 0, b, c) &#123;&#125;).length // 0(function (a, b = 1, c) &#123;&#125;).length // 1 作用域一个需要注意的地方是，如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的，即先是当前函数的作用域，然后才是全局作用域。12345678var x = 1;function f(x, y = x) &#123; console.log(\"x \", x);console.log(\"y \", y);&#125;f(2) // x 2, y 2 如果调用时，函数作用域内部的变量x没有生成，结果就会不一样。123456789let x = 1;function f(y = x) &#123; let x = 2; console.log(\"x\",x);console.log(\"y\",y);&#125;f() // x 2, y 1 如果此时，全局变量x不存在，就会报错。1234567function f(y = x) &#123; let x = 2; console.log(\"x\",x);console.log(\"y\",y);&#125;f() // ReferenceError: x is not defined 如果函数A的参数默认值是函数B，由于函数的作用域是其声明时所在的作用域，那么函数B的作用域不是函数A，而是全局作用域。请看下面的例子。12345678let foo = 'outer';function bar(func = x =&gt; foo) &#123; let foo = 'inner'; console.log(func()); // outer&#125;bar(); 上面代码中，函数bar的参数func，默认是一个匿名函数，返回值为变量foo。这个匿名函数的作用域就不是bar。这个匿名函数声明时，是处在外层作用域，所以内部的foo指向函数体外的声明，输出outer。它实际上等同于下面的代码。123456789let foo = 'outer';let f = x =&gt; foo;function bar(func = f) &#123; let foo = 'inner'; console.log(func()); // outer&#125;bar(); rest参数ES6引入rest参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。123456789function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10 上面代码的add函数是一个求和函数，利用rest参数，可以向该函数传入任意数目的参数。下面是一个rest参数代替arguments变量的例子。1234567// arguments变量的写法function sortNumbers() &#123; return Array.prototype.slice.call(arguments).sort();&#125;// rest参数的写法const sortNumbers = (...numbers) =&gt; numbers.sort(); rest参数中的变量代表一个数组，所以数组特有的方法都可以用于这个变量。下面是一个利用rest参数改写数组push方法的例子。123456789function push(array, ...items) &#123; items.forEach(function(item) &#123; array.push(item); console.log(item); &#125;);&#125;var a = [];push(a, 1, 2, 3) // 1, 2, 3 注意，rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错,函数的length属性，不包括rest参数。1234567function f(a, ...b, c) &#123; // ...&#125; // SyntaxError: Rest parameter must be last formal parameter(function(a) &#123;&#125;).length // 1(function(...a) &#123;&#125;).length // 0(function(a, ...b) &#123;&#125;).length // 1 扩展运算符含义扩展运算符spread是三个点...。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。12345678console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll('div')]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] 该运算符主要用于函数调用。123456789101112131415function push(array, ...items) &#123; array.push(...items);&#125;function add(x, y) &#123; return x + y;&#125;var numbers = [4, 38];add(...numbers) // 42// 扩展运算符与正常的函数参数可以结合使用，非常灵活function f(v, w, x, y, z) &#123; &#125;var args = [0, 1];f(-1, ...args, 2, ...[3]); 替代数组的apply方法由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。12345678910111213// ES5的写法function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f.apply(null, args);// ES6的写法function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f(...args); 一个例子是通过push函数，将一个数组添加到另一个数组的尾部123456789// ES5的写法var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];Array.prototype.push.apply(arr1, arr2);// ES6的写法var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];arr1.push(...arr2); 扩展运算符的应用 （1）合并数组 12345678910111213141516// ES5[1, 2].concat(more)// ES6[1, 2, ...more]var arr1 = ['a', 'b'];var arr2 = ['c'];var arr3 = ['d', 'e'];// ES5的合并数组arr1.concat(arr2, arr3);// [ 'a', 'b', 'c', 'd', 'e' ]// ES6的合并数组[...arr1, ...arr2, ...arr3]// [ 'a', 'b', 'c', 'd', 'e' ] （2）与解构赋值结合 123456789101112131415161718const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []:const [first, ...rest] = [\"foo\"];first // \"foo\"rest // []// 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错const [...butLast, last] = [1, 2, 3, 4, 5];// 报错const [first, ...middle, last] = [1, 2, 3, 4, 5];// 报错 （3）函数的返回值 JavaScript的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。123// 代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数Datevar dateFields = readDateFields(database);var d = new Date(...dateFields); （4）字符串 扩展运算符还可以将字符串转为真正的数组12345678910111213141516[...'hello']// [ \"h\", \"e\", \"l\", \"l\", \"o\" ]function length(str) &#123; return [...str].length;&#125;length('x\\uD83D\\uDE80y') // 3let str = 'x\\uD83D\\uDE80y';str.split('').reverse().join('')// 'y\\uDE80\\uD83Dx'[...str].reverse().join('')// 'y\\uD83D\\uDE80x' 上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。 （5）实现了Iterator接口的对象 任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。123456789let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// TypeError: Cannot spread non-iterable object.let arr = [...arrayLike]; 上面代码中，arrayLike是一个类似数组的对象，但是没有部署Iterator接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。 （6）Map和Set结构，Generator函数 扩展运算符内部调用的是数据结构的Iterator接口，因此只要具有Iterator接口的对象，都可以使用扩展运算符，比如Map结构。1234567let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);let arr = [...map.keys()]; // [1, 2, 3] Generator函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。1234567var go = function*()&#123; yield 1; yield 2; yield 3;&#125;;[...go()] // [1, 2, 3] 箭头函数基本用法ES6允许使用“箭头”=&gt;定义函数。123456789101112131415var f = v =&gt; v;// 等同于var f = function(v) &#123; return v;&#125;;var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。1var getTempItem = id =&gt; (&#123; id: id, name: \"Temp\" &#125;); 箭头函数的一个用处是简化回调函数123456789101112131415// 正常函数写法[1,2,3].map(function (x) &#123; return x * x;&#125;);// 箭头函数写法[1,2,3].map(x =&gt; x * x);// 正常函数写法var result = values.sort(function (a, b) &#123; return a - b;&#125;);// 箭头函数写法var result = values.sort((a, b) =&gt; a - b); 下面是rest参数与箭头函数结合的例子。123456789const numbers = (...nums) =&gt; nums;numbers(1, 2, 3, 4, 5)// [1,2,3,4,5]const headAndTail = (head, ...tail) =&gt; [head, tail];headAndTail(1, 2, 3, 4, 5)// [1,[2,3,4,5]] 使用注意点箭头函数有几个使用注意点 （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作Generator函数。 上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。12345678910function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42 上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到100毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。 箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。1234567891011121314151617function Timer() &#123; this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() =&gt; this.s1++, 1000); // 普通函数 setInterval(function () &#123; this.s2++; &#125;, 1000);&#125;var timer = new Timer();setTimeout(() =&gt; console.log('s1: ', timer.s1), 3100);setTimeout(() =&gt; console.log('s2: ', timer.s2), 3100);// s1: 3// s2: 0 上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100毫秒之后，timer.s1被更新了3次，而timer.s2一次都没更新。 箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM事件的回调函数封装在一个对象里面。123456789101112var handler = &#123; id: '123456', init: function() &#123; document.addEventListener('click', event =&gt; this.doSomething(event.type), false); &#125;, doSomething: function(type) &#123; console.log('Handling ' + type + ' for ' + this.id); &#125;&#125;; 上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。所以，箭头函数转成ES5的代码如下。123456789101112131415// ES6function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;// ES5function foo() &#123; var _this = this; setTimeout(function () &#123; console.log('id:', _this.id); &#125;, 100);&#125; 在看一个例子123456789101112131415function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log('id:', this.id); &#125;; &#125;; &#125;;&#125;var f = foo.call(&#123;id: 1&#125;);var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1var t2 = f().call(&#123;id: 3&#125;)(); // id: 1var t3 = f()().call(&#123;id: 4&#125;); // id: 1 上面代码之中，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。12345678function foo() &#123; setTimeout(() =&gt; &#123; console.log('args:', arguments); &#125;, 100);&#125;foo(2, 4, 6, 8)// args: [2, 4, 6, 8] 上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。123456(function() &#123; return [ (() =&gt; this.x).bind(&#123; x: 'inner' &#125;)() ];&#125;).call(&#123; x: 'outer' &#125;);// ['outer'] 嵌套的箭头函数箭头函数内部，还可以再使用箭头函数。下面是一个ES5语法的多重嵌套函数。12345678910function insert(value) &#123; return &#123;into: function (array) &#123; return &#123;after: function (afterValue) &#123; array.splice(array.indexOf(afterValue) + 1, 0, value); return array; &#125;&#125;; &#125;&#125;;&#125;insert(2).into([1, 3]).after(1); //[1, 2, 3] 上面这个函数，可以使用箭头函数改写。123456let insert = (value) =&gt; (&#123;into: (array) =&gt; (&#123;after: (afterValue) =&gt; &#123; array.splice(array.indexOf(afterValue) + 1, 0, value); return array;&#125;&#125;)&#125;);insert(2).into([1, 3]).after(1); //[1, 2, 3] 下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。123456789const pipeline = (...funcs) =&gt; val =&gt; funcs.reduce((a, b) =&gt; b(a), val);const plus1 = a =&gt; a + 1;const mult2 = a =&gt; a * 2;const addThenMult = pipeline(plus1, mult2);addThenMult(5)// 12 如果觉得上面的写法可读性比较差，也可以采用下面的写法。12345const plus1 = a =&gt; a + 1;const mult2 = a =&gt; a * 2;mult2(plus1(5))// 12 函数绑定箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法call、apply、bind。但是，箭头函数并不适用于所有场合，所以ES7提出了函数绑定（function bind）运算符，用来取代call、apply、bind调用。虽然该语法还是ES7的一个提案，但是Babel转码器已经支持。 函数绑定运算符是并排的两个双冒号::，双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。 123456789101112foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments);const hasOwnProperty = Object.prototype.hasOwnProperty;function hasOwn(obj, key) &#123; return obj::hasOwnProperty(key);&#125; 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。1234567var method = ::obj.foo;// 等同于var method = obj::obj.foo;let log = ::console.log;// 等同于var log = console.log.bind(console); 由于双冒号运算符返回的还是原对象，因此可以采用链式写法。1234567891011121314// 例一import &#123; map, takeWhile, forEach &#125; from \"iterlib\";getPlayers()::map(x =&gt; x.character())::takeWhile(x =&gt; x.strength &gt; 100)::forEach(x =&gt; console.log(x));// 例二let &#123; find, html &#125; = jake;document.querySelectorAll(\"div.myClass\")::find(\"p\")::html(\"hahaha\"); 文章参考ECMAScript 6 入门","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6学习笔记之数组的扩展","date":"2016-02-26T16:00:00.000Z","path":"2016/02/27/es6-array-expansion/","text":"数组的扩展Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。下面是一个类似数组的对象，Array.from将它转为真正的数组。 123456789101112let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。 1234567891011// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).forEach(function (p) &#123; console.log(p);&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125; 上面代码中，querySelectorAll方法返回的是一个类似数组的对象，只有将这个对象转为真正的数组，才能使用forEach方法。只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组。 12345Array.from('hello')// ['h', 'e', 'l', 'l', 'o']let namesSet = new Set(['a', 'b'])Array.from(namesSet) // ['a', 'b'] Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 12345678910111213Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9]// 下面的例子是取出一组DOM节点的文本内容。let spans = document.querySelectorAll('span.name');// map()let names1 = Array.prototype.map.call(spans, s =&gt; s.textContent);// Array.from()let names2 = Array.from(spans, s =&gt; s.textContent) Array.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。 1Array.from(&#123; length: 2 &#125;, () =&gt; 'jack') // ['jack', 'jack'] Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种Unicode字符，可以避免JavaScript将大于\\uFFFF的Unicode字符，算作两个字符的bug。 123function countSymbols(string) &#123; return Array.from(string).length;&#125; Array.of()Array.of方法用于将一组值，转换为数组，这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。1234567Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8] 数组实例的copyWithin()数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。1Array.prototype.copyWithin(target, start = 0, end = this.length) 它接受三个参数。 target（必需）：从该位置开始替换数据。 start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 123456789101112131415161718192021// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5]// -2相当于3号位，-1相当于4号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5]// 将3号位复制到0号位[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)// &#123;0: 1, 3: 1, length: 5&#125;// 将2号位到数组结束，复制到0号位var i32a = new Int32Array([1, 2, 3, 4, 5]);i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]// 对于没有部署TypedArray的copyWithin方法的平台// 需要采用下面的写法[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5] 数组实例的find()和findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。12345[1, 4, -5, 10].find((n) =&gt; n &lt; 0) // -5[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 数组实例的fill()fill方法使用给定值，填充一个数组，它接受三个参数。 target（必需）：替换的数据。 start（可选）：从该位置开始替换数据，默认为0。如果为负值，表示倒数。 end（可选）：到该位置前停止替换数据，默认等于数组长度。如果为负值，表示倒数。123['a', 'b', 'c'].fill(7) // [7, 7, 7]new Array(3).fill(7) // [7, 7, 7]['a', 'b', 'c'].fill(7, 1, 2) // ['a', 7, 'c'] 数组实例的entries()，keys()和values()ES6提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 \"a\"// 1 \"b\" 如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历。12345let letter = ['a', 'b', 'c'];let entries = letter.entries();console.log(entries.next().value); // [0, 'a']console.log(entries.next().value); // [1, 'b']console.log(entries.next().value); // [2, 'c'] 数组实例的includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。该方法属于ES7，但Babel转码器已经支持。123[1, 2, 3].includes(2); // true[1, 2, 3].includes(4); // false[1, 2, NaN].includes(NaN); // true 数组推导数组推导（array comprehension）提供简洁写法，允许直接通过现有数组生成新数组。这项功能本来是要放入ES6的，但是TC39委员会想继续完善这项功能，让其支持所有数据结构（内部调用iterator对象），不像现在只支持数组，所以就把它推迟到了ES7。Babel转码器已经支持这个功能。1234var a1 = [1, 2, 3, 4];var a2 = [for (i of a1) i * 2];a2 // [2, 4, 6, 8] 注意，数组推导中，for…of结构总是写在最前面，返回的表达式写在最后面。for…of后面还可以附加if语句，用来设定循环的限制条件。123456789101112131415161718var years = [ 1954, 1974, 1990, 2006, 2010, 2014 ];[for (year of years) if (year &gt; 2000) year];// [ 2006, 2010, 2014 ][for (year of years) if (year &gt; 2000) if(year &lt; 2010) year];// [ 2006][for (year of years) if (year &gt; 2000 &amp;&amp; year &lt; 2010) year];// [ 2006][for (i of [1, 2, 3]) i * i];// 等价于[1, 2, 3].map(function (i) &#123; return i * i &#125;);[for (i of [1,4,2,3,-8]) if (i &lt; 3) i];// 等价于[1,4,2,3,-8].filter(function(i) &#123; return i &lt; 3 &#125;); 文章参考ECMAScript 6 入门","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6学习笔记之数值的扩展","date":"2016-02-19T16:00:00.000Z","path":"2016/02/20/es6-number-expansion/","text":"数值的扩展二进制和八进制表示法ES6提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。从ES5开始，在严格模式之中，八进制就不再允许使用前缀0表示，ES6进一步明确，要使用前缀0o表示。123456789101112131415// es60b111110111 === 503 // true0o767 === 503 // true// es5// 非严格模式(function()&#123; console.log(0o11 === 011);&#125;)() // true// 严格模式(function()&#123; 'use strict'; console.log(0o11 === 011);&#125;)() // Uncaught SyntaxError: Octal literals are not allowed in strict mode. Number.isFinite(), Number.isNaN()ES6在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法，用来检查Infinite和NaN这两个特殊值。Number.isFinite()用来检查一个数值是否非无穷（infinity）。Number.isNaN()用来检查一个值是否为NaN。123456789101112131415Number.isFinite(15); // trueNumber.isFinite(0.8); // trueNumber.isFinite(NaN); // falseNumber.isFinite(Infinity); // falseNumber.isFinite(-Infinity); // falseNumber.isFinite('foo'); // falseNumber.isFinite('15'); // falseNumber.isFinite(true); // falseNumber.isNaN(NaN) // trueNumber.isNaN(15) // falseNumber.isNaN('15') // falseNumber.isNaN(true) // falseNumber.isNaN(9/NaN) // trueNumber.isNaN('true'/0) // trueNumber.isNaN('true'/'true') // true Number.parseInt(), Number.parseFloat()ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。 1234567// ES5的写法parseInt('12.34') // 12parseFloat('123.45#') // 123.45// ES6的写法Number.parseInt('12.34') // 12Number.parseFloat('123.45#') // 123.45 Number.isInteger()Number.isInteger()用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。 12345Number.isInteger(25) // trueNumber.isInteger(25.0) // trueNumber.isInteger(25.1) // falseNumber.isInteger(\"15\") // falseNumber.isInteger(true) // false Number.EPSILONES6在Number对象上面，新增一个极小的常量Number.EPSILON。引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。123456780.1 + 0.2// 0.300000000000000040.1 + 0.2 - 0.3// 5.551115123125783e-175.551115123125783e-17.toFixed(20)// '0.00000000000000005551' 但是如果这个误差能够小于Number.EPSILON，我们就可以认为得到了正确结果。因此，Number.EPSILON的实质是一个可以接受的误差范围。123456785.551115123125783e-17 &lt; Number.EPSILON // truefunction withinErrorMargin (left, right) &#123; return Math.abs(left - right) &lt; Number.EPSILON&#125;withinErrorMargin(0.1 + 0.2, 0.3)// truewithinErrorMargin(0.2 + 0.2, 0.3)// false 安全整数和Number.isSafeInteger()JavaScript能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。 1234567Math.pow(2, 53) // 90071992547409929007199254740992 // 90071992547409929007199254740993 // 9007199254740992Math.pow(2, 53) === Math.pow(2, 53) + 1// true ES6引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。123456789Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1// trueNumber.MAX_SAFE_INTEGER === 9007199254740991// trueNumber.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER// trueNumber.MIN_SAFE_INTEGER === -9007199254740991// true Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。123456789101112131415Number.isSafeInteger('a') // falseNumber.isSafeInteger(null) // falseNumber.isSafeInteger(NaN) // falseNumber.isSafeInteger(Infinity) // falseNumber.isSafeInteger(-Infinity) // falseNumber.isSafeInteger(3) // trueNumber.isSafeInteger(1.2) // falseNumber.isSafeInteger(9007199254740990) // trueNumber.isSafeInteger(9007199254740992) // falseNumber.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // falseNumber.isSafeInteger(Number.MIN_SAFE_INTEGER) // trueNumber.isSafeInteger(Number.MAX_SAFE_INTEGER) // trueNumber.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false Math对象的扩展 Math.trunc() Math.trunc方法用于去除一个数的小数部分，返回整数部分。对于非数值，Math.trunc内部使用Number方法将其先转为数值。对于空值和无法截取整数的值，返回NaN。123456789Math.trunc(4.1) // 4Math.trunc(4.9) // 4Math.trunc(-4.1) // -4Math.trunc(-4.9) // -4Math.trunc(-0.1234) // -0Math.trunc('123.456') // 123Math.trunc(NaN); // NaNMath.trunc('foo'); // NaNMath.trunc(); // NaN Math.sign() Math.sign方法用来判断一个数到底是正数、负数、还是零。1234567Math.sign(-5) // -1Math.sign(5) // +1Math.sign(0) // +0Math.sign(-0) // -0Math.sign(NaN) // NaNMath.sign('foo'); // NaNMath.sign(); // NaN Math.cbrt() Math.cbrt方法用于计算一个数的立方根。123456Math.cbrt(-1) // -1Math.cbrt(0) // 0Math.cbrt(1) // 1Math.cbrt(2) // 1.2599210498948734Math.cbrt('8') // 2Math.cbrt('hello') // NaN Math.clz32() JavaScript的整数使用32位二进制形式表示，Math.clz32方法返回一个数的32位无符号整数形式有多少个前导0。 12345Math.clz32(0) // 32Math.clz32(1) // 31Math.clz32(1000) // 22Math.clz32(0b01000000000000000000000000000000) // 1Math.clz32(0b00100000000000000000000000000000) // 2 Math.imul() Math.imul方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。 123Math.imul(2, 4); // 8Math.imul(-1, 8); // -8Math.imul(-2, -2); // 4 Math.fround() Math.fround方法返回一个数的单精度浮点数形式。12345Math.fround(0); // 0Math.fround(1); // 1Math.fround(1.337); // 1.3370000123977661Math.fround(1.5); // 1.5Math.fround(NaN); // NaN Math.hypot() Math.hypot方法返回所有参数的平方和的平方根。1234567Math.hypot(3, 4); // 5Math.hypot(3, 4, 5); // 7.0710678118654755Math.hypot(); // 0Math.hypot(NaN); // NaNMath.hypot(3, 4, 'foo'); // NaNMath.hypot(3, 4, '5'); // 7.0710678118654755Math.hypot(-3); // 3 对数方法 Math.expm1() Math.expm1(x)返回ex - 1，即Math.exp(x) - 1。123Math.expm1(-1); // -0.6321205588285577Math.expm1(0); // 0Math.expm1(1); // 1.718281828459045 Math.log1p() Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。 1234Math.log1p(1); // 0.6931471805599453Math.log1p(0); // 0Math.log1p(-1); // -InfinityMath.log1p(-2); // NaN Math.log10() Math.log10(x)返回以10为底的x的对数。如果x小于0，则返回NaN。12345Math.log10(2); // 0.3010299956639812Math.log10(1); // 0Math.log10(0); // -InfinityMath.log10(-2); // NaNMath.log10(100000); // 5 Math.log2() Math.log2(x)返回以2为底的x的对数。如果x小于0，则返回NaN。 1234567Math.log2(3) // 1.584962500721156Math.log2(2) // 1Math.log2(1) // 0Math.log2(0) // -InfinityMath.log2(-2) // NaNMath.log2(1024) // 10Math.log2(1 &lt;&lt; 29) // 29 三角函数方法ES6新增了6个三角函数方法。 Math.sinh(x) 返回x的双曲正弦（hyperbolic sine） Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine） Math.tanh(x) 返回x的双曲正切（hyperbolic tangent） Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine） Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine） Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent） 指数运算符ES7新增了一个指数运算符（**），目前Babel转码器已经支持。 1234567let a = 2;a **= 2;// 等同于 a = a * a;let b = 3;b **= 3;// 等同于 b = b * b * b; 文章参考ECMAScript 6 入门","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6学习笔记之字符串的扩展","date":"2016-02-13T16:00:00.000Z","path":"2016/02/14/es6-string-expansion/","text":"ES6加强了对Unicode的支持，并且扩展了字符串对象。 字符的Unicode表示法JavaScript允许采用\\uxxxx形式表示一个字符，其中xxxx表示字符的码点。1\"\\u0061\" // \"a\" 但是，这种表示法只限于\\u0000——\\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表达。12\"\\uD842\\uDFB7\" // \"𠮷\"\"\\u20BB7\" // \" 7\" 上面代码表示，如果直接在\\u后面跟上超过0xFFFF的数值（比如\\u20BB7），JavaScript会理解成\\u20BB+7。由于\\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。ES6对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。1234567\"\\u&#123;20BB7&#125;\" // \"𠮷\"\"\\u&#123;41&#125;\\u&#123;42&#125;\\u&#123;43&#125;\" // \"ABC\"let hello = 123;hell\\u&#123;6F&#125; // 123'\\u&#123;1F680&#125;' === '\\uD83D\\uDE80' // true 有了这种表示法之后，JavaScript共有6种方法可以表示一个字符。12345'\\z' === 'z' // true'\\172' === 'z' // true'\\x7A' === 'z' // true'\\u007A' === 'z' // true'\\u&#123;7A&#125;' === 'z' // true codePointAt()JavaScript内部，字符以UTF-16的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode码点大于0xFFFF的字符），JavaScript会认为它们是两个字符。123456var s = \"𠮷\";s.length // 2s.charAt(0) // ''s.charAt(1) // ''s.charCodeAt(0) // 55362s.charCodeAt(1) // 57271 上面代码中，汉字𠮷的码点是0x20BB7，UTF-16编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript不能正确处理，字符串长度会误判为2，而且charAt方法无法读取整个字符，charCodeAt方法只能分别返回前两个字节和后两个字节的值。 ES6提供了codePointAt方法，能够正确处理4个字节储存的字符，返回一个字符的码点。1234var s = '𠮷a';s.codePointAt(0) // 134071s.codePointAt(1) // 57271s.charCodeAt(2) // 97 codePointAt方法会正确返回32位的UTF-16字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同，codePointAt方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString方法转换一下。123var s = '𠮷a';s.codePointAt(0).toString(16) // \"20bb7\"s.charCodeAt(2).toString(16) // \"61\" String.fromCodePoint()ES5提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别32位的UTF-16字符（Unicode编号大于0xFFFF）。1String.fromCharCode(0x20BB7) // \"ஷ\" 上面代码中，String.fromCharCode不能识别大于0xFFFF的码点，所以0x20BB7就发生了溢出，最高位2被舍弃了，最后返回码点U+0BB7对应的字符，而不是码点U+20BB7对应的字符。 ES6提供了String.fromCodePoint方法，可以识别0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。12String.fromCodePoint(0x20BB7) // \"𠮷\"String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\\uD83D\\uDE80y' // true 注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。 字符串的遍历器接口ES6为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被for...of循环遍历123for (let codePoint of 'foo') &#123; console.log(codePoint)&#125; 除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。123456789var text = String.fromCodePoint(0x20BB7);for (let i = 0; i &lt; text.length; i++) &#123; console.log(text[i]);&#125;// \" \"// \" \"for (let i of text) &#123; console.log(i);// \"𠮷\"&#125; at()ES5对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。1234'abc'.charAt(0) // \"a\"'𠮷'.charAt(0) // \"\\uD842\"'abc'.at(0) // \"a\"'𠮷'.at(0) // \"𠮷\" normalize()为了表示语调和重音符号，Unicode提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\\u004F）和ˇ（\\u030C）合成Ǒ（\\u004F\\u030C）。这两种表示方法，在视觉和语义上都等价，但是JavaScript不能识别。1234'\\u01D1'==='\\u004F\\u030C' //false'\\u01D1'.length // 1'\\u004F\\u030C'.length // 2'\\u01D1'.normalize() === '\\u004F\\u030C'.normalize() // true 不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过Unicode编号区间判断。 includes(), startsWith(), endsWith()传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串 startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部 endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部 12345678let s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // true// 这三个方法都支持第二个参数，表示开始搜索的位置。s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false repeat()repeat方法返回一个新字符串，表示将原字符串重复n次。参数如果是小数，会被取整。如果repeat的参数是负数或者Infinity，会报错。但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于-0，repeat视同为0。参数NaN等同于0。如果repeat的参数是字符串，则会先转换成数字。12345678910'x'.repeat(3) // \"xxx\"'hello'.repeat(2) // \"hellohello\"'na'.repeat(0) // \"\"'na'.repeat(2.9) // \"nana\"'na'.repeat(Infinity)// RangeError'na'.repeat(-1)// RangeError'na'.repeat(-0.9) // \"\"'na'.repeat(NaN) // \"\"'na'.repeat('na') // \"\"'na'.repeat('3') // \"nanana\" 模板字符串传统的JavaScript语言，输出模板通常是这样写的。123456$(\"#result\").append( \"There are &lt;b&gt;\" + basket.count + \"&lt;/b&gt; \" + \"items in your basket, \" + \"&lt;em&gt;\" + basket.onSale + \"&lt;/em&gt; are on sale!\"); 上面这种写法相当繁琐不方便，ES6引入了模板字符串解决这个问题。12345$(\"#result\").append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。12345678910// 普通字符串`In JavaScript '\\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`// 字符串中嵌入变量var name = \"Bob\", time = \"today\";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 上面代码中的字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。1var greeting = `\\`Yo\\` World!`; 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。12345$(\"#warning\").html(` &lt;h1&gt;Watch out!&lt;/h1&gt; &lt;p&gt;Unauthorized hockeying can result in penalties of up to $&#123;maxPenalty&#125; minutes.&lt;/p&gt;`); 模板字符串中嵌入变量，需要将变量名写在${}之中。123456789101112function authorize(user, action) &#123; if (!user.hasPrivilege(action)) &#123; throw new Error( // 传统写法为 // 'User ' // + user.name // + ' is not authorized to do ' // + action // + '.' `User $&#123;user.name&#125; is not authorized to do $&#123;action&#125;.`); &#125;&#125; 大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。123456789101112var x = 1;var y = 2;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`// \"1 + 2 = 3\"`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`// \"1 + 4 = 5\"var obj = &#123;x: 1, y: 2&#125;;`$&#123;obj.x + obj.y&#125;`// 3 模板字符串之中还能调用函数。1234function fn() &#123; return \"Hello World\";&#125;`foo $&#123;fn()&#125; bar` // foo Hello World bar 如果需要引用模板字符串本身，可以像下面这样写。123456789// 写法一let str = 'return ' + '`Hello $&#123;name&#125;!`';let func = new Function('name', str);func('Jack') // \"Hello Jack!\"// 写法二let str = '(name) =&gt; `Hello $&#123;name&#125;!`';let func = eval.call(null, str);func('Jack') // \"Hello Jack!\" 实例：模板编译下面，我们来看一个通过模板字符串，生成正式模板的实例。1234567var template = `&lt;ul&gt; &lt;% for(var i=0; i &lt; data.supplies.length; i++) &#123;%&gt; &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt; &lt;% &#125; %&gt;&lt;/ul&gt;`; 上面代码在模板字符串之中，放置了一个常规模板。该模板使用&lt;%...%&gt;放置JavaScript代码，使用&lt;%= ... %&gt;输出JavaScript表达式。 怎么编译这个模板字符串呢？一种思路是将其转换为JavaScript表达式字符串。1234567echo('&lt;ul&gt;');for(var i=0; i &lt; data.supplies.length; i++) &#123; echo('&lt;li&gt;'); echo(data.supplies[i]); echo('&lt;/li&gt;');&#125;;echo('&lt;/ul&gt;'); 这个转换使用正则表达式就行了。12345678var evalExpr = /&lt;%=(.+?)%&gt;/g;var expr = /&lt;%([\\s\\S]+?)%&gt;/g;template = template .replace(evalExpr, '`); \\n echo( $1 ); \\n echo(`') .replace(expr, '`); \\n $1 \\n echo(`');template = 'echo(`' + template + '`);'; 然后，将template封装在一个函数里面返回，就可以了。1234567891011var script =`(function parse(data)&#123; var output = \"\"; function echo(html)&#123; output += html; &#125; $&#123; template &#125; return output;&#125;)`;return script; 将上面的内容拼装成一个模板编译函数compile。123456789101112131415161718function compile(template)&#123; var evalExpr = /&lt;%=(.+?)%&gt;/g; var expr = /&lt;%([\\s\\S]+?)%&gt;/g; template = template .replace(evalExpr, '`); \\n echo( $1 ); \\n echo(`') .replace(expr, '`); \\n $1 \\n echo(`'); template = 'echo(`' + template + '`);'; var script = `(function parse(data)&#123; var output = \"\"; function echo(html)&#123; output += html; &#125; $&#123; template &#125; return output; &#125;)`; return script;&#125; compile函数的用法如下。12var parse = eval(compile(template));div.innerHTML = parse(&#123; supplies: [ \"broom\", \"mop\", \"cleaner\" ] &#125;); 标签模板模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。123var a = 5;var b = 10;tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`; 上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。函数tag依次会接收到多个参数。1234567function tag(stringArr, value1, value2)&#123; // ...&#125;// 等同于function tag(stringArr, ...values)&#123; // ...&#125; tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。tag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。也就是说，tag函数实际上以下面的形式调用。1tag(['Hello ', ' world ', ''], 15, 50) 我们可以按照需要编写tag函数的代码。下面是tag函数的一种写法，以及运行结果。123456789101112131415var total = 30;var msg = passthru`The total is $&#123;total&#125; ($&#123;total*1.05&#125; with tax)`;function passthru(literals) &#123; var result = \"\"; var i = 0; while (i &lt; literals.length) &#123; result += literals[i++]; if (i &lt; arguments.length) &#123; result += arguments[i]; &#125; &#125; return result;&#125;msg // \"The total is 30 (31.5 with tax)\" 上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。passthru函数采用rest参数的写法如下。12345678function passthru(literals, ...values) &#123; var output = \"\"; for (var index = 0; index &lt; values.length; index++) &#123; output += literals[index] + values[index]; &#125; output += literals[index] return output;&#125; “标签模板”的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容。123456789101112131415161718var message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;function SaferHTML(templateData) &#123; var s = templateData[0]; for (var i = 1; i &lt; arguments.length; i++) &#123; var arg = String(arguments[i]); // Escape special characters in the substitution. s += arg.replace(/&amp;/g, \"&amp;amp;\") .replace(/&lt;/g, \"&amp;lt;\") .replace(/&gt;/g, \"&amp;gt;\"); // Don't escape special characters in the template. s += templateData[i]; &#125; return s;&#125; String.raw()ES6还为原生的String对象，提供了一个raw方法。String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。12345String.raw`Hi\\n$&#123;2+3&#125;!`; // \"Hi\\\\n5!\"String.raw`Hi\\u000A!`; // 'Hi\\\\u000A!'String.raw(&#123; raw: 'test' &#125;, 0, 1, 2); // 't0e1s2t'// 等同于String.raw(&#123; raw: ['t','e','s','t'] &#125;, 0, 1, 2); 文章参考ECMAScript 6 入门","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6学习笔记之变量的解构赋值","date":"2016-02-05T16:00:00.000Z","path":"2016/02/06/es6-destruction-assignment/","text":"变量的解构赋值ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。 数组的解构赋值以前，为变量赋值，只能直接指定值：123var a = 1;var b = 2;var c = 3; ES6允许写成下面这样：1var [a, b, c] = [1, 2, 3]; 这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值，如果解构不成功，变量的值就等于undefined，下面是一些使用嵌套数组进行解构的例子：1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [\"foo\", \"bar\", \"baz\"];third // \"baz\"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // \"a\"y // undefinedz // [] 如果对undefined或null进行解构，会报错。12var [foo] = undefined; // Uncaught TypeError: Cannot match against 'undefined' or 'null'var [foo] = null; // Uncaught TypeError: Cannot match against 'undefined' or 'null' 这是因为解构只能用于数组或对象。其他原始类型的值都可以转为相应的对象，但是，undefined和null不能转为对象，因此报错。 解构赋值允许指定默认值，注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。 1234567891011121314var [foo = true] = [];foo // true[x, y = 'b'] = ['a'] // x='a', y='b'[x, y = 'b'] = ['a', undefined] // x='a', y='b'var [x = 1] = [undefined];console.log(x) // 1var [x = 1] = [null];console.log(x) // nullvar [x = 1] = [2];console.log(x) // 2 上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined，同时2也不严格等于undefined，所以默认值也不会生效。 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError 对象的解构赋值解构不仅可以用于数组，还可以用于对象。123var &#123; foo, bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;console.log(foo); // aaaconsole.log(bar); // bbb 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。12var &#123; baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;console.log(baz) // undefined 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。123var &#123; foo: baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;console.log(baz) // \"aaa\"console.log(foo) // error: foo is not defined 和数组一样，解构也可以用于嵌套结构的对象，在嵌套中，模式是不会被赋值的，只有变量会被赋值。12345678910111213var node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;var &#123; loc: &#123; start: &#123; line &#125;&#125; &#125; = node;console.log(line) // 1console.log(loc) // error: loc is undefinedconsole.log(start) // error: start is undefined 如果要将一个已经声明的变量用于解构赋值，必须非常小心。 12345678var x;// 错误的写法&#123;x&#125; = &#123;x: 1&#125;;// 正确的写法(&#123;x&#125; = &#123;x: 1&#125;);// SyntaxError: syntax error 上面代码的写法会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。123456789const [a, b, c, d, e] = 'hello';console.log(a) // \"h\"console.log(b) // \"e\"console.log(c) // \"l\"console.log(d) // \"l\"console.log(e) // \"o\"let &#123;length : len&#125; = 'hello';console.log(len) // 5 函数参数的解构赋值函数的参数也可以使用解构赋值12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x = 0和y = 0的值。如果解构失败，x和y等于默认值。12345678function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。但是undefined就会触发函数参数的默认值。12[1, undefined, 3].map((x = 'yes') =&gt; x) // [ 1, 'yes', 3 ] 不能使用圆括号的情况 变量声明语句中，不能带有圆括号 1234567// 全部报错var [(a)] = [1];var &#123;x: (c)&#125; = &#123;&#125;;var (&#123;x: c&#125;) = &#123;&#125;;var &#123;(x: c)&#125; = &#123;&#125;;var &#123;(x): c&#125; = &#123;&#125;;&#125;var &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;; 函数参数中，模式不能带有圆括号 12// 全部报错function f([(z)]) &#123; return z; &#125; 赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中 1234// 全部报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5];[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;]; 可以使用圆括号的情况可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。 123[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确 上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。 用途 交换变量的值 1[x, y] = [y, x]; 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 从函数返回多个值 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便1234567891011121314// 返回一个数组function example() &#123; return [1, 2, 3];&#125;var [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;var &#123; foo, bar &#125; = example(); 函数参数的定义 解构赋值可以方便地将一组参数与变量名对应起来。1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3])// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;) 提取JSON数据 解构赋值对提取JSON对象中的数据123456789var jsonData = &#123; id: 42, status: \"OK\", data: [867, 5309]&#125;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number) // 42, \"OK\", [867, 5309] 函数参数的默认值 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || &#39;default foo&#39;;这样的语句。1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 遍历Map结构 任何部署了Iterator接口的对象，都可以用for…of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。123456789var map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + \" is \" + value);&#125;// first is hello// second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。123456789// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; 输入模块的指定方法 加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。1const &#123; SourceMapConsumer, SourceNode &#125; = require(\"source-map\"); 文章参考ECMAScript 6 入门","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6学习笔记之let && const","date":"2016-01-30T16:00:00.000Z","path":"2016/01/31/es6-let-and-const/","text":"ES6新增了let和const命令，用来声明变量。 let命令基本用法let的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。123456&#123; let a = 10; var b = 6;&#125;console.log(a); //undefinedconsole.log(b); //6 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量undefined，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。 for循环的计数器，就很合适使用let命令123456789101112131415var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 不存在变量提升1234console.log(foo); // undefinedconsole.log(bar); // Uncaught ReferenceError: bar is not definedvar foo = 2;let bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。12345var tmp = 123;if (true) &#123; tmp = 'abc'; // Uncaught ReferenceError: tmp is not defined let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。12345678910111213141516&#123; let a = 10; var a = 1; // Uncaught SyntaxError: Unexpected identifier&#125;&#123; let a = 20; let a = 2; // Uncaught SyntaxError: Unexpected identifier&#125;function func(arg) &#123; let arg; // Uncaught SyntaxError: Identifier 'arg' has already been declared&#125;function func(arg) &#123; &#123; let arg; // undefined &#125;&#125; 块级作用域ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 内层变量可能会覆盖外层变量 123456var tmp = 'abc';function f()&#123; console.log(tmp); var tmp = \"hello world\";&#125;f() // undefined 上面代码中，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 用来计数的循环变量泄露为全局变量 1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 ES6中的let实际上为JavaScript新增了块级作用域。12345678function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); &#125;f1(); // 5 另外，ES6也规定，函数本身的作用域，在其所在的块级作用域之内。12345678function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if(false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;()); 上面代码在ES5中运行，会得到“I am inside!”，但是在ES6中运行，会得到“I am outside!”。这是因为ES5存在函数提升，不管会不会进入 if代码块，函数声明都会提升到当前作用域的顶部，得到执行；而ES6支持块级作用域，不管会不会进入if代码块，其内部声明的函数皆不会影响到作用域的外部。 上面代码中，块级作用域外部，无法调用块级作用域内部定义的函数。如果确实需要调用，就要像下面这样处理。12345678let f;&#123; let a = 'secret'; f = function () &#123; return a; &#125;&#125;f() // \"secret\" ES5的严格模式规定，函数只能在顶层作用域和函数内声明，其他情况（比如if代码块、循环代码块）的声明都会报错。12345// ES5'use strict';if (true) &#123; function f() &#123;&#125; // undefined&#125; const命令const这个声明创建了一个常量，可以在全局作用域或者函数内声明常量，在定义常量的同时必须初始化，常量的值不能通过再赋值改变，也不能再次声明。12const PI = 3.1415;PI = 3; Uncaught TypeError: Identifier 'PI' has already been declared 文章参考ECMAScript 6 入门","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6学习笔记","date":"2016-01-22T16:00:00.000Z","path":"2016/01/23/es6/","text":"ECMAScript 6简介ECMAScript6（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015，也就是说，ES6就是ES2015。 工具安装因为目前各大游览器对ES6的支持不是很好，所以我们需要用到工具对ES6进行转码，这里我们用babel来转码，因为项目里面还会用到其他前端自动化的东西，所以这里我们选择用gulp+babel 安装gulp1npm install --save-dev gulp 安装gulp-babel1npm install --save-dev gulp-babel 配置如下12345678910111213var gulp = require('gulp');var babel = require('gulp-babel');gulp.task('es6', function () &#123; return gulp.src('build/es6/*.js') .pipe(babel()) .pipe(gulp.dest('build/js/'));&#125;);gulp.task('watch-es6',function (done) &#123; gulp.watch('build/es6/*.js', ['es6']) .on('end', done);&#125;);gulp.task('default',['watch-es6']); 下次再用webpack来进行相关配置。 文章参考ECMAScript 6 入门","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"移动端关于px,rem,em的选择","date":"2016-01-16T16:00:00.000Z","path":"2016/01/17/px-or-rem-or-em/","text":"先来介绍下这三个单位： px：px是Pixel（像素）的缩写，相对长度单位，这个是相对于屏幕的分辨率来说的。em：相对于父亲元素的单位，例如设置body为font-size:62.5%因为游览器默认body是16像素，这样计算就可以使得1em = 10px，方便计算。但是这里会存在一个问题，em是相对于父元素的，例如一个ul是16px即为1.6em，里面有li为1.6em，这样计算的话li的实际font-size为10x16x16，如果里面有其他元素就更麻烦了，这里可以设置li li, li p, li span, li p span, p span{font-size:1em}来重置字体，但是结构复杂的时候就很麻烦了。rem：root em，看到这个我们就可以理解rem是相对根元素html的，例如如果设置font-size:16px，然后设置p{font-size:1rem},那么这里的p标签就是16px。 接下来说一下几个概念： 物理像素（physical pixel）：一个物理像素是显示器(手机屏幕)上最小的物理显示单元，在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值。设备独立像素（density-independent pixel）：设备独立像素(也叫密度无关像素)，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css像素)，然后由相关系统转换为物理像素。设备像素比(device pixel ratio )：设备像素比(简称dpr)定义了物理像素和设备独立像素的对应关系，它的值可以按如下的公式的得到设备像素比 = 物理像素 / 设备独立像素 在javascript中，可以通过window.devicePixelRatio获取到当前设备的dpr。 在css中，可以通过-webkit-device-pixel-ratio，-webkit-min-device-pixel-ratio和 -webkit-max-device-pixel-ratio进行媒体查询，对不同dpr的设备，做一些样式适配(这里只针对webkit内核的浏览器和webview)。 一般来说，为了保持在不同屏幕上字体大小的显示一致，会根据不同屏幕来显示不同的字号，而字体用rem的话误差太大，且不能满足任何屏幕下字体大小看起来一样，所以一般字体用px。宽度，高度这些值则会用rem来显示，接下会有另外一篇文章具体说明这个。 目前我们的设计稿都是750的宽，我们可以用下面的js来设置html字体，并在meta上设置scale,dpr（这里我们以10为基准）：1234567891011121314151617181920212223242526272829303132var dpr, rem, scale;var docEl = document.documentElement;var fontEl = document.createElement('style');var metaEl = document.querySelector('meta[name=\"viewport\"]');dpr = window.devicePixelRatio || 1;rem = docEl.clientWidth * dpr / 75;scale = 1 / dpr;// 设置viewport，进行缩放，达到高清效果metaEl.setAttribute('content', 'width=' + dpr * docEl.clientWidth + ',initial-scale=' + scale + ',maximum-scale=' + scale + ', minimum-scale=' + scale + ',user-scalable=no');// 设置data-dpr属性，留作的css hack之用docEl.setAttribute('data-dpr', dpr);// 动态写入样式docEl.firstElementChild.appendChild(fontEl);fontEl.innerHTML = 'html&#123;font-size:' + rem + 'px!important;&#125;';// 给js调用的，某一dpr下rem和px之间的转换函数window.rem2px = function(v) &#123; v = parseFloat(v); return v * rem;&#125;;window.px2rem = function(v) &#123; v = parseFloat(v); return v / rem;&#125;;window.dpr = dpr;window.rem = rem; 接下来我们可以写两个sass的mixin函数来将px转换成rem以及根据不同的dpr来设置不同字体：123456789101112131415161718192021222324252627282930313233343536373839404142//px2px@mixin px2px($name, $px)&#123; @if(data-dpr=&quot;1&quot;)&#123; [data-dpr=&quot;1&quot;] &amp; &#123; #&#123;$name&#125;: round($px / 2) * 1px; &#125; &#125; @if(data-dpr=&quot;1.5&quot;)&#123; [data-dpr=&quot;1.5&quot;] &amp; &#123; #&#123;$name&#125;: round($px * 1.5 / 2)* 1px; &#125; &#125; @if(data-dpr=&quot;2&quot;)&#123; [data-dpr=&quot;2&quot;] &amp; &#123; #&#123;$name&#125;: $px * 1px; &#125; &#125; @if(data-dpr=&quot;2.5&quot;)&#123; [data-dpr=&quot;2.5&quot;] &amp; &#123; #&#123;$name&#125;: round($px * 2.5 / 2) * 1px; &#125; &#125; @if(data-dpr=&quot;2.75&quot;)&#123; [data-dpr=&quot;2.75&quot;] &amp; &#123; #&#123;$name&#125;: round($px * 2.75 / 2) * 1px; &#125; &#125; @if(data-dpr=&quot;3&quot;)&#123; [data-dpr=&quot;3&quot;] &amp; &#123; #&#123;$name&#125;: round($px / 2 * 3) * 1px &#125; &#125; @if(data-dpr=&quot;4&quot;)&#123; [data-dpr=&quot;4&quot;] &amp; &#123; #&#123;$name&#125;: $px * 2px; &#125; &#125;&#125;//px2rem@mixin px2rem($name, $px)&#123; #&#123;$name&#125;: round($px / 10) * 1rem;&#125; 然后使用的时候就像这样：12@include px2px(&apos;font-size&apos;, 28);@include px2rem(&apos;width&apos;, 400);","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"mobile","slug":"mobile","permalink":"http://yoursite.com/tags/mobile/"},{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"},{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"},{"name":"sass","slug":"sass","permalink":"http://yoursite.com/tags/sass/"}]},{"title":"移动端真机调试终极利器-BrowserSync","date":"2016-01-12T16:00:00.000Z","path":"2016/01/13/browsersync/","text":"在移动开发中，我们经常会碰到不同设备，不同游览器，不同平台的调试问题，这个在开发过程中常常是挡在我们面前的“大难题”，现在介绍browsersync 这个工具并结合常用的gulp来进行调试，今天就介绍一下这个工具的用法： 一、安装官网有Get started 教程，但是使用起来没用gulp方便，官方也有BrowserSync for Gulp的插件，并有明确文档说明如何与Gulp整合 。 1、安装开发依赖 browsersync是依赖于node的，所以我们得先安装node，建议选择LTS版本，比较稳定，安装好之后我们可以看看版本信息： 接下来安装gulp，因为gulp经常会用到，所以可以考虑在全局安装：1npm install --global gulp 如果只想在本项目适用的话：1npm install --save-dev gulp 接下来安装browsersync插件：1npm install browser-sync gulp --save-dev 2、编辑gulpfile.js 文件目录如下： index.html在bin文件夹中，js如下： 12345678910var gulp = require('gulp');var browserSync = require('browser-sync').create();gulp.task('browser-sync', function() &#123; browserSync.init(&#123; server: &#123; baseDir: \"./bin\" &#125; &#125;); gulp.watch(\"./bin/**/*.*\").on('change', browserSync.reload);&#125;); 二、启动打开终端输入： 1gulp browser-sync 此时浏览器会自动打开http://localhost:3000的页面，我们会发现这个页面正是指向./bin目录下的index.html，这与我们在gulpfile.js中的设置相符 note 这里默认是读取index.html，但是开发过程中有时不是index.html，然后会出现如下提示： 这里不用担心，只要把路径修改为相对应的就可以： BrowserSync启动后终端界面会有两个端口提示，分别是:3000的项目页面，和:3001的BrowserSync的UI界面，并且每个端口都有供本地（localhost）和外部（局域网IP）访问的URL： 因为我们把BrowserSync的reload加到了gulp的watch里，所以只要./bin下面的文件发生变化所有访问local URL或External URL的客户端（client）都会自动刷新。接下来我们把手机和电脑要连接在同一个无线局域网里，然后在手机端输入对应的外网ip地址就可以在手机端调试了。 三、调试我们在PC的浏览器中打开http://localhost:3001，这个端口为3001的URL是BrowserSync的操作界面： 点击出现的红色字：Access remote debugger (opens in a new tab)，就会打开weinre的控制台界面： 需要注意的是，要先打开自己的项目页面，再打开Remote Debugger，这样才能列出当前已经连接的客户端。否则的话，即使项目页面和BrowserSync是连接状态，Remote Debugger也会出现捕捉不到的情况。因此，可能需要关闭再重新开启Remote Debugger进行调试。","tags":[{"name":"mobile","slug":"mobile","permalink":"http://yoursite.com/tags/mobile/"},{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"},{"name":"browsersync","slug":"browsersync","permalink":"http://yoursite.com/tags/browsersync/"}]},{"title":"css中水平垂直居中的总结","date":"2015-10-30T16:00:00.000Z","path":"2015/10/31/css-center/","text":"水平居中1、元素内容的水平居中 说到这个就不得不说到一个属性text-align，text-align属性定义行内内容（例如文字）如何相对于它的父元素进行对齐， 但是并不控制块元素自己的对齐，只控制它的行内内容的对齐，这个属性能很好的解决部分水平居中的问题。 初始值：start适用元素：display为block，inline-block，inherit的元素属性值：start | end | left | right | center | justify | match-parent | start end dsky on jsbin.com 2、元素的水平居中 dsky on jsbin.com 垂直居中1、元素内容的垂直居中 内容的垂直居中的话，vertical-align是一个常用的属性，vertical-align 指定了行内（inline）元素或表格单元格（table-cell）元素的垂直对齐方式。 初始值：baseline适用元素：display为inline，inline-block，table-cell，::first-letter，::first-line的元素属性值：baseline | sub | super | text-top | text-bottom | middle | top | bottom | | dsky on jsbin.com 2、元素的垂直居中 dsky on jsbin.com 水平垂直居中1、元素内容的水平垂直居中 dsky on jsbin.com 2、元素的水平垂直居中 dsky on jsbin.com","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"}]},{"title":"那些被我们忽略的bootstrap组件","date":"2015-10-23T16:00:00.000Z","path":"2015/10/24/bootstrap/","text":".navbar(导航条)导航条是在您的应用或网站中作为导航页头的响应式基础组件。它们在移动设备上可以折叠（并且可开可关），且在视口（viewport）宽度增加时逐渐变为水平展开模式。 navbar on jsbin.com .breadcrumb(路径导航)在一个带有层次的导航结构中标明当前页面的位置。各路径间的分隔符已经自动通过 CSS 的 :before 和 content 属性添加了。 breadcrumb on jsbin.com .pagination (分页)为网站或应用提供带有展示页码的分页组件 pagination on jsbin.com .label(标签)标签 label on jsbin.com .badge(徽章)给链接、导航等元素嵌套 &lt;span class=&quot;badge&quot;&gt;元素，可以很醒目的展示新的或未读的信息条目。如果没有新的或未读的信息条目，也就是说不包含任何内容，徽章组件能够自动隐藏（通过CSS的 :empty 选择符实现) 。 badge on jsbin.com .jumbotron(巨幕)这是一个轻量、灵活的组件，它能延伸至整个浏览器视口来展示网站上的关键内容。如果需要让巨幕组件的宽度与浏览器宽度一致并且没有圆角，请把此组件放在所有 .container 元素的外面，并在组件内部添加一个.container元素。 JS Bin on jsbin.com .thumbnail(缩略图)通过缩略图组件扩展 Bootstrap 的 栅格系统，可以很容易地展示栅格样式的图像、视频、文本等内容。 thumbnail on jsbin.com .media(媒体对象)这是一个抽象的样式，用以构建不同类型的组件，这些组件都具有在文本内容的左或右侧对齐的图片，适用于自适应布局。图片或其他媒体类型可以顶部、中部或底部对齐。默认是顶部对齐。 JS Bin on jsbin.com .panel (面版)虽然不总是必须，但是某些时候你可能需要将某些 DOM 内容放到一个盒子里。对于这种情况，可以试试面板组件。 JS Bin on jsbin.com .alert警告框组件通过提供一些灵活的预定义消息，为常见的用户动作提供反馈消息。 JS Bin on jsbin.com","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"},{"name":"bootstrap","slug":"bootstrap","permalink":"http://yoursite.com/tags/bootstrap/"}]},{"title":"jqueryvalidation学习总结","date":"2015-10-16T16:00:00.000Z","path":"2015/10/17/jqueryvalidation/","text":"最近一段时间忙着项目，没怎么更新博客，现在抽空总结下项目中用到的插件和碰到的问题，先说说jqueryvalidation debug 是否开启danebug模式，如果开启的话，那么表单不会提交，只进行检查，然后某些错误将会打印在控制台上面 123$(\".selector\").validate(&#123; debug: true&#125;); submitHandler type:function当表单验证完成之后执行的函数，获取表单作为唯一的参数 12345$(\".selector\").validate(&#123; submitHandler: function(form) &#123; console.log(\"done\"); &#125;&#125;); invalidHandler type:function当表单验证完成之前执行的函数，调用事件对象作为第一个参数，第二个为验证器（validator） 123456789101112131415$(\".selector\").validate(&#123; invalidHandler: function(event, validator) &#123; // 'this' refers to the form var errors = validator.numberOfInvalids(); if (errors) &#123; var message = errors == 1 ? 'You missed 1 field. It has been highlighted' : 'You missed ' + errors + ' fields. They have been highlighted'; $(\"div.error span\").html(message); $(\"div.error\").show(); &#125; else &#123; $(\"div.error\").hide(); &#125; &#125;&#125;); ignore type: 元素验证时忽略的元素，也就是不会被验证的元素，这里默认：hidden，readyonly的元素是不会被验证的 1234//拥有ignore这个class的元素不会被验证$(\"#myform\").validate(&#123; ignore: \".ignore\"&#125;); rules type: 对象这里会接受一组规则，规则里面有各种方法，jqueryvalidation自带默认方法，例如required，min，number，range等等 html 部分1234&lt;input name=\"name\" type=\"text\"/&gt;&lt;input name=\"email\" type=\"email\"/&gt;&lt;input name=\"checkbox\" type=\"checkbox\" id=\"checkbox\" /&gt;&lt;input name=\"tel\" type=\"tel\"/&gt; js部分1234567891011121314151617$(\".selector\").validate(&#123; rules: &#123; //rules里面是根据name来做规则的 name: \"required\", email: &#123; required: true, //这里的email是单独写的验证方法，为ture是表示采用这个方法 email: true &#125;, tel:&#123; //依赖关系 depends: function(element) &#123; return $(\"#checkbox\").is(\":checked\"); &#125; &#125; &#125;&#125;); messages type: 对象这里会接受一组对象，里面是对错误信息的语言提示，默认自带英文提示，可以引入语言包来替换成中文，也可以自己定义 12345678910111213141516$(\".selector\").validate(&#123; rules: &#123; name: \"required\", email: &#123; required: true, email: true &#125; &#125;, messages: &#123; name: \"Please specify your name\", email: &#123; required: \"We need your email address to contact you\", email: \"Your email address must be in the format of name@domain.com\" &#125; &#125;&#125;); groups type: 对象指定错误消息分组。一个组由一个任意的组名作为键，一个由空白符分割的表单元素name属性列表作为值。用errorPlacement定义组消息的存放位置。 123456789101112$(\"#myform\").validate(&#123; groups: &#123; username: \"fname lname\" &#125;, errorPlacement: function(error, element) &#123; if (element.attr(\"name\") == \"fname\" || element.attr(\"name\") == \"lname\" ) &#123; error.insertAfter(\"#lastname\"); &#125; else &#123; error.insertAfter(element); &#125; &#125;&#125;); focusCleanup type: Boolean默认为false，如果为true，则当验证元素获得焦点时，移除错误class，并且隐藏错误信息。 123$(\".selector\").validate(&#123; focusCleanup: true&#125;); errorElement type: String存放错误信息的元素，默认是label 123$(\".selector\").validate(&#123; errorElement: \"em\"&#125;); wrapper type: String包裹错误信息的元素，默认是window 123$(\".selector\").validate(&#123; wrapper: \"li\"&#125;); errorLabelContainer type: Selector错误消息标签的容器，当验证的时候，显示和隐藏这个容器 12345$(\"#myform\").validate(&#123; errorLabelContainer: \"#messageBox\", wrapper: \"li\", submitHandler: function() &#123; alert(\"Submitted!\") &#125;&#125;); errorContainer type: Selector错误消息的容器，当验证的时候，显示和隐藏这个容器 1234567$(\"#myform\").validate(&#123; errorContainer: \"#messageBox1, #messageBox2\", errorLabelContainer: \"#messageBox1 ul\", wrapper: \"li\", debug:true, submitHandler: function() &#123; alert(\"Submitted!\") &#125;&#125;); showErrors type: Function()自定义消息显示的句柄。该回调函数有两个参数，第一个为errorMap,第二个参数为errorList，在validator对象的上下文中调用。参数只包含那些经过onblur/onkeyup验证 的表单元素，也有可能是单个元素。除此之外，你还可以用this.defaultShowErrors()触发默认的行为。 12345678$(\".selector\").validate(&#123; showErrors: function(errorMap, errorList) &#123; $(\"#summary\").html(\"Your form contains \" + this.numberOfInvalids() + \" errors, see details below.\"); this.defaultShowErrors(); &#125;&#125;); errorMap，type:Object,键/值对，key是未通过验证的元素的name值,value是错误提示信息errorList，type:Array，errorList有两个属性,一个是message(错误提示信息)，另外一个是element(对应的未通过验证的DOM元素)。 errorPlacement type: Function()用户自定义错误标签的显示位置。第一个参数：一个作为jQuery对象的错误标签，第二个参数为：一个作为jQuery对象的未通过验证的表单元素。 12345$(\"#myform\").validate(&#123; errorPlacement: function(error, element) &#123; error.appendTo( element.parent(\"td\").next(\"td\") ); &#125;&#125;); highlight, unhighlight type: Function()将未通过验证的表单元素设置高亮或者取消高亮。 123456789101112$(\".selector\").validate(&#123; highlight: function(element, errorClass, validClass) &#123; $(element).addClass(errorClass).removeClass(validClass); $(element.form).find(\"label[for=\" + element.id + \"]\") .addClass(errorClass); &#125;, unhighlight: function(element, errorClass, validClass) &#123; $(element).removeClass(errorClass).addClass(validClass); $(element.form).find(\"label[for=\" + element.id + \"]\") .removeClass(errorClass); &#125;&#125;); ignoreTitle type: Boolean将未通过验证的表单元素设置高亮或者取消高亮。 123$(\".selector\").validate(&#123; ignoreTitle: true&#125;); require_from_groupremote","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"http://yoursite.com/tags/jquery/"},{"name":"jqueryvalidation","slug":"jqueryvalidation","permalink":"http://yoursite.com/tags/jqueryvalidation/"},{"name":"validate","slug":"validate","permalink":"http://yoursite.com/tags/validate/"}]},{"title":"用angularjs制作2048游戏","date":"2015-09-11T16:00:00.000Z","path":"2015/09/12/using-angular-to-make-2048-game/","text":"文章翻译自 Building the 2048 game in AngularJS， 整个译文带有自己的理解与想法，如果译得不好或有不对之处还请指点和见谅 第一步：规划程序我们要做的第一步就是高层次(认真仔细有逻辑)的设计我们将要做的应用。我们如果这样做，无论应用程序有多大或者我们克隆另外一个应用，或者从头开始创建，都可以很轻松，容易。 先来看看这个游戏，我们可以看到有很多瓷砖在游戏板上面。每一个瓷砖本身作为一个位置被一个标有数字的瓷砖来放置。根据上面的情况，我们可以把放置瓷砖的职责交给css3，而不是依靠需要知道去哪放置瓷砖的javascript。当我们有一个瓷砖在面板上面的时候，我们基本可以确定瓷砖被摆放在一个合适的位置上面。使用css3让我们有能力摆脱（解决）css的动画工作，同时，我们使用默认的AngularJS行为去跟踪面板和瓷砖的状态，游戏逻辑。因为我们只有一个页面，我们仅仅只需要一个控制器去管理页面。因为在APP运行期间，只有一个游戏面板，然后，我们将包含所有的网格逻辑在一个单一的实例GridService服务中。因为服务是一个单例对象，这样正好适合存储网格。我们会使用GridService服务去解决放置瓷砖，移动瓷砖，遍历网格找到瓷砖可能位置和管理网格的所有问题。我们将使用另外一个叫做GameManager的服务来存储游戏逻辑和处理内部服务。GameManager服务将负责管理游戏的统计，解决移动，记录成绩（包括当前游戏数据和最高分数）。最后，我们需要一个让我们控制键盘的组件。为了解决这个，我们将使用一个叫做KeyboardService的服务（我们只需要一个处理器在这个APP中）。在这篇文章中，我们将会在APP中完成对桌面的处理，但是我们可以重复使用这个相同的服务去解决移动设备的触摸事件。 构建app为了构建我们的应用，我们创建了一个基本APP（我们使用叫做yeoman的angular生成器来生成APP的结构，但是这个并不是必要的我们。我们只把它作为一个起点,但很快偏离它的结构）。我们直接创建覆盖整个结构的APP。我们会把test/目录作为app /的同级目录。 接下来的介绍是用yeoman工具安装项目。如果你更喜欢手动安装，你可以跳过安装依赖，然后直接跳到下一节。 因为在我们的应用中使用了yeoman，我们一开始需要确认yeoman是否安装。Yeoman依赖于nodejs和npm是否安装了。安装nodejs超出了这篇教程的范围之外，但是有一个伟大的指导在NodeJS.org上面。npm安装好了之后，我们可以安装yeoman工具yo和angular产生器（生成器将会被yo工具使用去创建我们的Angular app）。12$ npm install -g yo$ npm install -g generator-angular 当上面这些安装好了之后，我们可以按照下面的方法用yeoman工具创建我们的应用12$ cd ~/Development &amp;&amp; mkdir 2048$ yo angular twentyfourtyeight 安装的时候，工具将会问我们一些问题，我们对所有问题都选择是，仅仅除了选择angular-cookies作为依赖，因为我们不需要任何其他提供的依赖。 需要注意的是，使用Angular产生器，它会期望你已经安装了compass gem 和ruby环境。通过找打完整来源的方法来避免使用ruby和compass。 下面是手动方法通过bower来构建目录。（自己写的）首先通过nodejs安装bower,也可以去bower上面自己查看。1$ npm install -g bower 然后安装所需要的依赖包1234$ bower install angular$ bower install angular-mocks$ bower install angular-cookies$ bower install angular-animate 最终目录如下 我们的angular模块我们将会在scripts目录创建app.js文件来控制我们的应用。让我们创建我们应用的开始代码1angular.module('twentyfourtyeightApp', []) 第二部：模块结构这个angular app的推荐的布局结构是通过功能，而不是类型。那就意味着，我们将在功能的基础上定义我们的模块，而不是通过控制器，服务，指令等等来拆分我们的组件。比如，我么吧将定义一个Game模块和Keyboard模块在我们的应用中。这种模块结构给了我们和文件结构匹配的完全分离的职责。这样做不仅能帮助我们构建更大更复杂的应用，同时也能帮助我们在我们的应用程序之前实现函数共享。 视图最容易开始构建我们应用的地方就是视图。我们先看看视图，我们只有一个视图（模板）。我们不需要复杂的视图在我们应用中，所以我们将创建一个单独的div元素来包含我们的应用内容。在我们app/index.html文件中，我们需要包含所有我们的依赖（包括angular.js自己作为我们的js文件，暂时，这是简单的scripts/app.js），像这样12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;2048&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"styles/main.css\"/&gt;&lt;/head&gt;&lt;body ng-app=\"twentyfourtyeightApp\"&gt; &lt;div class=\"container\" ng-include=\"'views/main.html'\"&gt;&lt;/div&gt; &lt;script src=\"bower_components/angular/angular.min.js\"&gt;&lt;/script&gt; &lt;script src=\"scripts/app.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 随意去制作一个更加复杂版本的多视图游戏，如果这也样做了，请在下面留言。我们将会很高兴看到你制作的东西。 随着我们的app/index.html文件已经设置好，我们只需要为应用程序级视图详述出视图在我们的app/views/main.html文件中。我们仅仅只需要修改index.html文件，并且我们需要在应用程序中引入一个新的来源。打开我们的app/views/main.html文件，我们将放置我们所有的游戏专用视图。使用controller as 语法，我们将能够明确哪里我们期望找到数据在$scope，并且明确哪个控制器负责处理哪个组件。1234&lt;!-- app/views/main.html --&gt;&lt;div id=\"content\" ng-controller='GameController as ctrl'&gt; &lt;!-- Now the variable: ctrl refers to the GameController --&gt;&lt;/div&gt; controller as是在版本1.2中推出的相对较新的语法 。当解决有多个控制器在页面上同时它允许我们具体的了解哪里我们期待功能和数据可以被定义的问题时很有用。 在我们的视图中，最低限度，我们想去展现一些东西： 游戏的静态头部 当前游戏的分数和本地用户的最高分数 游戏面板 静态的头部可以这么简单：1234567891011&lt;!-- heading inside app/views/main.html --&gt;&lt;div id=\"content\" ng-controller='GameController as ctrl'&gt; &lt;div id=\"heading\" class=\"row\"&gt; &lt;h1 class=\"title\"&gt;ng-2048&lt;/h1&gt; &lt;div class=\"scores-container\"&gt; &lt;div class=\"score-container\"&gt;&#123;&#123; ctrl.game.currentScore &#125;&#125;&lt;/div&gt; &lt;div class=\"best-container\"&gt;&#123;&#123; ctrl.game.highScore &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- ... --&gt;&lt;/div&gt; 注意，在视图中，当我们引用currentScore和highScore时，我们也要引用GameController。controller as语法允许我们准确应用我们感兴趣的控制器。 第三步，GameController现在我们有了一个合理的项目结构，让我们创建GameController来展现我们在视图中看到的值。在app/scripts/app.js里面，我们可以创建在主要模块twentyfourtyeightApp上的控制器：1234angular.module('twentyfourtyeightApp', []).controller('GameController', function() &#123;&#125;); 在视图中，我们引用设置在GameController上的一个game对象。game对象将会引用主要的游戏对象。我们将在一个新的模块创建这个游戏主要对象，我们将创建一个保存游戏的所有引用。因为这个模块目前还没有被创建，应用程序不会在浏览器中加载。在控制器内，我们可以添加GameManager依赖：123.controller('GameController', function(GameManager) &#123; this.game = GameManager;&#125;); 记住，我们正在创建一个模块化水平依赖与此不同的我们的应用程序的一部分，所以为了确认它在我们的app中是否加载，我们需要去将其列为我们angular模块的一个依赖。为了让Game模块作为我们twentyfourtyeightApp的依赖，我们将其放在我们模块定义的数组中。我们全部的app/scripts/app.js文件应该像这样：12345angular.module('twentyfourtyeightApp', ['Game']).controller('GameController', function(GameManager) &#123; this.game = GameManager;&#125;); 游戏现在我们的视图部分连接到视图，我们可以开始构建游戏本身背后的逻辑。为了去创建一个新的游戏模块，让我们在app/scripts/目录中的app/scripts/game/game.js创建我们的模块。1angular.module(&apos;Game&apos;, []); 当创建模块，我们喜欢将它们写在以模块命名的自己的目录中。我们将在一个以模块命名的文件中，实现模块的初始化。例如，我们正在创建一个game模块，所以我们将在app/scripts/game里面名为game.js的文件中创建我们的游戏模块。这种方法在产品中提供了可以拓展的和条理分明。 Game模块将会提供一个核心模块：GameManager。我们写GameManager是为了负责保持这种状态的游戏，用户可以做的各种运动，追踪分数，同时确定什么时候游戏结束，以及用户是否打败游戏或者被游戏打败。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"angularjs","slug":"angularjs","permalink":"http://yoursite.com/tags/angularjs/"},{"name":"translate","slug":"translate","permalink":"http://yoursite.com/tags/translate/"}]},{"title":"Angularjs学习(9)之服务","date":"2015-09-04T16:00:00.000Z","path":"2015/09/05/angularJS-learning-9/","text":"到目前为止，我们只关心视图是如何同$scope绑定在一起，以及控制器是如何管理数据的。出于内存占用和性能的考虑，控制器只会在需要时被实例化，并且不再需要就会被销毁。这意味着每次切换路由或重新加载视图时，当前的控制器会被AngularJS清除掉。服务提供了一种能在应用的整个生命周期内保持数据的方法，它能够在控制器之间进行通信，并且能保证数据的一致性。服务是一个单例对象，在每个应用中只会被实例化一次（被$injector实例化），并且是延迟加载的（需要时才会被创建）。服务提供了把与特定功能相关联的方法集中在一起的接口。以AngularJS的$http服务为例，它提供了对浏览器的XMLHttpRequest对象的底层访问功能，我们可以通过$http的API同XMLHttpRequest进行交互，而不需要因为调用这些底层代码而污染应用。123456789101112// 示例服务，在应用的整个生命周期内保存current_userangular.module('myApp', []).factory('UserService', function($http) &#123; var current_user; return &#123; getCurrentUser: function() &#123; return current_user; &#125;, setCurrentUser: function(user) &#123; current_user = user; &#125; &#125;;&#125;); AngularJS提供了一些内置服务，在任何地方使用它们的方式都是统一的。同时，为复杂应用创建我们自己的服务也是非常有用的。在AngularJS中创建自己的服务是非常容易的：只需要注册这个服务即可。服务被注册后，AngularJS编译器就可以引用它，并且在运行时把它当作依赖加载进来。服务名称的注册表使得在测试中伪造和剔除相互隔离的应用依赖变得非常容易。 注册一个服务用$injector来创建和注册服务有好几种方式，使用angular.module的factory API创建服务，是最常见也是最灵活的方式：12345angular.module('myApp.services', []).factory('githubService', function() &#123; var serviceInstance = &#123;&#125;; // 我们的第一个服务 return serviceInstance;&#125;); 尽管githubService没做什么有趣的事情，但现在它已经用githubService作为名字注册成为这个AngularJS应用的一个服务了。服务的工厂函数用来生成一个单例的对象或函数，这个对象或函数就是服务，它会存在于应用的整个生命周期内。当我们的AngularJS应用加载服务时，这个函数会被执行并返回一个单例的服务对象。同创建控制器的方法一样，服务的工厂函数既可以是一个函数也可以是一个数组：123// 用方括号声明工厂angular.module('myApp.services', []).factory('githubService', [function($http) &#123; &#125;]); 例如， githubService需要访问$http服务，所以我们将$http服务当作AngularJS应用的一个依赖，并将它注入到工厂函数中。12345angular.module('myApp.services', []).factory('githubService', function($http) &#123; // 我们的serviceInstance现在可以在函数定义中访问$http服务 var serviceInstance = &#123;&#125;; return serviceInstance;&#125;); 现在，无论何处需要访问GitHub API都不需要通过$http来进行了，可以通过githubService来代替，并让它处理所有复杂的业务逻辑和远程服务。GitHub API提供了一个读取用户活动流的方法（活动流就是用户记录在GitHub中的最近的事件列表）。在我们的服务中，可以创建一个访问这个API的方法，并将API的请求结果返回。通过将方法设置为服务对象的一个属性来将其暴露给外部。123456789101112131415161718angular.module('myApp.services', []).factory('githubService', function($http) &#123; var githubUrl = 'https://api.github.com'; var runUserRequest = function(username, path) &#123; // 从使用JSONP调用Github API的$http服务中返回promise return $http(&#123; method: 'JSONP', url: githubUrl + '/users/' + username + '/' + path + '?callback=JSON_CALLBACK' &#125;); &#125;; // 返回带有一个events函数的服务对象 return &#123; events: function(username) &#123; return runUserRequest(username, 'events'); &#125; &#125;;&#125;); githubService中只包含了一个方法，可以在应用的模块中调用。 使用服务可以在控制器、指令、过滤器或另外一个服务中通过依赖声明的方式来使用服务。 AngularJS会像平时一样在运行期自动处理实例化和依赖加载的相关事宜。将服务的名字当作参数传递给控制器函数，可以将服务注入到控制器中。当服务成为了某个控制器的依赖，就可以在控制器中调用任何定义在这个服务对象上的方法。1234angular.module('myApp', ['myApp.services']).controller('ServiceController', function($scope, githubService) &#123; // 我们可以调用对象的事件函数 $scope.events = githubService.events('auser');&#125;); 创建服务时的设置项在AngularJS应用中， factory()方法是用来注册服务的最常规方式，同时还有其他一些API可以在特定情况下帮助我们减少代码量。共有5种方法用来创建服务： factory() 如前所见，factory()方法是创建和配置服务的最快捷方式,factory()函数可以接受两个参数。 name（字符串）需要注册的服务名。getFn（函数）这个函数会在AngularJS创建服务实例时被调用。 12345angular.module('myApp').factory('myService', function() &#123; return &#123; 'username': 'auser' &#125;;&#125;); 因为服务是单例对象， getFn在应用的生命周期内只会被调用一次。同其他AngularJS的服务一样，在定义服务时， getFn可以接受一个包含可被注入对象的数组或函数。getFn函数可以返回简单类型、函数乃至对象等任意类型的数据（同value()函数类似）。 1234567angular.module('myApp').factory('githubService', ['$http', function($http) &#123; return &#123; getUserEvents: function(username) &#123; // ... &#125; &#125;;&#125;]); service() 使用service()可以注册一个支持构造函数的服务，它允许我们为服务对象注册一个构造函数。service()方法接受两个参数。 name（字符串）要注册的服务名称。constructor（函数）构造函数，我们调用它来实例化服务对象。 service()函数会在创建实例时通过new关键字来实例化服务对象。123456var Person = function($http) &#123; this.getName = function() &#123; return $http(&#123; method: 'GET', url: '/api/user'&#125;); &#125;;&#125;;angular.service('personService', Person); provider() 所有服务工厂都是由$provide服务创建的， $provide服务负责在运行时初始化这些提供者。提供者是一个具有$get()方法的对象， $injector通过调用$get方法创建服务实例。$provider提供了数个不同的API用于创建服务，每个方法都有各自的特殊用途。所有创建服务的方法都构建在provider()方法之上。 provider()方法负责在$providerCache中注册服务。从技术上说，当我们假定传入的函数就是$get()时， factory()函数就是用provider()方法注册服务的简略形式。下面两种方法的作用完全一样，并且会创建同一个服务。1234567891011121314angular.module('myApp').factory('myService', function() &#123; return &#123; 'username': 'auser' &#125;;&#125;)// 这与上面工厂的用法等价.provider('myService', &#123; $get: function() &#123; return &#123; 'username': 'auser' &#125;; &#125;&#125;); 是否可以一直使用.factory()方法来代替.provider()呢？答案取决于是否需要用AngularJS的.config()函数来对.provider()方法返回的服务进行额外的扩展配置。同其他创建服务的方法不同， config()方法可以被注入特殊的参数。比如我们希望在应用启动前配置githubService的URL：1234567891011121314// 使用`.provider`注册该服务angular.module('myApp', []).provider('githubService', function($http) &#123; // 默认的，私有状态 var githubUrl = 'https://github.com', setGithubUrl: function(url) &#123; // 通过.config改变默认属性 if (url) &#123; githubUrl = url &#125; &#125;， method: JSONP, // 如果需要，可以重写 $get: function($http) &#123; self = this; return $http(&#123; method: self.method, url: githubUrl + '/events'&#125;); &#125;&#125;); 如果希望在config()函数中可以对服务进行配置，必须用provider()来定义服务。provider()方法为服务注册提供者。可以接受两个参数。 name（字符串）name参数在providerCache中是注册的名字。name+Provider会成为服务的提供者。同时name也是服务实例的名字。例如，如果定义了一个githubService，那它的提供者就是githubServiceProvider。aProvider（对象/函数/数组）aProvider可以是多种形式。如果aProvider是函数，那么它会通过依赖注入被调用，并且负责通过$get方法返回一个对象。如果aProvider是数组，会被当做一个带有行内依赖注入声明的函数来处理。数组的最后一个元素应该是函数，可以返回一个带有$get方法的对象。如果aProvider是对象，它应该带有$get方法。 provider()函数返回一个已经注册的提供者实例。直接使用provider() API是最原始的创建服务的方法：12345678910111213141516// 在模块对象上直接创建provider的例子angular.module('myApp', []).provider('UserService', &#123; favoriteColor: null, setFavoriteColor: function(newColor) &#123; this.favoriteColor = newColor; &#125;, // $get函数可以接受injectables $get: function($http) &#123; return &#123; 'name': 'Ari', getFavoriteColor: function() &#123; return this.favoriteColor || 'unknown'; &#125; &#125;; &#125;&#125;); 用这个方法创建服务，必须返回一个定义有$get()函数的对象，否则会导致错误。 constant() 可以将一个已经存在的变量值注册为服务，并将其注入到应用的其他部分当中。例如，假设我们需要给后端服务一个apiKey，可以用constant()将其当作常量保存下来。constant()函数可以接受两个参数。 name（字符串）需要注册的常量的名字。value（常量）需要注册的常量的值（值或者对象）。 constant()方法返回一个注册后的服务实例。1angular.module('myApp') .constant('apiKey','123123123') 这个常量服务可以像其他服务一样被注入到配置函数中：12345angular.module('myApp').controller('MyController', function($scope, apiKey) &#123; // 可以像上面一样用apiKey作为常量 // 用123123123作为字符串的值 $scope.apiKey = apiKey;&#125;); value() 如果服务的$get方法返回的是一个常量，那就没要必要定义一个包含复杂功能的完整服务，可以通过value()函数方便地注册服务。value()方法可以接受两个参数。 name（字符串）同样是需要注册的服务名。value（值）将这个值将作为可以注入的实例返回。 value()方法返回以name参数的值为名称的注册后的服务实例。1angular.module('myApp').value('apiKey','123123123'); 何时使用value()和constant() value()方法和constant()方法之间最主要的区别是， 常量可以注入到配置函数中，而值不行。通常情况下，可以通过value()来注册服务对象或函数，用constant()来配置数据。1234567891011angular.module('myApp', []).constant('apiKey', '123123123').config(function(apiKey) &#123;// 在这里apiKey将被赋值为123123123// 就像上面设置的那样&#125;).value('FBid','231231231').config(function(FBid) &#123;// 这将抛出一个错误，未知的provider: FBid// 因为在config函数内部无法访问这个值&#125;); decorator() $provide服务提供了在服务实例创建时对其进行拦截的功能，可以对服务进行扩展，或者用另外的内容完全代替它。装饰器是非常强大的，它不仅可以应用在我们自己的服务上，也可以对AngularJS的核心服务进行拦截、中断甚至替换功能的操作。事实上AngularJS中很多功能的测试就是借助$provide.decorator()建立的。对服务进行装饰的场景有很多，比如对服务进行扩展，将外部数据缓存进localStorage的功能，或者对服务进行封装以便在开发中进行调试和跟踪等。例如，我们想给之前定义的githubService服务加入日志功能，可以借助decorator()函数方便地实现这个功能，而不需要对原始的服务进行修改。decorator()函数可以接受两个参数。 name（字符串）将要拦截的服务名称。decoratorFn（函数）在服务实例化时调用该函数，这个函数由injector.invoke调用，可以将服务注入这个函数中。 $delegate是可以进行装饰的最原始的服务，为了装饰其他服务，需要将其注入进装饰器。例如，下面的代码展示了如何给githubService添加装饰器，从而为每个请求都加上一个时间戳：12345678910111213141516var githubDecorator = function($delegate,$log) &#123; var events = function(path) &#123; var startedAt = new Date(); var events = $delegate.events(path); // 事件是一个promise events.finally(function() &#123; $log.info(\"Fetching events\" +\" took \" +(new Date() - startedAt) + \"ms\"); &#125;); return events; &#125;; return &#123; events: events &#125;;&#125;;angular.module('myApp').config(function($provide) &#123; $provide.decorator('githubService',githubDecorator);&#125;);","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"angularjs","slug":"angularjs","permalink":"http://yoursite.com/tags/angularjs/"}]},{"title":"Angularjs学习(8)之依赖注入","date":"2015-08-28T16:00:00.000Z","path":"2015/08/29/angularJS-learning-8/","text":"一个对象通常有三种方式可以获得对其依赖的控制权：(1) 在内部创建依赖；(2) 通过全局变量进行引用；(3) 在需要的地方通过参数进行传递。依赖注入是通过第三种方式实现的。其余两种方式会带来各种问题，例如污染全局作用域，使隔离变得异常困难等。依赖注入是一种设计模式，它可以去除对依赖关系的硬编码，从而可以在运行时改变甚至移除依赖关系。在运行时修改依赖关系的能力对测试来讲是非常理想的，因为它允许我们创建一个隔离的环境，从而在测试环境可以使用模拟的对象取代生产环境中的真实对象。从功能上看，依赖注入会事先自动查找依赖关系，并将注入目标告知被依赖的资源，这样就可以在目标需要时立即将资源注入进去。在编写依赖于其他对象或库的组件时，我们需要描述组件之间的依赖关系。在运行期，注入器会创建依赖的实例，并负责将它传递给依赖的消费者。12345678// 出自Angular文档的优秀示例function SomeClass(greeter) &#123; this.greeter = greeter;&#125;SomeClass.prototype.greetName = function(name) &#123; this.greeter.greet(name);&#125;;//注意，示例代码在全局作用域上创建了一个控制器，这并不是一个好主意，这里只是为了方便演示。 SomeClass能够在运行时访问到内部的greeter，但它并不关心如何获得对greeter的引用。为了获得对greeter实例的引用， SomeClass的创建者会负责构造其依赖关系并传递进去。基于以上原因， AngularJS使用$injetor（注入器服务）来管理依赖关系的查询和实例化。事实上， $injetor负责实例化AngularJS中所有的组件，包括应用的模块、指令和控制器等。在运行时， 任何模块启动时$injetor都会负责实例化，并将其需要的所有依赖传递进去。例如下面这段代码。这是一个简单的应用，声明了一个模块和一个控制器：1234567891011angular.module('myApp', []).factory('greeter', function() &#123; return &#123; greet: function(msg) &#123;alert(msg);&#125; &#125;&#125;).controller('MyController',function($scope, greeter) &#123; $scope.sayHello = function() &#123; greeter.greet(\"Hello!\"); &#125;;&#125;); 当AngularJS实例化这个模块时，会查找greeter并自然而然地把对它的引用传递进去：12345&lt;div ng-app=\"myApp\"&gt; &lt;div ng-controller=\"MyController\"&gt; &lt;button ng-click=\"sayHello()\"&gt;Hello&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 而在内部， AngularJS的处理过程是下面这样的：123456// 使用注入器加载应用var injector = angular.injector(['ng', 'myApp']);// 通过注入器加载$controller服务： var $controller = injector.get('$controller');var scope = injector.get('$rootScope').$new();// 加载控制器并传入一个作用域，同AngularJS在运行时做的一样var MyController = $controller('MyController', &#123;$scope: scope&#125;) 在任何一个AngularJS的应用中，都有$injector在进行工作，无论我们知道与否。当编写控制器时，如果没有使用[]标记或进行显式的声明， $injector就会尝试通过参数名推断依赖关系。 推断式注入声明 如果没有明确的声明， AngularJS会假定参数名称就是依赖的名称。因此，它会在内部调用函数对象的toString()方法，分析并提取出函数参数列表，然后通过$injector将这些参数注入进对象实例。注入的过程如下：1injector.invoke(function($http, greeter) &#123;&#125;); 请注意，这个过程只适用于未经过压缩和混淆的代码，因为AngularJS需要原始未经压缩的参数列表来进行解析。有了这个根据参数名称进行推断的过程，参数顺序就没有什么重要的意义了， 因为AngularJS会帮助我们把属性以正确的顺序注入进去。 JavaScript的压缩器通常会将参数名改写成简单的字符，以减小源文件体积（同时也会删除空格、空行和注释等）。如果我们不明确地描述依赖关系，AngularJS将无法根据参数名称推断出实际的依赖关系，也就无法进行依赖注入。 显式注入声明 AngularJS提供了显式的方法来明确定义一个函数在被调用时需要用到的依赖关系。通过这种方法声明依赖，即使在源代码被压缩、参数名称发生改变的情况下依然能够正常工作。可以通过$inject属性来实现显式注入声明的功能。函数对象的$inject属性是一个数组，数组元素的类型是字符串，它们的值就是需要被注入的服务的名称。下面是示例代码：123456789101112131415161718var aControllerFactory =function aController($scope, greeter) &#123; console.log(\"LOADED controller\", greeter); // ……控制器&#125;;aControllerFactory.$inject = ['$scope', 'greeter']; // Greeter服务 console.log(\"greeter service\");&#125;// 我们应用的控制器angular.module('myApp', []).controller('MyController', aControllerFactory).factory('greeter', greeterService);// 获取注入器并创建一个新的作用域var injector = angular.injector(['ng', 'myApp']),controller = injector.get('$controller'),rootScope = injector.get('$rootScope'),newScope = rootScope.$new();// 调用控制器controller('MyController', &#123;$scope: newScope&#125;); 对于这种声明方式来讲，参数顺序是非常重要的，因为$inject数组元素的顺序必须和注入参数的顺序一一对应。这种声明方式可以在压缩后的代码中运行，因为声明的相关信息已经和函数本身绑定在一起了。 行内注入声明 AngularJS提供的注入声明的最后一种方式，是可以随时使用的行内注入声明。这种方式其实是一个语法糖，它同前面提到的通过$inject属性进行注入声明的原理是完全一样的，但允许我们在函数定义时从行内将参数传入。此外，它可以避免在定义过程中使用临时变量。在定义一个AngularJS的对象时，行内声明的方式允许我们直接传入一个参数数组而不是一个函数。数组的元素是字符串，它们代表的是可以被注入到对象中的依赖的名字，最后一个参数就是依赖注入的目标函数对象本身。示例如下：12angular.module('myApp').controller('MyController', ['$scope', 'greeter', function($scope, greeter) &#123;&#125;]); 由于需要处理的是一个字符串组成的列表，行内注入声明也可以在压缩后的代码中正常运行。通常通过括号和声明数组的[]符号来使用它。 $injector API annotate() annotate()方法的返回值是一个由服务名称组成的数组，这些服务会在实例化时被注入到目标函数中。 annotate()方法可以帮助$injector判断哪些服务会在函数被调用时注入进去。 annotate()方法可以接受一个参数： fn（函数或数组）参数fn可以是一个函数，也可以是一个数组。 annotate()方法返回一个数组，数组元素的值是在调用时被注入到目标函数中的服务的名称。 get() get()方法返回一个服务的实例 get()方法可以接受一个参数,get()根据名称返回服务的一个实例。 name（字符串）参数name是想要获取的实例的名称。 has() has()方法返回一个布尔值，在$injector能够从自己的注册列表中找到对应的服务时返回true，否则返回false。 has()方法能接受一个参数： name（字符串）参数name是我们想在注入器的注册列表中查询的服务名称。 instantiate() instantiate()方法可以创建某个JavaScript类型的实例。它会通过new操作符调用构造函数，并将所有参数都传递给构造函数。 instantiate()方法可以接受两个参数,instantiate()方法返回Type的一个新实例。 Type（函数）构造函数。locals（对象，可选）这是一个可选的参数，提供了另一种传递参数的方式。 invoke() invoke()方法会调用方法并从$injector中添加方法参数。 invoke()方法接受三个参数,invoke()方法返回fn函数返回的值。 fn(function)这个函数就是要调用的函数。这个函数的参数由函数声明设置。self (object-可选)self参数允许我们设置调用方法的this参数。locals (object-可选)这个可选参数提供另一种方式在函数被调用时传递参数名给该函数。 ngMin 上面介绍了三种声明依赖注入的方式，可以在定义函数时选择任意一种合适的方式。但在实际生产过程中，当代码体积变得非常庞大时，写代码还要关心参数顺序将是一个耗费心力的工作。通过使用ngMin这个工具，能够减少我们定义依赖关系所需的工作量。 ngMin是一个为AngularJS应用设计的预压缩工具，它会遍历整个AngularJS应用并帮助我们设置好依赖注入。例如，它会将如下代码：123angular.module('myApp', []).directive('myDirective', function($http) &#123; &#125;).controller('IndexController', function($scope, $q) &#123;&#125;); 转换成下面的形式：123angular.module('myApp', []).directive('myDirective', ['$http', function ($http) &#123; &#125;]).controller('IndexController', [ '$scope', '$q',function ($scope, $q) &#123;&#125; ]); ngMin可以显著减少代码输入的工作量，并保持源文件的整洁。 安装 可以通过npm包管理工具来安装ngMin：1$ npm install -g ngmin 使用ngMin 我们可以在命令行界面单独使用ngMin，可以通过标准输入输出设备或标准输出流传入input.js和output.js两个参数，例如：123$ ngmin input.js output.js#或者$ ngmin &lt; input.js &gt; output.js input.js是源文件，而 output.js则是转换过注入声明后的输出文件。 工作原理 在其内部， ngMin使用抽象语法树（Abstract Syntax Tree， AST）来遍历JavaScript源代码。借助名为astral的AST工具框架的帮助，它可以将必要的声明代码添加进源文件，并用escodegen将转换后的源文件输出。ngMin希望我们的AngularJS源代码只由逻辑定义组成。如果我们书写代码的语法和这本书里的一样，那么ngMin就可以对其进行解析和预压缩。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"angularjs","slug":"angularjs","permalink":"http://yoursite.com/tags/angularjs/"}]},{"title":"Angularjs学习(7)之多重视图和路由","date":"2015-08-21T16:00:00.000Z","path":"2015/08/22/angularJS-learning-7/","text":"能够从页面的一个视图跳转到另外一个视图，对单页面应用来讲是至关重要的。当应用变得越来越复杂时，我们需要一个合理的方式来管理用户在使用过程中看到的界面。除了用ng-include指令在视图中引用多个模板外，更好的做法是将视图分解成布局和模板视图，并且根据用户当前访问的URL来展示对应的视图。我们会将这些模板分解到视图中，并在布局模板内进行组装。 AngularJS允许我们在$route服务的提供者$routeProvider中通过声明路由来实现这个功能。通过$routeProvider，可以发挥出浏览器历史导航的优势，并让用户基于浏览器当前的URL地址创建书签或分享页面。 安装从1.2版本开始， AngularJS将ngRoutes从核心代码中剥离出来成为独立的模块。我们需要安装并引用它，才能够在AngularJS应用中正常地使用路由功能。可以从code.angularjs.org下载它，然后保存到一个可以在HTML页面中进行引用的位置，例如js/vendor/angular-route.js。也可以用Bower来安装，这样会将它存放到Bower的目录中。1$bower install--save angular -route 在HTML中，需要在AngularJS之后引用angular-route： 12&lt;script src=\"js/vendor/angular.js\"&gt;&lt;/script&gt;&lt;script src=\"js/vendor/angular-route.js\"&gt;&lt;/script&gt; 最后，要把ngRoute模块在我们的应用中当作依赖加载进来： 1angular.module('myApp', ['ngRoute']); 布局模板要创建一个布局模板，需要修改HTML以告诉AngularJS把模板渲染到何处。通过将ng-view指令和路由组合到一起，我们可以精确地指定当前路由所对应的模板在DOM中的渲染位置： 123456789&lt;header&gt; &lt;h1&gt;Header&lt;/h1&gt;&lt;/header&gt;&lt;div class=\"content\"&gt; &lt;div ng-view&gt;&lt;/div&gt;&lt;/div&gt;&lt;footer&gt; &lt;h5&gt;Footer&lt;/h5&gt;&lt;/footer&gt; ng-view是由ngRoute模块提供的一个特殊指令，它的独特作用是在HTML中给$route对应的图内容占位。它会创建自己的作用域并将模板嵌套在内部。ngView指令遵循以下规则: 每次触发$routeChangeSuccess事件，视图都会更新。 如果某个模板同当前的路由相关联： 创建一个新的作用域 移除上一个视图，同时上一个作用域也会被清除 将新的作用域同当前模板关联在一起 如果路由中有相关的定义，那么就把对应的控制器同当前作用域关联起来 触发$viewContentLoaded事件 如果提供了onload属性，调用该属性所指定的函数 路由我们可以使用AngularJS提供的when和otherwise两个方法来定义应用的路由。用config函数在特定的模块或应用中定义路由：123angular.module('myApp', []).config(['$routeProvider', function($routeProvider) &#123;// 在这里定义路由&#125;]); 现在，我们可以用when方法来添加一个特定的路由。这个方法可以接受两个参数（when(path,route)）：123456angular.module('myApp', []).config(['$routeProvider', function($routeProvider) &#123; $routeProvider.when('/', &#123; templateUrl: 'views/home.html', controller: 'HomeController' &#125;);&#125;]); 第一个参数是路由路径，这个路径会与$location.path进行匹配， $location.path也就是当前URL的路径。如果路径后面还有其他内容，或使用了双斜线也可以正常匹配。我们可以在URL中存储参数，参数需要以冒号开头（例如:name），后面会讨论如何用$routeParams读取这些参数。第二个参数是配置对象，决定了当第一个参数中的路由能够匹配时具体做些什么。配置对象中可以进行设置的属性包括controller、 template、 templateURL、 resolve、 redirectTo和reloadOnSearch。 controller controller: MyController或者controller: function($scope) {} 如果配置对象中设置了controller属性，那么这个指定的控制器会与路由所创建的新作用域关联在一起。如果参数值是字符型，会在模块中所有注册过的控制器中查找对应的内容，然后与路由关联在一起。如果参数值是函数型，这个函数会作为模板中DOM元素的控制器并与模板进行关联。 template template: &lt;div&gt;&lt;h2&gt;Route&lt;/h2&gt;&lt;/div&gt; AngularJS会将配置对象中的HTML模板渲染到对应的具有ng-view指令的DOM元素中。 templateUrl templateUrl: views/template_name.html 应用会根据templateUrl属性所指定的路径通过XHR读取视图（或者从$templateCache中读取）。如果能够找到并读取这个模板， AngularJS会将模板的内容渲染到具有ng-view指令的DOM元素中。 resolve 12345678resolve: &#123;'data': ['$http', function($http) &#123; return $http.get('/api').then( function success(resp) &#123; return response.data; &#125;, function error(reason) &#123; return false; &#125; );&#125;];&#125; 如果设置了resolve属性， AngularJS会将列表中的元素都注入到控制器中。如果这些依赖是promise对象，它们在控制器加载以及$routeChangeSuccess被触发之前，会被resolve并设置成一个值。列表对象可以是：键，键值是会被注入到控制器中的依赖的名字;工厂，即可以是一个服务的名字，也可以是一个返回值，它是会被注入到控制器中的函数或可以被resolve的promise对象。 redirectTo redirectTo: /home或者redirectTo: function(route,path,search) 如果redirectTo属性的值是一个字符串，那么路径会被替换成这个值，并根据这个目标路径触发路由变化。如果redirectTo属性的值是一个函数，那么路径会被替换成函数的返回值，并根据这个目标路径触发路由变化,AngularJS会在调用它时传入下面三个参数中：(1) 从当前路径中提取出的路由参数；(2) 当前路径；(3) 当前URL中的查询串。 reloadOnSearch 如果reloadOnSearch选项被设置为true（默认），当$location.search()发生变化时会重新加载路由。如果设置为false，那么当URL中的查询串部分发生变化时就不会重新加载路由。这个小窍门对路由嵌套和原地分页等需求非常有用。下面的例子中设置了两个路由：一个首页路由和一个收件箱路由，同时首页路由被设置成默认路由。 123456789101112angular.module('MyApp', []).config(['$routeProvider', function($routeProvider) &#123;$routeProvider.when('/', &#123; controller: 'HomeController', templateUrl: 'views/home.html'&#125;).when('/inbox/:name', &#123; controller: 'InboxController', templateUrl: 'views/inbox.html'&#125;).otherwise(&#123;redirectTo: '/'&#125;);&#125;]); $location 服务AngularJS提供了一个服务用以解析地址栏中的URL，并让你可以访问应用当前路径所对应的路由。它同样提供了修改路径和处理各种形式导航的能力。location服务对JavaScript中的window.location对象的API进行了更优雅地封装，并且和AngularJS集成在一起。当应用需要在内部进行跳转时是使用location服务的最佳场景，比如当用户注册后、修改或者登录后进行的跳转。location服务没有刷新整个页面的能力。如果需要刷新整个页面，需要使用$window.location对象（window.location的一个接口）。 path() path()用来获取页面当前的路径：1$location.path(); // 返回当前路径 修改当前路径并跳转到应用中的另一个URL：1$location.path('/'); // 把路径修改为'/'路由 path()方法直接和HTML5的历史API进行交互，所以用户可通过点击后退按钮退回到上一个页面。 replace() 如果你希望跳转后用户不能点击后退按钮（对于登录之后的跳转这种发生在某个跳转之后的再次跳转很有用）， AngularJS提供了replace()方法来实现这个功能：1234$location.path('/home');$location.replace();// 或者$location.path('/home').replace(); absUrl() absUrl()方法用来获取编码后的完整URL：1$location.absUrl() hash() hash()方法用来获取URL中的hash片段：1$location.hash(); // 返回当前的hash片段 host() host()方法用来获取URL中的主机：1$location.host();// 当前URL的主机 port() port()方法用来获取URL中的端口号：1$location.port();// 当前URL的端口 protocol() protocol()方法用来获取URL中的协议：1$location.protocol();// 当前URL的协议 search() search()方法用来获取URL中的查询串：1$location.search(); 我们可以向这个方法中传入新的查询参数，来修改URL中的查询串部分：1234// 用对象设置查询$location.search(&#123;name: 'Ari', username: 'auser'&#125;);// 用字符串设置查询$location.search('name=Ari&amp;username=auser'); url() url()方法用来获取当前页面的URL：1$location.url(); // 该URL的字符串 如果调用url()方法时传了参数，会设置并修改当前的URL，这会同时修改URL中的路径、查询串和hash，并返回$location。12// 设置新的URL$location.url('/home?name=Ari#hashthing'); 路由模式不同的路由模式在浏览器的地址栏中会以不同的URL格式呈现。 $location服务默认会使用标签模式来进行路由。路由模式决定你的站点的URL长成什么样子。 标签模式标签（hashbang）是AngularJS用来同你的应用内部进行链接的技巧。标签模式是HTML5模式的降级方案， URL路径会以#符号开头。标签模式不需要重写&lt;a href=&quot;&quot;&gt;&lt;/a&gt;标签，也不需要任何服务器端的支持。如果没有进行额外的指定， AngularJS将默认使用标签模式。使用标签模式的URL看起来是这样的：1http://yoursite.com/#!/inbox/all 如果要显式指定配置并使用标签模式，需要在应用模块的config函数中进行配置：123angular.module('myApp', ['ngRoute']).config(['$locationProvider', function($locationProvider) &#123; $locationProvider.html5Mode(false);&#125;]); 我们还可以配置hashPrefix，也就是标签模式下标签默认的前缀!符号。这个前缀也是AngularJS在比较老的浏览器中降级机制的一部分。这个符号是可以配置的：1234angular.module('myApp', ['ngRoute']).config(['$locationProvider', function($locationProvider) &#123; $locationProvider.html5Mode(false); $locationProvider.hashPrefix('!');&#125;]); HTML5 模式 AngularJS支持的另外一种路由模式是html5模式。在这个模式中， URL看起来和普通的URL一样（在老式浏览器中看起来还是使用标签的URL）。例如，同样的路由在HTML5模式中看起来是这样的：1http://yoursite.com/inbox/all 在AngularJS内部， location服务通过HTML5历史API让应用能够使用普通的URL路径来路由。当浏览器不支持HTML5历史API时， location服务会自动使用标签模式的URL作为替代方案。location服务还有一个有趣的功能，当一个支持HTML5历史API的现代浏览器加载了一个带标签的URL时，它会为用户重写这个URL。在HTML5模式中， AngularJS会负责重写&lt;a href=&quot;&quot;&gt;&lt;/a&gt;中的链接。也就是说AngularJS会根据浏览器的能力在编译时决定是否要重写href=&quot;&quot;中的链接。例如&lt;a href=&quot;/person/42?all=true&quot;&gt;Person&lt;/a&gt;这个标签，在老式浏览器中会被重写成标签模式的URL： /index.html#!/person/42?all=true。但在现代浏览器中会URL会保持本来的样子。后端服务器也需要支持URL重写，服务器需要确保所有请求都返回index.html，以支持HTML5模式。这样才能确保由AngularJS应用来处理路由。当在HTML5模式的AngularJS中写链接时，永远都不要使用相对路径。如果你的应用是在根路径中加载的，这不会有什么问题，但如果是在其他路径中， AngularJS应用就无法正确处理路由了。另一个选择是在HTML文档的HEAD中用标签来指定应用的基础URL：1&lt;base href=\"/base/url\" /&gt; 路由事件route服务在路由过程中的每个阶段都会触发不同的事件，可以为这些不同的路由事件设置监听器并做出响应。这个功能对于控制不同的路由事件，以及探测用户的登录和授权状态等场景是非常有用的。我们需要给路由设置事件监听器，用rootScope来监听这些事件。 $routeChangeStart AngularJS在路由变化之前会广播routeChangeStart事件。在这一步中，路由服务会开始加载路由变化所需要的所有依赖，并且模板和resolve键中的promise也会被resolve。1234angular.module('myApp', []).run(['$rootScope', '$location', function($rootScope, $location) &#123; $rootScope.$on('$routeChangeStart', function(evt, next, current) &#123; &#125;);&#125;]); $routeChangeStart事件带有两个参数： 将要导航到的下一个URL； 路由变化前的URL。 $routeChangeSuccess AngularJS会在路由的依赖被加载后广播$routeChangeSuccess事件。1234angular.module('myApp', []).run(['$rootScope', '$location', function($rootScope, $location) &#123; $rootScope.$on('$routeChangeSuccess', function(evt, next, previous) &#123; &#125;);&#125;]); $routeChangeStart事件带有三个参数： 原始的AngularJS evt对象 用户当前所处的路由 上一个路由（如果当前是第一个路由，则为undefined） $routeChangeError AngularJS会在任何一个promise被拒绝或者失败时广播$routeChangeError事件。1234angular.module('myApp', []).run(function($rootScope, $location) &#123; $rootScope.$on('$routeChangeError', function(current, previous, rejection) &#123; &#125;);&#125;); $routeChangeError事件有三个参数： 当前路由的信息 上一个路由的信息 被拒绝的promise的错误信息 $routeUpdate AngularJS在reloadOnSearch属性被设置为false的情况下，重新使用某个控制器的实例时，会广播routeUpdate事件。 关于搜索引擎索引 Web爬虫对于JavaScript的胖客户端应用无能为力。为了在应用的运行过程中给爬虫提供支持，我们需要在头部添加meta标签。这个元标记会让爬虫请求一个带有空的转义片段参数的链接，服务器根据请求返回对应的HTML代码片段。1&lt;meta name=\"fragment\" content=\"!\"/&gt; 更多关于路由的内容 页面重新加载 location服务不会重新加载整个页面，它只会单纯地改变URL。如果我们想重新加载整个页面，需要用window服务来设置地址。1$window.location.href = \"/reload/page\"; 异步的地址变化 如果我们想要在作用域的生命周期外使用location服务，必须用apply函数将变化抛到应用外部。因为location服务是基于digest来驱动浏览器的地址变化，以使路由事件正常工作的。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"angularjs","slug":"angularjs","permalink":"http://yoursite.com/tags/angularjs/"}]},{"title":"Angularjs学习(6)之模块加载","date":"2015-08-14T16:00:00.000Z","path":"2015/08/15/angularJS-learning-6/","text":"AngularJS模块可以在被加载和执行之前对其自身进行配置。我们可以在应用的加载阶段应用不同的逻辑组。 配置在模块的加载阶段， AngularJS会在提供者注册和配置的过程中对模块进行配置。在整个AngularJS的工作流中，这个阶段是唯一能够在应用启动前进行修改的部分。 123angular.module('myApp', []).config(function($provide) &#123;&#125;); 当对模块进行配置时，需要格外注意只有少数几种类型的对象可以被注入到config()函数中：提供者和常量。如果我们将一个服务注入进去，会在真正对其进行配置之前就意外地把服务例化了。也可以定义多个配置块，它们会按照顺序执行，这样就可以将应用不同阶段的配置代码集中在不同的代码块中,AngularJS会以这些函数书写和注册的顺序来执行它们,也就是说我们无法注入一个尚未注册的提供者。 12345678910angular.module('myApp', []).config(function($routeProvider) &#123; $routeProvider.when('/', &#123; controller: 'WelcomeController', template: 'views/welcome.html' &#125;);&#125;).config(function(ConnectionProvider) &#123; ConnectionProvider.setApiKey('SOME_API_KEY');&#125;); 运行块和配置块不同，运行块在注入器创建之后被执行，它是所有AngularJS应用中第一个被执行的方法。运行块是AngularJS中与main方法最接近的概念。运行块中的代码块通常很难进行单元测试，它是和应用本身高度耦合的。运行块通常用来注册全局的事件监听器。例如，我们会在.run()块中设置路由事件的监听器以及过滤未经授权的请求。假设我们需要在每次路由发生变化时，都执行一个函数来验证用户的权限，放置这个功能唯一合理的地方就是run方法： 123456789101112angular.module('myApp', []).run(function($rootScope, AuthService) &#123; $rootScope.$on('$routeChangeStart', function(evt, next, current) &#123; // 如果用户未登录 if (!AuthService.userLoggedIn()) &#123; if (next.templateUrl === \"login.html\") &#123; // 已经转向登录路由因此无需重定向 &#125; else &#123; $location.path('/login'); &#125; &#125; &#125;);&#125;);","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"angularjs","slug":"angularjs","permalink":"http://yoursite.com/tags/angularjs/"}]},{"title":"Angularjs学习(5)之指令","date":"2015-08-07T16:00:00.000Z","path":"2015/08/08/angularJS-learning-5/","text":"自定义 HTML 元素和属性基于我们对HTML元素的理解，指令本质上就是AngularJS扩展具有自定义功能的HTML元素的途径。接下来让我们来创建一个自定义指令：1&lt;my-directive&gt;&lt;/my-directive&gt; 对应js代码如下123456angular.module('myApp',[]).directive('myDirective', function() &#123; return &#123; restrict: 'E', template: '&lt;a href=\"http://google.com\"&gt;Click me to go to Google&lt;/a&gt;' &#125;;&#125;); 向指令中传递数据这里的话一般都用ng-model进行双向绑定来向指令中传递数据，下面看一个DemoJS Bin on jsbin.com 内置指令AngularJS提供了一系列内置指令。其中一些指令重载了原生的HTML元素，比如form和a标签，当在HTML中使用标签时，并不一定能明确看出是否在使用指令，其他内置指令通常以ng为前缀，很容易识别。下面介绍几个基础ng属性指令。 布尔属性 属性 用法 ng-disabled 当写普通的HTML输入字段时，如果在元素标签上出现了disabled属性就会禁用这个输入字段。通过ng-disabled可以对是否出现属性进行绑定。在线示例： http://jsbin.com/iHiYItu/1/edit ng-readonly 同其他布尔属性一样， HTML定义只会检查readonly属性是否出现，而不是它的实际值 ng-checked 通过ng-checked将某个表达式同是否出现checked属性进行绑定。 ng-selected ng-selected可以对是否出现option标签的selected属性进行绑定, 在线示例： http://jsbin.com/oQazOQE/2/edit 类布尔属性 属性 用法 ng-href 当使用当前作用域中的属性动态创建URL时，应该用ng-href代替href,在线示例： http://jsbin.com/IgInopi/1/edit ng-src AngularJS会告诉浏览器在ng-src对应的表达式生效之前不要加载图像 ,在线示例： http://jsbin.com/egucIqU/1/edit。 浏览在线示例时，通过Chrome开发者工具的网络面板观察资源加载状况，注意，其中一个请求是红色的，说明发生了错误。这个错误是由于Wrong Way中我们用src代替了ng-src导致的。 在指令中使用子作用域 属性 用法 ng-app 任何具有ng-app属性的DOM元素将被标记为rootScope的起始点。rootScope是作用域链的起始点，任何嵌套在ng-app内的指令都会继承它，在线示例： http://jsbin.com/ICOzeFI/2/edit。 实际生产中不建议像使用全局作用域一样使用$rootScope ng-controller 内置指令ng-controller的作用是为嵌套在其中的指令创建一个子作用域，避免将所有操作和模型都定义在rootScope上。用这个指令可以在一个DOM元素上放置控制器，ng-controller接受一个参数expression，这个参数是必需的，expression参数是一个AngularJS表达式。嵌套在ng-controller中的指令有访问新子scope的权限，但是要牢记每个指令都应该遵守的和作用域相关的规则，在线示例： http://jsbin.com/OYikipe/1/edit， http://jsbin.com/UbIRIHa/1/ ng-include 使用ng-include可以加载、编译并包含外部HTML片段到当前的应用中。使用ng-include时AngularJS会自动创建一个子作用域。如果你想使用某个特定的作用域，例如ControllerA的作用域，必须在同一个DOM元素上添加ng-controller =”ControllerA”指令，这样当模板加载完成后，不会像往常一样从外部作用域继承并创建一个新的子作用域 ng-switch 这个指令和ng-switch-when及on=”propertyName”一起使用，可以propertyName发生变化时渲染不同指令到视图中,在线示例： http://jsbin.com/AVihUdi/2/。 ng-view ng-view指令用来设置将被路由管理和放置在HTML中的视图的位置。 ng-if 使用ng-if指令可以完全根据表达式的值在DOM中生成或移除一个元素。如果赋值给ng-if的表达式的值是false，那对应的元素将会从DOM中移除，否则对应元素的一个克隆将被重新插入DOM中。ng-if同no-show和ng-hide指令最本质的区别是，它不是通过CSS显示或隐藏DOM节点，而是真正生成或移除节点。当一个元素被ng-if从DOM中移除，同它关联的作用域也会被销毁。而且当它重新加入DOM中时，会通过原型继承从它的父作用域生成一个新的作用域。 ng-repeat ng-repeat用来遍历一个集合或为集合中的每个元素生成一个模板实例。集合中的每个元素都会被赋予自己的模板和作用域。同时每个模板实例的作用域中都会暴露一些特殊的属性,在线示例： http://jsbin.com/akuYUkey/1/edit。 ng-init ng-init指令用来在指令被调用时设置内部作用域的初始状态, ng-init最常见的使用场景是需要创建小的示例代码的时候,在线示例： http://jsbin.com/OZENuhO/1/。 {{ }} {{ }}语法是AngularJS内置的模板语法，它会在内部scope和视图之间创建绑定。基于这个绑定，只要scope发生变化，视图就会随之自动更新。在屏幕可视的区域内使用{{ }}会导致页面加载时未渲染的元素发生闪烁，用ng-bind可以避免这个问题,在线示例： http://jsbin.com/ODUxeho/1/edit。 ng-bind 尽管可以在视图中使用{{ }}模板语法，我们也可以通过ng-bind指令实现同样的行为,在线示例： http://jsbin.com/esihUJ/1/edit ng-cloak 除使用ng-bind来避免未渲染元素闪烁，还可以在含有{{ }}的元素上使用ng-cloak指令,在线示例： http://jsbin.com/AJEboLO/1/edit。 ng-bind-template 同ng-bind指令类似， ng-bind-template用来在视图中绑定多个表达式。 ng-model ng-model指令用来将input、 select、 text area或自定义表单控件同包含它们的作用域中的属性进行绑定。它可以提供并处理表单验证功能，在元素上设置相关的CSS类（ng-valid、ng-invalid等），并负责在父表单中注册控件。它将当前作用域中运算表达式的值同给定的元素进行绑定。如果属性并不存在，它会隐式创建并将其添加到当前作用域中。我们应该始终用ngModel来绑定scope上一个数据模型内的属性，而不是scope上的属性，这可以避免在作用域或后代作用域中发生属性覆盖 ng-show/ng-hide ng-show和ng-hide根据所给表达式的值来显示或隐藏HTML元素。当赋值给ng-show指令的值为false时元素会被隐藏。类似地，当赋值给ng-hide指令的值为true时元素也会被隐藏。元素的显示或隐藏是通过移除或添加ng-hide这个CSS类来实现的,在线示例： http://jsbin.com/ihOkagE/1/。 ng-change 这个指令会在表单输入发生变化时计算给定表达式的值。因为要处理表单输入，这个指令要和ngModel联合起来使用,在线示例： http://jsbin.com/onUXuxO/1/edit。 ng-form ng-form用来在一个表单内部嵌套另一个表单。普通的form标签不允许嵌套，但ng-form可以。这意味着内部所有的子表单都合法时，外部的表单才会合法。这对于用ng-repeat动态创建表单是非常有用的,在线示例： http://jsbin.com/UduNeCA/1/edit。 ng-click ng-click用来指定一个元素被点击时调用的方法或表达式,在线示例： http://jsbin.com/uGipUBU/2/edit ng-select ng-select用来将数据同HTML的select元素进行绑定。这个指令可以和ng-model以及ng-options指令一同使用，构建精细且表现优良的动态表单。ng-options的值可以是一个内涵表达式（comprehension expression），其实这只是一种有趣的说法，简单来说就是它可以接受一个数组或对象，并对它们进行循环，将内部的内容提供给select标签内部的选项,在线示例： http://jsbin.com/iQelOxi/1/edit。 ng-submit ng-submit用来将表达式同onsubmit事件进行绑定。这个指令同时会阻止默认行为（发送请求并重新加载页面）， 除非表单不含有action属性,在线示例： http://jsbin.com/ONIcAC/1/edit。 ng-class 使用ng-class 动态设置元素的类，方法是绑定一个代表所有需要添加的类的表达式。重复的类不会添加。当表达式发生变化，先前添加的类会被移除，新类会被添加,在线示例： http://jsbin.com/IvEcUci/1/edit。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"angularjs","slug":"angularjs","permalink":"http://yoursite.com/tags/angularjs/"}]},{"title":"Angularjs学习(4)之过滤器","date":"2015-07-31T16:00:00.000Z","path":"2015/08/01/angularJS-learning-4/","text":"过滤器用来格式化需要展示给用户的数据。 AngularJS有很多实用的内置过滤器，同时也提供了方便的途径可以自己创建过滤器。在HTML中的模板绑定符号内通过|符号来调用过滤器，可以用|符号作为分割符来同时使用多个过滤器，我们先来介绍AngularJS提供的内置过滤器。 currencycurrecy过滤器可以将一个数值格式化为货币格式。用{{ 123 | currency }}将123转化成货币格式。currecy过滤器允许我们自己设置货币符号。默认情况下会采用客户端所处区域的货币符号，但是也可以自定义货币符号。 datedate过滤器可以将日期格式化成需要的格式。 AngularJS中内置了几种日期格式，如果没有指定使用任何格式，默认会采用mediumDate格式 filterfilter过滤器可以从给定数组中选择一个子集，并将其生成一个新数组返回。这个过滤器通常用来过滤需要进行展示的元素。 参数 介绍 字符串 返回所有包含这个字符串的元素。如果我们想返回不包含该字符串的元素，在参数前加!符号。 对象 AngularJS会将待过滤对象的属性同这个对象中的同名属性进行比较，如果属性值是字符串就会判断是否包含该字符串。如果我们希望对全部属性都进行对比，可以将$当作键名。 函数 对每个元素都执行这个函数，返回非假值的元素会出现在新的数组中并返回。 true 用angular.equals(expected, actual)对两个值进行严格比较。 false 进行区分大小写的子字符串比较。 jsonjson过滤器可以将一个JSON或JavaScript对象转换成字符串。1234567&#123;&#123; &#123;'name': 'Ari', 'City': 'SanFrancisco'&#125; | json &#125;&#125;&lt;!--&#123;\"name\": \"Ari\",\"City\": \"San Francisco\"&#125;--&gt; limitTolimitTo过滤器会根据传入的参数生成一个新的数组或字符串，新的数组或字符串的长度取决于传入的参数，通过传入参数的正负值来控制从前面还是从后面开始截取。 lowercaselowercase过滤器将字符串转为小写。 numbernumber过滤器将数字格式化成文本。它的第二个参数是可选的，用来控制小数点后截取的位数。 orderByorderBy过滤器可以用表达式对指定的数组进行排序。orderBy可以接受两个参数，第一个是必需的，第二个是可选的。 参数 介绍 字符串 对这个字符串进行解析的结果将决定数组元素的排序方向。我们可以传入+或-来强制进行升序或降序排列。 数组 在排序表达式中使用数组元素作为谓词。对于与表达式结果并不严格相等的每个元素，则使用第一个谓词。 函数 当第一个参数是函数时，该函数会被当作待排序对象的getter方法。 自定义过滤器创建自定义过滤器需要将它放到自己的模块中。下面我们一起来实现一个过滤器，将字符串第一个字母转换为大写。1234567angular.module('myApp.filters', []).filter('capitalize', function() &#123; return function(input) &#123; // input是我们传入的字符串 if (input) &#123; return input[0].toUpperCase() + input.slice(1); &#125;&#125;); 表单验证AngularJS能够将HTML5表单验证功能同它自己的验证指令结合起来使用，并且非常方便。AngularJS提供了很多表单验证指令，我们会介绍其中一些核心的验证功能，然后介绍如何创建自己的验证器。 $parsers 当用户同控制器进行交互，并且ngModelController中的$setViewValue()方法被调用时，$parsers数组中的函数会以流水线的形式被逐个调用。第一个$parse被调用后，执行结果会传递给第二个$parse，以此类推。这些函数可以对输入值进行转换，或者通过$setValidity()函数设置表单的合法性。使用$parsers数组是实现自定义验证的途径之一。例如，假设我们想要确保输入值在某两个数值之间，可以在$parsers数组中入栈一个新的函数，这个函数会在验证链中被调用。每个$parser返回的值都会被传入下一个$parser中。当不希望数据模型发生更新时返回undefined。 1234567891011121314151617181920angular.module('myApp').directive('oneToTen', function() &#123; return &#123; require: '?ngModel', link: function(scope, ele, attrs, ngModel) &#123; if (!ngModel) return; ngModel.$parsers.unshift( function(viewValue) &#123; var i = parseInt(viewValue); if (i &gt;= 0 &amp;&amp; i &lt; 10) &#123; ngModel.$setValidity('oneToTen', true); return viewValue; &#125; else &#123; ngModel.$setValidity('oneToTen', false); return undefined; &#125; &#125;); &#125; &#125;;&#125;); $formatters当绑定的ngModel值发生了变化，并经过$parsers数组中解析器的处理后，这个值会被传递给$formatters流水线。同$parsers数组可以修改表单的合法性状态类似， $formatters中的函数也可以修改并格式化这些值。1234567891011angular.module('myApp').directive('oneToTen', function() &#123; return &#123; require: '?ngModel', link: function(scope, ele, attrs, ngModel) &#123; if (!ngModel) return; ngModel.$formatters.unshift(function(v) &#123; return $filter('number')(v); &#125;); &#125; &#125;;&#125;); 下面我们一起创建一个注册表单。表单中包括用户的名字、邮件地址以及用户名JS Bin on jsbin.com","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"angularjs","slug":"angularjs","permalink":"http://yoursite.com/tags/angularjs/"}]},{"title":"Angularjs学习(3)之控制器和表达式","date":"2015-07-23T16:00:00.000Z","path":"2015/07/24/angularJS-learning-3/","text":"控制器AngularJS中的控制器是一个函数，用来向视图的作用域中添加额外的功能。我们用它来给作用域对象设置初始状态，并添加自定义行为。 当我们在页面上创建一个新的控制器时， AngularJS会生成并传递一个新的scope给这个控制器。可以在这个控制器里初始化$scope。由于AngularJS会负责处理控制器的实例化过程，我们只需编写构造函数即可。下面的例子展示了控制器初始化：123function FirstController($scope) &#123; $scope.message = \"hello\";&#125; 我们是在全局作用域中创建的这个函数。这样做并不合适，因为会污染全局命名空间。更合理的方式是创建一个模块，然后在模块中创建控制器，如下所示：1234var app = angular.module('app', []); app.controller('FirstController', function($scope) &#123; $scope.message = \"hello\";&#125;); 只需创建控制器作用域中的函数，就能创建可以在视图中使用的自定义操作，AngularJS允许我们在视图中像调用普通数据一样调用$scope上的函数。用内置指令ng-click可以将按钮、链接等其他任何DOM元素同点击事件进行绑定。 ng-click指令将浏览器中的mouseup事件，同设置在DOM元素上的事件处理程序绑定在一起（例如，当浏览器在某个DOM元素上触发了点击事件，函数就会被调用）。AngularJS通过作用域将视图、控制器和指令（本书后面会介绍）隔离开来，这样就很容易为功能的具体部分编写测试。 控制器嵌套（作用域包含作用域） AngularJS应用的任何一个部分，无论它渲染在哪个上下文中，都有父级作用域存在。对于ng-app所处的层级来讲，它的父级作用域就是$rootScope。(有一个例外：在指令内部创建的作用域被称作孤立作用域。) 默认情况下，AngularJS在当前作用域中无法找到某个属性时，便会在父级作用域中进行查找。如果AngularJS找不到对应的属性，会顺着父级作用域一直向上寻找，直到抵达$rootScope为止。如果在$rootScope中也找不到，程序会继续运行，但视图无法更新。 下面看一个例子，创建一个ParentController，其中包含一个user对象，再创建一个ChildController来引用这个对象：12345678app.controller('ParentController', function($scope) &#123; $scope.person = &#123;greeted: false&#125;;&#125;);app.controller('ChildController', function($scope) &#123; $scope.sayHello = function() &#123; $scope.person.name = 'Ari Lerner'; &#125;;&#125;); 如果我们将ChildController置于ParentController内部，那ChildController的scope对象的父级作用域就是ParentController的$scope对象。根据原型继承的机制，我们可以在子作用域中访问ParentController的$scope对象。123456&lt;div ng-controller=\"ParentController\"&gt; &lt;div ng-controller=\"ChildController\"&gt; &lt;a ng-click=\"sayHello()\"&gt;Say hello&lt;/a&gt; &lt;/div&gt; &#123;&#123; person &#125;&#125;&lt;/div&gt; See the Pen MwPXNq 表达式表达式和eval(javascript)非常相似，但是由于表达式由AngularJS来处理，它们有以下显著不同的特性： 所有的表达式都在其所属的作用域内部执行，并有访问本地$scope的权限； 如果表达式发生了TypeError和ReferenceError并不会抛出异常； 不允许使用任何流程控制功能（条件控制，例如if/eles）； 可以接受过滤器和过滤器链。 对表达式进行的任何操作，都会在其所属的作用域内部执行，因此可以在表达式内部调用那些限制在此作用域内的变量，并进行循环、函数调用、将变量应用到数学表达式中等操作。 解析 AngularJS 表达式 AngularJS通过$parse这个内部服务来进行表达式的运算，这个服务能够访问当前所处的作用域。这个过程允许我们访问定义在$scope上的原始JavaScript数据和函数。将$parse服务注入到控制器中，然后调用它就可以实现手动解析表达式。举例来说，如果页面上有一个输入框绑定到了expr变量上，如下所示：1234&lt;div ng-controller=\"MyController\"&gt; &lt;input ng-model=\"expr\" type=\"text\" placeholder=\"Enter an expression\" /&gt; &lt;h2&gt;&#123;&#123; parseValue &#125;&#125;&lt;/h2&gt;&lt;/div&gt; 我们可以在MyController中给expr这个表达式设置一个$watch并解析它：12345678910angular.module(\"myApp\", []).controller('MyController',function($scope,$parse) &#123; $scope.$watch('expr', function(newVal, oldVal, scope) &#123; if (newVal !== oldVal) &#123; // 用该表达式设置parseFun var parseFun = $parse(newVal); // 获取经过解析后表达式的值 $scope.parsedValue = parseFun(scope); &#125; &#125;);&#125;); 插值字符串 在AngularJS中，我们的确有手动运行模板编译的能力。例如，插值允许基于作用域上的某个条件实时更新文本字符串。要在字符串模板中做插值操作，需要在你的对象中注入$interpolate服务。在下面的例子中，我们将会将它注入到一个控制器中：123angular.module('myApp', []).controller('MyController',function($scope,$interpolate) &#123;// 我们同时拥有访问$scope和$interpolate服务的权限&#125;); $interpolate服务是一个可以接受三个参数的函数，其中第一个参数是必需的。 text（字符串）：一个包含字符插值标记的字符串。 mustHaveExpression（布尔型）：如果将这个参数设为true，当传入的字符串中不含有表达式时会返回null。 trustedContext（字符串）： AngularJS会对已经进行过字符插值操作的字符串通过$sec.getTrusted()方法进行严格的上下文转义。 $interpolate服务返回一个函数，用来在特定的上下文中运算表达式。设置好这些参数后，就可以在控制器中进行字符插值的操作了。例如，假设我们希望可以在电子邮件的正文中进行实时编辑，当文本发生变化时进行字符插值操作并将结果展示出来。12345&lt;div ng-controller=\"MyController\"&gt; &lt;input ng-model=\"to\" type=\"email\" placeholder=\"Recipient\" /&gt; &lt;textarea ng-model=\"emailBody\"&gt;&lt;/textarea&gt; &lt;pre&gt;&#123;&#123; previewText &#125;&#125;&lt;/pre&gt;&lt;/div&gt;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"angularjs","slug":"angularjs","permalink":"http://yoursite.com/tags/angularjs/"}]},{"title":"Angularjs学习(2)之模块和作用域","date":"2015-07-12T16:00:00.000Z","path":"2015/07/13/angularJS-learning-2/","text":"模块在angularJS中，模块是定义应用的最主要方式。模块包含了主要的应用代码。一个应用可以包含多个模块，每一个模块都包含了定义具体功能的代码。使用模块能带给我们许多好处，例如： 保持全局命名空间的清洁 编写测试代码更容易，并能保持其清洁，以便更容易找到互相隔离的功能 易于在不同的应用间复用代码 使应用能够以任意顺序加载代码的各个部分 angularJS允许我们使用angular.module()方法来声明模块，这个方法能接受两个参数，第一个是模块名称，第二个是依赖列表，也就是可以被注入到模块中的对象列表。使用方法如下：1angular.module('myApp', []); angular.module()的参数列表如下： 参数 类型 介绍 name 字符串 name是模块的名称，字符串变量 requires 字符串 requires包含了一个字符串变量组成的列表，每个元素都是一个模块名称，本模块依赖于这些模块，依赖需要在本模块加载之前由注入器进行预加载 作用域作用域是构成angularJS应用的核心基础，在整个框架中都被广泛应用。应用的作用域是和应用的数据模型相关联的，同时作用域也是表达式执行的上下文。$scope对象是定义应用业务逻辑、控制器方法和视图属性的地方。作用域是视图和控制器之前的胶水。在应用将视图渲染并呈现给用户之前，视图中的模板会和作用域进行连接，然后应用会对DOM进行设置以便将属性的变化通知给angularJS。这个功能让XHR请求等promise对象的实现变得非常容易。将应用的业务逻辑都放在控制器中，而将相关的数据都放在控制的作用域中，这是非常完美的架构。 - 视图和$scope的世界 angularJS启动并生成视图时，会将根ng-app元素同$rootScope进行绑定。$rootScope是所有$scope对象的最上层。$scope对象就是一个普通的javascript对象，我们可以在其上随意修改或添加属性。$scope并不负责处理和操作数据，它只是视图和html之间的桥梁，它是视图和控制器之前的胶水。我们可以在angularJS应用的模板中使用多种标记，包括下面这些： 指令： 将DOM元素增强为可复用的 DOM组件的属性或元素 值绑定： 模板语法可以将表达式绑定到视图上 过滤器： 可以在视图中使用函数，用来进行格式化 表单控件： 用来检验用户输入的控件 - 作用域能做什么作用域有一下功能 提供观察者以监视数据模型的变化 可以将数据模型的变化通知给整个应用，甚至是系统外的组件 可以进行嵌套，隔离业务功能和数据 给表达式提供运算时所需要的执行环境 我们可以创建一个控制器来管理与其相关的变量，而不是将name变量直接放在$rootScope上123angular.module(\"myApp\", []).controller('MyController',function($scope) &#123; $scope.name = \"Ari\";&#125;); - $scope的生命周期 $scope对象的生命周期有四个不同的阶段。 创建。在创建控制器指令时，angularJS会用$injector创建一个新的作用域，并在这个新的控制器或指令运行时将作用域传过去。 链接。当angularJS开始运行时，所有的$scope对象都会附加或者链接到视图中。所有创建$scope对象的函数也会将自身附加到视图中。这些作用域将会注册当angularJS应用上下文中发生变化时需要运行的函数。这些函数被称称为$watch函数， Angular通过这些函数获知何时启动事件循环。 更新。当事件循环运行时，它通常执行在顶层$scope对象上（被称作$rootScope），每个子作用域都执行自己的脏值检测。每个监控函数都会检查变化。如果检测到任意变化， $scope对象就会触发指定的回调函数。 销毁。当一个scope在视图中不再需要时，这个作用域将会清理和销毁自己。尽管永远不会需要清理作用域（因为Angular会为你处理），但是知道是谁创建了这个作用域还是有用的，因为你可以使用这个$scope上叫做$destory()的方法来清理这个作用域。 - 指令和作用域指令在AngularJS中被广泛使用，指令通常不会创建自己的$scope，但也有例外。比如ng-controller和ng-repeat指令会创建自己的子作用域并将它们附加到DOM元素上。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"angularjs","slug":"angularjs","permalink":"http://yoursite.com/tags/angularjs/"}]},{"title":"Angularjs学习(1)之数据绑定","date":"2015-07-09T03:20:17.000Z","path":"2015/07/09/angularJS-learning-1/","text":"AngularJs主要用于构建单页面web应用。它通过增加开发人员和常见web应用开发任务之间的抽象级别，使构建交互式的现代web应用变得更加简单。AngularJs使开发web应用变得非常简单，同时也降低了构建复杂应用的难度。它提供了开发者在现代web应用总经常要用到的一系列高级功能，例如： 解耦应用逻辑，数据模型和视图 ajax服务 依赖注入 浏览历史 测试 双向数据绑定 更多功能 现在我们就先从hello word来看看数据绑定JS Bin on jsbin.com 这里是使用了ng-model指令将内部数据模型对象（$scope）中的name属性绑定到了文本输入的字段上面，这意味着不论在文本输入字段中输入什么，都会同步到数据模型中。DOM元素上的ng-controller，声明所有被它包含的元素都属于某个控制器，下面是一个例子：JS Bin on jsbin.com 由于javascript自身的特点，以及它在传递值和引用时的不同处理方式，通常认为，在视图中通过对象的属性而非对象本身来引用绑定，是angular中的最佳实践。下面就把最佳实践应用到上面时钟的例子中：JS Bin on jsbin.com 这里用了$apply进行了一个绑定操作，以后再具体解释$apply的用法","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"angularjs","slug":"angularjs","permalink":"http://yoursite.com/tags/angularjs/"}]},{"title":"瀑布流布局","date":"2015-07-07T16:00:00.000Z","path":"2015/07/08/pinterest/","text":"瀑布流，又称瀑布流式布局。是比较流行的一种网站页面布局，视觉表现为参差不齐的多栏布局，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。下面将用三种方式来实现瀑布流的效果 JavaScript原生方法实现瀑布流布局jQurey实现瀑布流布局CSS3实现瀑布流布局","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"http://yoursite.com/tags/jquery/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"layout","slug":"layout","permalink":"http://yoursite.com/tags/layout/"},{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"}]},{"title":"html5学习之拖拽与拖放","date":"2015-06-24T16:00:00.000Z","path":"2015/06/25/html5-dnd/","text":"以前实现元素的拖拽需要使用javascript大段代码实现，又是记录初始位置，又是记录位移等等很麻烦，现在HTML5提供了专门的拖拽与拖放的API，先说说相关API 事件 产生的源对象 说明 drag 被拖动的元素 这个事件在拖拽源触发。即在拖拽操作中触发dragstart事件的元素。 drop 拖放的目标元素 这个事件在拖拽操作结束释放时于释放元素上触发。一个监听器用来响应接收被拖拽的数据并插入到释放之地。这个事件只有在需要时才触发。当用户取消了拖拽操作时将不触发，例如按下了Escape（ESC）按键，或鼠标在非可释放目标上释放了按键。 dragstart 被拖动的元素 当一个元素开始被拖拽的时候触发。用户拖拽的元素需要附加dragstart事件。在这个事件中，监听器将设置与这次拖拽相关的信息，例如拖动的数据和图像。 dragenter 拖动过程中鼠标经过的元素 当拖拽中的鼠标第一次进入一个元素的时候触发。这个事件的监听器需要指明是否允许在这个区域释放鼠标。如果没有设置监听器，或者监听器没有进行操作，则默认不允许释放。当你想要通过类似高亮或插入标记等方式来告知用户此处可以释放，你将需要监听这个事件。 dragleave 拖动过程中鼠标经过的元素 当拖拽中的鼠标离开元素时触发。监听器需要将作为可释放反馈的高亮或插入标记去除。 dragend 拖动的对象元素 拖拽源在拖拽操作结束将得到dragend事件对象，不管操作成功与否。 dragover 拖动过程中鼠标经过的元素 当拖拽中的鼠标移动经过一个元素的时候触发。大多数时候，监听过程发生的操作与dragenter事件是一样的。 兼容如下 其他设置 1、DataTransfer 对象：退拽对象用来传递的媒介，使用一般为Event.dataTransfer。 2、draggable 属性：就是标签元素要设置draggable=true，否则不会有效果，例如：1&lt;div title=\"拖拽我\" draggable=\"true\"&gt;列表1&lt;/div&gt; 3、Event.preventDefault() 方法：阻止默认的些事件方法等执行。在dragover中一定要执行preventDefault()，否则drop事件不会被触发。另外，如果是从其他应用软件或是文件中拖东西进来，尤其是图片的时候，默认的动作是显示这个图片或是相关信息，并不是真的执行drop。此时需要用用document的dragover事件把它直接干掉。 上面有一个很关键的对象DataTransfer，在进行拖放操作时，DataTransfer 对象用来保存被拖动的数据。它可以保存一项或多项数据、一种或者多种数据类型,其属性和方法如下 属性/方法 类型/参数 作用 dropEffect String 设置实际的放置效果，它应该始终设置成 effectAllowed 的可能值之一 ，可以指定为none(禁止所有操作)、copy(复制到新的位置)、link(建立一个源位置到新位置的链接)、move(移动到新的位置 ) effectAllowed String 用来指定拖动时被允许的效果，可以指定为 copy(复制到新的位置), move(移动到新的位置 ), link(建立一个源位置到新位置的链接), copyLink(允许复制或者链接), copyMove(允许复制或者移动), linkMove( 允许链接或者移动), all(允许所有的操作), none(禁止所有操作), uninitialized(缺省值（默认值）, 相当于 all. ) files FileList 包含一个在数据传输上所有可用的本地文件列表。如果拖动操作不涉及拖动文件，此属性是一个空列表。此属性访问指定的FileList 中无效的索引将返回未定义（undefined）。 types DOMStringList 保存一个被存储数据的类型列表作为第一项，顺序与被添加数据的顺序一致。如果没有添加数据将返回一个空列表。 addElement() element(要添加的元素) 设置拖动源。通常你不需要改变这项，如果修改这项将会影响拖动的哪个节点和dragend事件的触发。默认目标是被拖动的节点。 clearData() type(要删除的数据类型) 删除与给定类型关联的数据。类型参数是可选的。如果类型为空或未指定，将删除所有类型相关联的数据。如果不存在指定类型的数据，或数据传输不包含任何数据，此方法将没有任何效果。 getData() type(要检索的数据类型) 检索（取得）给定类型的数据，如果给定类型的数据不存在或者数据转存（data transfer）没有包涵数据，方法将返回一个空字符串。 setData() type(要添加的数据类型), data(要添加的数据) 为一个给定的类型设置数据。如果该数据类型不存在，它将添加到的末尾，这样类型列表中的最后一个项目将是新的格式。如果已经存在的数据类型，替换相同的位置的现有数据。就是，当更换相同类型的数据时，不会更改类型列表的顺序。 setDragImage() image(要用作拖动反馈图像元素), x(图像内的水平偏移量), y(图像内的垂直偏移量) 自定义一个期望的拖动时的图片。大多数情况下，这项不用设置，因为被拖动的节点被创建成默认图片。坐标指定图像相对于鼠标光标位置的偏移量。 说了这么多相关的API，现在就开始实际操作一下 功能检测在使用darg之前，我们需要判断是否支持，这里可以使用一个工具modernizr,使用方法如下12345if (Modernizr.draganddrop) &#123; // Browser supports HTML5 DnD.&#125; else &#123; // Fallback to a library solution.&#125; 创建可拖动内容在要设为可移动的元素上设置 draggable=true 属性。可以是任何能启用拖动功能的内容，包括图片、链接、文件或其他 DOM 节点，实例如下： See the Pen BNJBQB 完成拖动- 在您的内容上定义 draggable=”true” 属性后，附加 dragstart 事件处理程序以展开每一列的 DnD 序列。- 每种事件类型的 this/e.target 各不相同，具体取决于我们在 DnD 事件模型中所处的位置。- 如果要拖动链接之类的内容，我们需要阻止浏览器的默认行为，不让其导航至该链接。为实现这一目标，可调用 dragover 事件中的 e.preventDefault()。在同一处理程序中调用 return false 也是个不错的做法。浏览器与这些所需操作会有点不协调，但并不会有所损害。- 我们使用 dragenter 触发“over”类，而不是使用 dragover。如果我们使用 dragover，系统将反复触发 CSS 类，因为 dragover 事件会在鼠标悬停在列上方时不断启动。这将最终导致浏览器的渲染器进行大量不必要的工作。- dataTransfer 可在 dragstart 事件中进行设置，并在 drop 事件中读取/处理。调用 e.dataTransfer.setData(format, data) 会将对象内容设置成 MIME 类型，并将数据有效负载作为参数传递。See the Pen qdpWrK 购物车 See the Pen WvzPjm 实现了购物车的添加并计算价格的功能，这里还有个功能以后完善，就是删除购物车商品的功能，后期完善。 参考资料：本机 HTML5 拖放","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"}]},{"title":"css3学习之column","date":"2015-06-08T16:00:00.000Z","path":"2015/06/09/css3-of-column/","text":"CSS多列布局继承自块级布局模式，允许简单地定义多列文本。 一行太长的文字读起来很麻烦；当人眼从一行过长的文字末端移动到下一行开始处，就容易弄错到底该读哪一行。因此，为了最优化使用大的显示屏幕，设计者应该限制文字段落的宽度而并排排列，就像报纸一样。 糟糕的是如果不使用CSS和HTML在特定的位置强制换行，或者严格限制文本中允许的标记，或者夸张地使用脚本的话，这是不可能实现的。该限制通过从传统的块级布局模块中延伸出来的新的CSS属性得以解决。 兼容如下 属性如下 属性（Properties） 版本（CSS Version） 简介（Description columns CSS3 CSS3 columns 属性，是复合属性，设置或检索对象的列数和每列的宽度 column-width CSS3 CSS3 column-width 属性，设置或检索对象每列的宽度 column-count CSS3 CSS3 column-count 属性，设置或检索对象的列数 column-gap CSS3 CSS3 column-gap 属性，设置或检索对象的列与列之间的间隙 column-rule CSS3 CSS3 column-rule 属性，是复合属性。设置或检索对象的列与列之间的边框 column-rule-width CSS3 CSS3 column-rule-width 属性，设置或检索对象的列与列之间的边框厚度 column-rule-style CSS3 CSS3 column-rule-style 属性，设置或检索对象的列与列之间的边框样式 column-rule-color CSS3 CSS3 column-rule-color 属性，设置或检索对象的列与列之间的边框颜色 column-span CSS3 CSS3 column-span 属性，设置或检索对象元素是否横跨所有列 column-fill CSS3 CSS3 column-fill 属性，设置或检索对象所有列的高度是否统一 column-break-before CSS3 CSS3 column-break-after 属性，设置或检索对象之后是否断行 column-break-after CSS3 CSS3 column-width 属性，设置或检索对象每列的宽度 column-break-inside CSS3 CSS3 column-break-inside 属性，设置或检索对象内部是否断行 DemoJS Bin on jsbin.com","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"layout","slug":"layout","permalink":"http://yoursite.com/tags/layout/"},{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"}]},{"title":"css3学习之display:flex","date":"2015-06-02T16:00:00.000Z","path":"2015/06/03/css3-of-flex/","text":"CSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。对于很多应用来讲，弹性盒改进了盒模型，既不使用浮动，也不会在弹性盒容器与其内容之间合并外边距。 弹性盒布局的定义中，它可以自动调整子元素的高和宽，来很好的填充任何显示设备中的可用显示空间，收缩内容防止内容溢出。 不同于盒布局的基于垂直方向以及行内布局的基于水平方向，弹性盒布局的算法是方向无关的。 虽然盒布局在页面中工作良好，但是其定义不足以支持那种需要根据用户代理从竖直切换成水平等变化而进行方向切换、大小调整、拉伸、收缩的引用组件。不同于将要出现的网格布局针对目标为大比例布局，弹性盒布局更适用于应用组件和小比例布局。这两种都是CSS工作组为了能与不同用户代理、不同书写模式和其他弹性需要进行协作而做出的努力。 兼容如下 CSS Syntax1flex: flex-grow flex-shrink flex-basis|auto|initial|inherit; 弹性容器 弹性子元素的父元素。 通过设置display属性的值为flex或inline-flex将其定义为弹性容器。 弹性子元素 弹性容器的每一个子元素变为一个弹性子元素。弹性容器直接包含的文本变为匿名的弹性子元素。 轴 每个弹性盒布局以两个轴来排列。弹性子元素沿着主轴依次相互排列。侧轴垂直于主轴。 属性 flex-direction 定义主轴方向。 属性 justify-content 定义了弹性子元素如何在当前线上沿着主轴排列。 属性 align-items 定义了弹性子元素如何在当前线上沿着侧轴排列。 属性 align-self 覆盖父元素的align-items属性，定义了单独的弹性子元素如何沿着侧轴排列。 方向 弹性容器的主轴开始、主轴结束和侧轴开始、侧轴结束边缘代表了弹性子元素排列的起始和结束位置。它们具体取决于由writing-mode（从左到右、从右到左等等）属性建立的向量中的主轴和侧轴位置。 属性 order 将元素依次分组，并决定谁先出现。 属性 flex-flow 是属性 flex-direction 和 flex-wrap 的简写，用于排列弹性子元素。 行 弹性子元素根据 flex-wrap 属性控制的侧轴方向（在这个方向上可以建立垂直的新线），既可以是一行也可以是多行排列。 不影响弹性盒子的属性 因为弹性盒子使用一种不同的布局逻辑，一些属性会在弹性容器上无效。 多列模块 中的column-*属性对弹性子元素无效。 float 和 clear 对弹性子元素无效。使用 float 会导致 display 属性计算为 block. vertical-align 对弹性子元素的对齐无效。 接下来看看flex的一些属性 flex-basis 属性flex-basis指定了项的初始值，CSS Syntax如下，查看DEMO1flex-basis: number|auto|initial|inherit; flex-direction 属性flex-direction指定了项的排列方向，CSS Syntax如下，查看DEMO1flex-direction: row|row-reverse|column|column-reverse|initial|inherit; flex-flow 属性 flex-flow 是属性 flex-direction 和 flex-wrap 的简写，用于排列弹性子元素，CSS Syntax如下，查看DEMO1flex-flow: flex-direction flex-wrap|initial|inherit; flex-grow 属性 flex-grow 指定了在同一容器中，相对于其他项的增长数目，CSS Syntax如下，查看DEMO1flex-grow: number|initial|inherit; flex-shrink 属性 flex-shrink 指定了在同一容器中，相对于其他项的减少数目，CSS Syntax如下，查看DEMO1flex-shrink: number|initial|inherit; flex-wrap 属性 flex-wrap 指定了是否折行，CSS Syntax如下，查看DEMO1flex-wrap: nowrap|wrap|wrap-reverse|initial|inherit; 参考资料:MDN使用 CSS 弹性盒w3schoolsCSS flex Property","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"layout","slug":"layout","permalink":"http://yoursite.com/tags/layout/"},{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"}]},{"title":"css3学习之animation","date":"2015-05-25T16:00:00.000Z","path":"2015/05/26/css3-of-animation/","text":"animation运用的是一个Keyframes(关键帧)的概念来制作动画，这个概念和flash里面的关键帧一样，每一关键帧一个状态，然后很多关键帧拼成了一个动画。关键帧使用percentage来指定动画发生的时间点。0%表示动画的第一时刻，100%表示动画的最终时刻。因为这两个时间点十分重要，所以还有特殊的别名：from和to。这两个都是可选的，若from/0%或to/100%未指定，则浏览器使用计算值开始或结束动画。也可包含额外可选的关键帧，描述动画开始和结束之间的状态。 语法规则如下： animation-name 必须，定义了animation的动画名称 keyframes-selector 必须，定义阶段，0%或者from为开始，100%或者to为结束 css-styles 必须，每一关键帧的css样式 示例如下：1234567891011121314@-webkit-keyframes 'animation_name' &#123; 0% &#123; //css code &#125; 35% &#123; //css code &#125; 65% &#123; //css code &#125; 100% &#123; //css code &#125; &#125; 先来看看animation的兼容情况 可以看到，animation基本上被所有游览器支持了,接下来说一下animation的几个属性 一、animation-name语法如下：1animation-name: none | IDENT animation-name是用来定义一个动画的名称，其主要有两个值：IDENT是由Keyframes创建的动画名，换句话说此处的IDENT要和Keyframes中的IDENT一致，如果不一致,将不能实现任何动画效果；none为默认值，当值为none时，将没有任何动画效果。我们可以同时附几个animation给一个元素，我们只需要用逗号“，”隔开。 二、animation-duration：语法如下：1animation-duration: &lt;time&gt; animation-duration是用来指定元素播放动画所持续的时间长，取值:&lt;time&gt;为数值，单位为s（秒.）其默认值为“0”。这个属性跟transition中的transition-duration使用方法是一样的。 三、animation-timing-function语法如下：1animation-timing-function:ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier animation-timing-function是指元素根据时间的推进来改变属性值的变换速率，说得简单点就是动画的播放方式。他和transition中的transition-timing-function一样，具有以下六种变换方式：ease;ease-in;ease-in-out;linear;cubic-bezier。 四、animation-delay语法如下：1animation-delay: &lt;time&gt; animation-delay是用来指定元素动画开始时间。取值为&lt;time&gt;为数值，单位为s(秒)，其默认值也是0。这个属性和transition-delay使用方法是一样的。 五、animation-iteration-count语法如下：1animation-iteration-count:infinite | &lt;number&gt; animation-iteration-count是用来指定元素播放动画的循环次数，其可以取值&lt;number&gt;为数字，其默认值为“1”；infinite为无限次数循环。 六、animation-direction语法如下：1animation-direction: normal | alternate animation-direction是用来指定元素动画播放的方向，其只有两个值，默认值为normal，如果设置为normal时，动画的每次循环都是向前播放；另一个值是alternate，他的作用是，动画播放在第偶数次向前播放，第奇数次向反方向播放。 七、animation-play-state语法如下：1animation-play-state:running | paused animation-play-state主要是用来控制元素动画的播放状态。其主要有两个值，running和paused,其中running为默认值。他们的作用就类似于我们的音乐播放器一样，可以通过paused将正在播放的动画停下了，也可以通过running将暂停的动画重新播放，我们这里的重新播放不一定是从元素动画的开始播放，而是从你暂停的那个位置开始播放。另外如果暂时了动画的播放，元素的样式将回到最原始设置状态。这个属性目前很少内核支持，所以只是稍微提一下。 查看DEMO 参考资料：w3cplus CSS3 Animationw3schools CSS3 Animations","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"},{"name":"animation","slug":"animation","permalink":"http://yoursite.com/tags/animation/"}]},{"title":"Swiper学习之旅（4）-API(3)","date":"2015-05-24T16:00:00.000Z","path":"2015/05/25/Swiper-learning-4/","text":"今天是最后一篇API的讲解，基本可以解决简单的使用。 touchRatio触摸距离与slide滑动距离的比率。就是说，触碰的点离划过的距离为touchRatio*slider长度的时候，才可以切换到下一个slider。 slideToClickedSlide设置为true则swiping时点击slide会过渡到这个slide。例如slide1向slide2 swipe的过程中轻点slide1会回到slide1，false则不接受此效果。 mySwiper.params重要参数，获取Swiper对象初始化参数，或者重写该参数123456var mySwiper = new Swiper('.swiper-container',&#123; autoplay : 1000,&#125;)$('#btn1').click(function()&#123; mySwiper.params.autoplay=200;&#125;) control设置为另外一个Swiper实例开始控制该Swiper。12345var Swiper1 = new Swiper('#swiper-container1',&#123;&#125;)var Swiper2 = new Swiper('#swiper-container2',&#123;&#125;)Swiper1.params.control = Swiper2;//需要在Swiper2初始化后 了解了上面两个API后我们可以做一个同步切换的DEMO hashnav如需使用散列导航（有点像锚链接）将此参数设置为true。此外在每个slide处增加data-hash属性。这样当你的swiper切换时你的页面url就会加上这个属性的值了，你也可以通过进入页面时修改页面url让swiper在初始化时切换到指定的slide。当你做复杂开发时这个很有用，因为你不必等待前面slide的切换就可以直接跳转到指定的slide了。使用方法示例,html部分12345678910&lt;div class=\"swiper-container\"&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;div class=\"swiper-slide\" data-hash=\"slide1\"&gt; slider1&lt;/div&gt; &lt;div class=\"swiper-slide\" data-hash=\"slide2\"&gt; slider2&lt;/div&gt; &lt;div class=\"swiper-slide\" data-hash=\"slide3\"&gt; slider3&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; js部分123var mySwiper = new Swiper('.swiper-container',&#123; hashnav:true,&#125;) parallax如需要开启视差效果（相对父元素移动），设置为true并在所需要的元素上增加data-swiper-parallax属性。 自从3.03版本后Swiper为swiper和slide内元素增加视差效果。有两种表现形式： 对于swiper-container的子元素，视差效果基于swiper的progress（0-1之间的小数，如有三个slide则是0-&gt;0.5-&gt;1）。 对于slides的子元素，视差效果基于slide的progress（1，0，-1，当前slide向左是从0-&gt;1，向右是从0-&gt;-1）。 data-swiper-parallax接受两种类型的参数。 number（单位：px），移动距离=number*progress。 percentage（百分比），移动距离=percentage(x)progress(x)元素宽度。 你还可以通过data-swiper-parallax-x 和 data-swiper-parallax-y单独设定其移动方向。 例：swiper内有5个slide，则swiper的progress是 0，0.25，0.5，0.75，1。swiper-container的子元素，设定了data-swiper-parallax=1000，当slide从0过渡到1时（初始向右滑动），该元素向右移动250px。slides的子元素，设定了data-swiper-parallax=1000，当slide从0过渡到1时（初始向右滑动），该元素相对于slide从0向右移动到250px处。nextslide内元素相对于slide从-250px向右移动0px处。 使用方法示例,css部分12345678910.parallax-bg &#123; position: absolute; left: 0; top: 0; width: 130%; height: 100%; -webkit-background-size: cover; background-size: cover; background-position: center;&#125; html部分123456789101112131415161718192021&lt;div class=\"swiper-container\"&gt; &lt;!-- Parallax background element --&gt; &lt;div class=\"parallax-bg\" style=\"background-image:url(/demo/img/Parallax.jpg)\" data-swiper-parallax=\"-23%\"&gt; &lt;/div&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;div class=\"swiper-slide\"&gt; &lt;!-- Each slide has parallax title --&gt; &lt;div class=\"title\" data-swiper-parallax=\"-100\"&gt;Slide 1&lt;/div&gt; &lt;!-- Parallax subtitle --&gt; &lt;div class=\"subtitle\" data-swiper-parallax=\"-200\"&gt;Subtitle&lt;/div&gt; &lt;!-- And parallax text --&gt; &lt;div class=\"text\" data-swiper-parallax=\"-300\"&gt; &lt;p&gt;Lorem ipsum dolor sit amet, ...&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; ... &lt;/div&gt;&lt;/div&gt; js部分123var mySwiper = new Swiper('.swiper-container',&#123; parallax : true,&#125;) 查看DEMO paginationBulletRender渲染分页器小点。这个参数允许完全自定义分页器的指示点。使用方法示例1234567var swiper = new Swiper('.swiper-container', &#123; pagination: '.swiper-pagination', paginationClickable: true, paginationBulletRender: function (index, className) &#123; return '&lt;span class=\"' + className + '\"&gt;' + (index + 1) + '&lt;/span&gt;'; &#125;&#125;); 效果如下 preloadImages默认为true，Swiper会强制加载所有图片。 lazyLoading设为true开启图片延迟加载，使preloadImages无效。需要将图片img标签的src改写成data-src，并且增加类名swiper-lazy。还可以为slide加一个预加载，1&lt;div class=\"swiper-lazy-preloader\"&gt;&lt;/div&gt; 或者白色的1&lt;div class=\"swiper-lazy-preloader swiper-lazy-preloader-white\"&gt;&lt;/div&gt; 当你设置了slidesPerView:&#39;auto&#39; 或者 slidesPerView &gt; 1，还需要开启watchSlidesVisibility。使用方法示例12345678910111213141516&lt;div class=\"swiper-container\"&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;div class=\"swiper-slide\"&gt; &lt;img data-src=\"path/to/picture-1.jpg\" class=\"swiper-lazy\"&gt; &lt;div class=\"swiper-lazy-preloader swiper-lazy-preloader-white\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"swiper-slide\"&gt; &lt;img data-src=\"path/to/picture-2.jpg\" class=\"swiper-lazy\"&gt; &lt;div class=\"swiper-lazy-preloader swiper-lazy-preloader-white\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"swiper-slide\"&gt; &lt;img data-src=\"path/to/picture-3.jpg\" class=\"swiper-lazy\"&gt; &lt;div class=\"swiper-lazy-preloader swiper-lazy-preloader-white\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 这里添加一个Lazy loading for background images debuggerdebugger调试，使用方法示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;script&gt;/* ========Debugger plugin, simple demo plugin to console.log some of callbacks======== */Swiper.prototype.plugins.debugger = function (swiper, params) &#123; if (!params) return; // Need to return object with properties that names are the same as callbacks return &#123; onInit: function (swiper)&#123; console.log('onInit'); &#125;, onClick: function (swiper, e) &#123; console.log('onClick'); &#125;, onTap: function (swiper, e) &#123; console.log('onTap'); &#125;, onDoubleTap: function (swiper, e) &#123; console.log('onDoubleTap'); &#125;, onSliderMove: function (swiper, e) &#123; console.log('onSliderMove'); &#125;, onSlideChangeStart: function (swiper) &#123; console.log('onSlideChangeStart'); &#125;, onSlideChangeEnd: function (swiper) &#123; console.log('onSlideChangeEnd'); &#125;, onTransitionStart: function (swiper) &#123; console.log('onTransitionStart'); &#125;, onTransitionEnd: function (swiper) &#123; console.log('onTransitionEnd'); &#125;, onReachBeginning: function (swiper) &#123; console.log('onReachBeginning'); &#125;, onReachEnd: function (swiper) &#123; console.log('onReachEnd'); &#125; &#125;;&#125;;&lt;/script&gt;&lt;!-- Initialize Swiper --&gt;&lt;script&gt;var swiper = new Swiper('.swiper-container', &#123; pagination: '.swiper-pagination', paginationClickable: true, nextButton: '.swiper-button-next', prevButton: '.swiper-button-prev', // Enable debugger debugger: true&#125;);&lt;/script&gt; 参考资料Swiper中文网","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"Swiper","slug":"Swiper","permalink":"http://yoursite.com/tags/Swiper/"},{"name":"mobile","slug":"mobile","permalink":"http://yoursite.com/tags/mobile/"}]},{"title":"Swiper学习之旅（3）-API(2)","date":"2015-05-22T16:00:00.000Z","path":"2015/05/23/Swiper-learning-3/","text":"昨天讲解了部分API，今天继续讲一部分，估计接下来还有一篇。 grabCursor设置为true时，鼠标覆盖Swiper时指针会变成手掌形状，拖动时指针会变成抓手形状。（根据浏览器形状有所不同） scrollbarScrollbar容器的css选择器或HTML元素。scrollbar使用时需要需要配合html标签使用，在div中添加class标签1&lt;div class=\"swiper-scrollbar\"&gt;&lt;/div&gt; js中设置如下1scrollbar: '.swiper-scrollbar' scrollbarHide滚动条是否自动隐藏。默认：true，此时若是没有任何操作，滚动条会自动隐藏。 nextButton，prevButton点击左右切换的按钮,使用时需要需要配合html标签使用，在div中添加class标签12&lt;div class=\"swiper-button-next\"&gt;&lt;/div&gt;&lt;div class=\"swiper-button-prev\"&gt;&lt;/div&gt; js中设置如下12nextButton: '.swiper-button-next',prevButton: '.swiper-button-prev' effectslide的切换效果，默认为slide（位移切换），可设置为fade（淡入），cube（方块），coverflow（3d流）。 fade效果参数。可选参数：crossFade 默认：false。关闭淡出。过渡时，原slide透明度为1（不淡出），过渡中的slide透明度从0-&gt;1（淡入），其他slide透明度0。可选值：true。开启淡出。过渡时，原slide透明度从1-&gt;0（淡出），过渡中的slide透明度从0-&gt;1（淡入），其他slide透明度0。1234effect : 'fade',fade: &#123; crossFade: false,&#125; fade demo cube效果参数，可选值： slideShadows：开启slide阴影。默认 true。shadow： 开启投影。默认 true。shadowOffset：投影距离。默认 20，单位px。shadowScale： 投影缩放比例。默认0.94。1234567effect : 'cube',cube: &#123; slideShadows: true, shadow: true, shadowOffset: 100, shadowScale: 0.6&#125; cube demo coverflow是类似于苹果将多首歌曲的封面以3D界面的形式显示出来的方式。coverflow效果参数，可选值： rotate：slide做3d旋转时Y轴的旋转角度。默认50。stretch：每个slide之间的拉伸值，越大slide靠得越紧。 默认0。depth：slide的位置深度。值越大z轴距离越远，看起来越小。 默认100。modifier：depth和rotate和stretch的倍率，相当于depthmodifier、rotatemodifier、stretch*modifier，值越大这三个参数的效果越明显。默认1。slideShadows：开启slide阴影。默认 true。123456789effect : 'coverflow',slidesPerView : 3,coverflow: &#123; rotate: 20, stretch: 40, depth: 300, modifier: 2, slideShadows : true&#125; coverflow demo keyboardControl是否开启键盘控制Swiper切换。设置为true时，能使用键盘方向键控制slide滑动。 mousewheelControl是否开启鼠标控制Swiper切换。设置为true时，能使用鼠标滑轮控制slide滑动。 autoplay自动切换的时间间隔（单位ms），不设定该参数slide不会自动切换，用户操作后autoplay停止。12345678var mySwiper = new Swiper('.swiper-container',&#123;autoplay : 5000,&#125;//反方向自动切换简单示例var mySwiper = new Swiper('.swiper-container',&#123;loop : true,&#125;)setInterval(\"mySwiper.slidePrev()\", 2000); autoplayDisableOnInteraction用户操作swiper之后，是否禁止autoplay。默认为true：停止。如果设置为false，用户操作swiper之后自动切换不会停止，每次都会重新启动autoplay。操作包括触碰，拖动，点击pagination等。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"Swiper","slug":"Swiper","permalink":"http://yoursite.com/tags/Swiper/"},{"name":"mobile","slug":"mobile","permalink":"http://yoursite.com/tags/mobile/"}]},{"title":"Swiper学习之旅（2）-API(1)","date":"2015-05-21T16:00:00.000Z","path":"2015/05/22/Swiper-learning-2/","text":"上篇文章讲了一些swiper的基本用法，今天来介绍一下常用的一些API directionslide滑动方向，可设置horizontal(水平)或vertical(垂直),默认是水平 pagination分页器容器的css选择器或HTML标签，这里需要配合html标签使用，在div中添加class标签：1&lt;div class=\"swiper-pagination\"&gt;&lt;/div&gt; js中进行相应设置1pagination: '.swiper-pagination' 这样就可以出现分页的按钮 paginationClickable此参数设置为true时，点击分页器的指示点分页器会控制Swiper切换，默认是false，这个API一般是配合上面的pagination一起使用 spaceBetweenslide之间的距离（单位px）,如下图 slidesPerView设置slider容器能够同时显示的slides数量(carousel模式)。可以设置为number或者 auto，auto则自动根据slides的宽度来设定数量。loop模式下如果设置为auto还需要设置另外一个参数loopedSlides。 loop设置为true 则开启loop模式。loop模式：会在wrapper前后生成若干个slides让slides看起来是衔接的，用于无限循环切换。loop模式在与free模式同用时会产生抖动，因为free模式下没有复制slide的时间点。 loopedSlides在loop模式下使用slidesPerview:auto,还需使用该参数设置所要用到的loop个数,这里的个数与slider的个数相同 centeredSlides设定为true时，当前slider会居中，而不是默认状态下的居左,默认false设置为true效果如下设置为false效果如下 freeMode默认为false，普通模式slide滑动时只滑动一格，并自动贴合wrapper，设置为true则变为free模式，slide会根据惯性滑动且不会贴合。 slidesPerColumn多行布局里面每列的slide数量,这时候排列会按照由上到下的排列，举例slidesPerColumn:2,如图 最后来做一个Demo，如果想在slider中套用slider怎么办，办法就是new两个swiper-containerhtml部分123456789101112131415161718192021&lt;div class=\"swiper-container swiper-container-h\"&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;div class=\"swiper-slide\"&gt;Horizontal Slide 1&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt; &lt;div class=\"swiper-container swiper-container-v\"&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;div class=\"swiper-slide\"&gt;Vertical Slide 1&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;Vertical Slide 2&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;Vertical Slide 3&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;Vertical Slide 4&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;Vertical Slide 5&lt;/div&gt; &lt;/div&gt; &lt;div class=\"swiper-pagination swiper-pagination-v\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;Horizontal Slide 3&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;Horizontal Slide 4&lt;/div&gt; &lt;/div&gt; &lt;!-- Add Pagination --&gt; &lt;div class=\"swiper-pagination swiper-pagination-h\"&gt;&lt;/div&gt;&lt;/div&gt; js部分1234567891011var swiperH = new Swiper('.swiper-container-h', &#123; pagination: '.swiper-pagination-h', paginationClickable: true, spaceBetween: 50&#125;);var swiperV = new Swiper('.swiper-container-v', &#123; pagination: '.swiper-pagination-v', paginationClickable: true, direction: 'vertical', spaceBetween: 50&#125;); 查看Demo","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"Swiper","slug":"Swiper","permalink":"http://yoursite.com/tags/Swiper/"},{"name":"mobile","slug":"mobile","permalink":"http://yoursite.com/tags/mobile/"}]},{"title":"Swiper学习之旅（1）","date":"2015-05-20T16:00:00.000Z","path":"2015/05/21/Swiper-learning-1/","text":"引入文件先去Swiper官网下载Swiper相关js和css文件，当然可以用cdn引入12&lt;link rel=&quot;stylesheet&quot; href=&quot;css/swiper.css&quot;/&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/swiper.min.js&quot;&gt;&lt;/script&gt; html部分先用3个div做实例123456789&lt;div class=\"swiper-container\"&gt; &lt;!-- Additional required wrapper --&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;!-- Slides --&gt; &lt;div class=\"swiper-slide\"&gt;Slide 1&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;Slide 2&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;Slide 3&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; js部分首先初始化，然后用相关API进行设置12345678window.onload = function () &#123; //initialize swiper when document ready var mySwiper = new Swiper ('.swiper-container', &#123; // Optional parameters direction: 'vertical', loop: false, &#125;)&#125;; DEMO查看demo 自适应page因为swiper主要是用在手机上，用来滑动的一个插件，所以我们接下来看一个用在手机端的自适应的一个Demo","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"Swiper","slug":"Swiper","permalink":"http://yoursite.com/tags/Swiper/"},{"name":"mobile","slug":"mobile","permalink":"http://yoursite.com/tags/mobile/"}]},{"title":"Sass学习之一 ——安装Sass","date":"2015-04-27T16:51:00.000Z","path":"2015/04/28/sass-learning-1/","text":"一、下载ruby安装包安装完成后，可以在命令行输入相关命令来检测安装是否完成 二，安装Sass安装过程中会出现error，本次安装出现错误如下 错误原因是因为由于国内网络原因（你懂的），导致 rubygems.org 存放在 Amazon S3 上面的资源文件间歇性连接失败。 解决办法RubyGems 镜像 - 淘宝网 最后安装成功 安装成功后，ruby文件夹内就有如下几个文件 这样就可以用webstorm或者相关工具进行编译sass文件了。","tags":[{"name":"Sass","slug":"Sass","permalink":"http://yoursite.com/tags/Sass/"}]},{"title":"使用CSS3美化复选框checkbox","date":"2015-03-24T16:37:47.000Z","path":"2015/03/25/using-css-to-beauty-checkbox/","text":"我们知道HTML默认的复选框样式十分简陋，而以图片代替复选框的美化方式会给页面表单的处理带来麻烦，那么本文将结合实例来了解一下使用CSS3将复选框checkbox进行样式美化，并且带上超酷的滑动效果。一般我们处理input都会用label的for属性与input的ID关联，这样的话，用户点击label的时候，实际上就相当于点击了那个input，通过label和checkbox，我们可以将checkbox隐藏，而将label制作为各种漂亮超酷的复选框样式。我们可以使用:before和:after伪元素来制作各种效果，如滑动按钮的效果。这些效果都可以通过相邻兄弟选择器来选择与checkbox相邻的label来实现，结果如下 勾选样式See the Pen mJWjra by dsky (@dsky) on CodePen. 单按钮See the Pen jPBpyb by dsky (@dsky) on CodePen. 移动端开关See the Pen PqpBpv by dsky (@dsky) on CodePen. 开启和关闭See the Pen qdryjo by dsky (@dsky) on CodePen.","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"}]},{"title":"HTML5学习之语义","date":"2015-03-14T13:09:59.000Z","path":"2015/03/14/html5-learning-1/","text":"一、HTML5的文档节段和纲要","tags":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"}]},{"title":"Javascript事件模型：捕获和冒泡","date":"2015-01-20T09:23:55.000Z","path":"2015/01/20/Javascript-event-model-of-capture-and-bubbling/","text":"在js的事件模型中，存在着两种不一样的处理方式，一总是捕获，一种是冒泡。早期的两种主流的浏览器Netscape和IE有不同的解决方案，IE采用的是事件冒泡的方法，而Netscape则是采用事件捕获的处理方法，区别如下图： 然后我们再来看看w3c中，对不同Event的定义规范: Event TypeBubbling phaseTrusted event target typesDOM interfaceCancelableabortNoWindow, ElementEventNobeforeinputYesElementInputEventYesblurNoWindow, ElementFocusEventNoclickYesElementMouseEventYescompositionstartYesElementCompositionEventYescompositionupdateYesElementCompositionEventNocompositionendYesElementCompositionEventNodblclickYesElementMouseEventNoerrorNoWindow, ElementEventNofocusNoWindow, ElementFocusEventNofocusinYesWindow, ElementFocusEventNofocusoutYesWindow, ElementFocusEventNoinputYesElementInputEventNokeydownYesElementKeyboardEventYeskeyupYesElementKeyboardEventYesloadNoWindow, Document,ElementEventNomousedownYesElementMouseEventYesmouseenterNoElementMouseEventNomouseleaveNoElementMouseEventNomousemoveYesElementMouseEventYesmouseoutYesElementMouseEventYesmouseoverYesElementMouseEventYesmouseupYesElementMouseEventYesresizeNoWindow, ElementUIEventNoscrollNo / YesDocument, ElementUIEventNoselectYesElementEventNounloadNoWindow, Document,ElementEventNowheelYesElementWheelEventYes 从上面我们可以看到什么事件会冒泡，什么事件不会。 看完这些我们再来看看这两种模式的影响。 1、子元素没有click函数，但是父元素有 JS Bin 可以看到，点击子元素的时候，也会调用父元素的click函数 2、子元素有cilck函数，父元素也有click函数 JS Bin 可以看到，点击子元素的时候也触发了父元素的click函数 上面两个就是冒泡了，然后我们该如何阻止这总默认时间呢 w3c的方法是e.stopPropagation()，IE则是使用window.event.cancelBubble = true; JS Bin 可以看到，成功阻止了冒泡行为","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"CSS之BFC","date":"2015-01-16T07:00:21.000Z","path":"2015/01/16/css-of-bfc/","text":"什么是BFC： BFC就是Block formatting contexts （块级格式化上下文）的简称。 w3c规范中的BFC定义： 浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。 在BFC中，盒子从顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin 值所决定的。在一个BFC中，两个相邻的块级盒子的垂直外边距会产生折叠。 在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。 BFC的通俗理解： 首先BFC是一个名词，是一个独立的布局环境，我们可以理解为一个箱子（实际上是看不见摸不着的），箱子里面物品的摆放是不受外界的影响的。转换为BFC的理解则是：BFC中的元素的布局是不受外界的影响（我们往往利用这个特性来消除浮动元素对其非浮动的兄弟元素和其子元素带来的影响。）并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。 那么我们该怎么使用BFC呢，如何触发BFC呢？： 1、float 除了none以外的值2、overflow 除了visible 以外的值（hidden，auto，scroll ）3、display (table-cell，table-caption，inline-block, flex, inline-flex)4、position值为（absolute，fixed）5、fieldset元素在以上的情况里可以创建BFC。 BFC有一下特性： 1、内部的Box会在垂直方向，从顶部开始一个接一个地放置。2、Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生叠加3、每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。4、BFC的区域不会与float box叠加。5、BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。6、计算BFC的高度时，浮动元素也参与计算。 至此，您或许明白了为什么 overflow:hidden或者auto可以闭合浮动了，真是因为父元素创建了新的BFC。IE6-7的显示引擎使用的是一个称为布局（layout）的内部概念，由于这个显示引擎自身存在很多的缺陷，直接导致了IE6-7的很多显示bug。当我们说一个元素“得到 layout”，或者说一个元素“拥有 layout” 的时候，我们的意思是指它的微软专有属性 hasLayout 。IE6-7使用布局的概念来控制元素的尺寸和定位，那些拥有布局（have layout）的元素负责本身及其子元素的尺寸设置和定位。如果一个元素的 hasLayout 为false，那么它的尺寸和位置由最近拥有布局的祖先元素控制。 触发hasLayout的条件： 1、position: absolute2、float: left|right3、display: inline-block4、width: 除 “auto” 外的任意值5、height: 除 “auto” 外的任意值 （例如很多人闭合浮动会用到 height: 1% ）6、zoom: 除 “normal” 外的任意值7、writing-mode: tb-rl 在 IE7 中，overflow 也变成了一个 layout 触发器： 1、overflow: hidden|scroll|auto （ 这个属性在IE之前版本中没有触发 layout 的功能。 ）2、overflow-x|-y: hidden|scroll|auto （CSS3 盒模型中的属性，尚未得到浏览器的广泛支持。他们在之前IE版本中同样没有触发 layout 的功能） 综上所述： 1、在支持BFC的浏览器（IE8+，firefox，chrome，safari）通过创建新的BFC闭合浮动； 2、在不支持 BFC的浏览器 （IE6-7），通过触发 hasLayout 闭合浮动。 参考文章： 深入理解BFC和Margin Collapse 那些年我们一起清除过的浮动","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"css闭合（清除）浮动","date":"2015-01-15T09:21:41.000Z","path":"2015/01/15/css-clear-float/","text":"经常在写页面的时候会碰到一种情况，明明有子元素，为什么父元素高度为0的情况，就像下面 http://jsbin.com/hutaji/1/ ID为wrapper的父元素有两个子元素，但是它的高度为0！ 原因：浮动元素不会影响父元素的布局（最早设计浮动这个机制的时候，就是为了实现文字环绕在图片周围的效果。所以浮动的时候，文字会环绕在浮动元素周围。） 再说下浮动：浮动的框可以左右移动，直至它的外边缘遇到包含框或者另一个浮动框的边缘。浮动框不属于文档中的普通流，当一个元素浮动之后，不会影响到块级框的布局而只会影响内联框（通常是文本）的排列，文档中的普通流就会表现得和浮动框不存在一样，当浮动框高度超出包含框的时候，也就会出现包含框不会自动伸高来闭合浮动元素（“高度塌陷”现象）。顾名思义，就是漂浮于普通流之上，像浮云一样，但是只能左右浮动。正是因为浮动的这种特性，导致本属于普通流中的元素浮动之后，包含框内部由于不存在其他普通流元素了，也就表现出高度为0（高度塌陷）。在实际布局中，往往这并不是我们所希望的，所以需要闭合浮动元素，使其包含框表现出正常的高度。 浮动的影响： 1、背景不能显示由于浮动产生，如果对父级设置了（CSS background背景）CSS背景颜色或CSS背景图片，而父级不能被撑开，所以导致CSS背景不能显示。 2、边框不能撑开如上图中，如果父级设置了CSS边框属性（css border），由于子级里使用了float属性，产生浮动，父级不能被撑开，导致边框不能随内容而被撑开。3、margin padding设置值不能正确显示由于浮动导致父级子级之间设置了css padding、css margin属性的值不能正确表达。特别是上下边的padding和margin不能正确显示。 但是，平时布局的时候我们经常会用到float这个属性，这个时候怎么解决这个问题呢，为了解决这个问题就要说到闭合（清除）浮动了。 DEMO 闭合（清除）浮动的方法： 1）在浮动元素末尾添加一个空的标签例如 &lt;div style=”clear:both”&gt;&lt;/div&gt;，其他标签br等亦可 &lt;div class=\"warp\" id=\"float1\"&gt; &lt;h2&gt;1）添加额外标签&lt;/h2&gt; &lt;div class=\"main left\"&gt;.main{float:left;}&lt;/div&gt; &lt;div class=\"side left\"&gt;.side{float:right;}&lt;/div&gt; &lt;div style=\"clear:both;\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;.footer&lt;/div&gt; 优点：通俗易懂，容易掌握缺点：可以想象通过此方法，会添加多少无意义的空标签，有违结构与表现的分离，在后期维护中将是噩梦，这是坚决不能忍受的，所以你看了这篇文章之后还是建议不要用了吧。 2）使用 br标签和其自身的 html属性这个方法有些小众，br 有 clear=“all | left | right | none” 属性 &lt;div class=\"warp\" id=\"float2\"&gt; &lt;h2&gt;2）使用 br标签和其自身的 html属性&lt;/h2&gt; &lt;div class=\"main left\"&gt;.main{float:left;}&lt;/div&gt; &lt;div class=\"side left\"&gt;.side{float:right;}&lt;/div&gt; &lt;br clear=\"all\" /&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;.footer&lt;/div&gt; 优点：比空标签方式语义稍强，代码量较少缺点：同样有违结构与表现的分离，不推荐使用 3)父元素设置 overflow：hidden通过设置父元素overflow值设置为hidden；在IE6中还需要触发 hasLayout ，例如 zoom：1； &lt;div class=\"warp\" id=\"float3\" style=\"overflow:hidden; *zoom:1;\"&gt; &lt;h2&gt;3)父元素设置 overflow:hidden &lt;/h2&gt; &lt;div class=\"main left\"&gt;.main{float:left;}&lt;/div&gt; &lt;div class=\"side left\"&gt;.side{float:right;}&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;.footer&lt;/div&gt; 优点：不存在结构和语义化问题，代码量极少缺点：内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素；04年POPO就发现overflow:hidden会导致中键失效，这是我作为一个多标签浏览控所不能接受的。所以还是不要使用了 4)父元素设置 overflow：auto 属性同样IE6需要触发hasLayout，演示和3差不多 &lt;div class=\"warp\" id=\"float3\" style=\"overflow:auto; *zoom:1;\"&gt; &lt;h2&gt;4)父元素设置 overflow:auto; &lt;/h2&gt; &lt;div class=\"main left\"&gt;.main{float:left;}&lt;/div&gt; &lt;div class=\"side left\"&gt;.side{float:right;}&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;.footer&lt;/div&gt; 优点：不存在结构和语义化问题，代码量极少缺点：多个嵌套后，firefox某些情况会造成内容全选；IE中 mouseover 造成宽度改变时会出现最外层模块有滚动条等，firefox早期版本会无故产生focus等, 请看 嗷嗷的 Demo ,不要使用 5）父元素也设置浮动 &lt;div class=\"warp left\" id=\"float3\"&gt; &lt;h2&gt;5)父元素也设置浮动 &lt;/h2&gt; &lt;div class=\"main left\"&gt;.main{float:left;}&lt;/div&gt; &lt;div class=\"side left\"&gt;.side{float:right;}&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;.footer&lt;/div&gt; 优点：不存在结构和语义化问题，代码量极少缺点：使得与父元素相邻的元素的布局会受到影响，不可能一直浮动到body，不推荐使用 6）父元素设置display:table &lt;div class=\"warp\" id=\"float3\" style=\"display:table; \"&gt; &lt;h2&gt;6)父元素设置 display:table; &lt;/h2&gt; &lt;div class=\"main left\"&gt;.main{float:left;}&lt;/div&gt; &lt;div class=\"side left\"&gt;.side{float:right;}&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;.footer&lt;/div&gt; 优点：结构语义化完全正确，代码量极少缺点：盒模型属性已经改变，由此造成的一系列问题，得不偿失，不推荐使用 7）使用:after 伪元素需要注意的是 :after是伪元素（Pseudo-Element），不是伪类（某些CSS手册里面称之为“伪对象”），很多闭合浮动大全之类的文章都称之为伪类，不过csser要严谨一点，这是一种态度。由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 &lt;div class=\"warp clearfix\" id=\"float\"&gt; &lt;h2&gt;7）.clearfix闭合浮动&lt;/h2&gt; &lt;div class=\"main left\"&gt;.main{float:left;}&lt;/div&gt; &lt;div class=\"side left\"&gt;.side{float:right;}&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;.footer这次 warp 通过 .clearfix 已经闭合浮动了&lt;/div&gt; 优点：结构和语义化完全正确,代码量居中缺点：复用方式不当会造成代码量增加 8）父元素设置display:inline-block 参考文章：那些年我们一起清除过的浮动 这里再贴一个关于在 CSS 中，用 float 和 position 的区别是什么？","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"javascript转换日期字符串为Date对象","date":"2015-01-13T09:25:01.000Z","path":"2015/01/13/Javascript-convers-DateString-to-DateObject/","text":"把一个日期字符串如“2007-2-28 10：18：30”转换为Date对象：12var s = \"2005-12-15 09:41:30\"; var d = new Date(Date.parse(s.replace(/-/g, \"/\"))); &nbsp;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"css在ie中的兼容情况","date":"2015-01-12T03:54:02.000Z","path":"2015/01/12/css-compatibility-in-Internet Explorer/","text":"在microsoft看到的一个关于css属性的兼容表，直接放地址吧 #CSS Compatibility in Internet Explorer","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"}]},{"title":"jQuery Performance Rules（续）","date":"2014-12-26T04:26:52.000Z","path":"2014/12/26/jQuery-Performance-Rules(continue)/","text":"之前发了一篇关于jquery选择器的有效选择建议的文章，看到评论这五个方法不一定是最好的，后来又找到一个相关的选择器时间测试，地址如下（本链接是第39版，囧….） Sizzle class vs tag qualfied class selector","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"http://yoursite.com/tags/jquery/"}]},{"title":"jQuery Performance Rules","date":"2014-12-26T04:25:27.000Z","path":"2014/12/26/jquery-performance-rules/","text":"Once upon a time, all we needed to worry about was reducing Bytes and Requests and playing around with load order to make things faster. Nowadays, we are increasingly impacting one more major component in performance – CPU utilization. Using jQuery and other frameworks that make selecting nodes and DOM manipulation easy can have adverse affects if you’re not careful and follow some simple practices for reducing the work the browser has to do. Always Descend From an #id Use Tags Before Classes Cache jQuery Objects Harness the Power of Chaining Use Sub-queries Limit Direct DOM Manipulation Leverage Event Delegation (a.k.a. Bubbling) Eliminate Query Waste Defer to $(window).load Compress Your JS Learn the Library 原文地址：jQuery Performance Rules","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"http://yoursite.com/tags/jquery/"}]},{"title":"5 Tips for More Efficient jQuery Selectors","date":"2014-12-26T04:12:03.000Z","path":"2014/12/26/5-tips-for-more-efficient-jquery-selectors/","text":"1. Use an ID if PossibleHTML ID attributes are unique in every page and even older browsers can locate a single element very quickly: 1$(\"#myelement\"); 2. Avoid Selecting by Class Only The following class selector will run quickly in modern browsers:1$(\".myclass\"); Unfortunately, in older browser such as IE6/7 and Firefox 2, jQuery must examine every element on the page to determine whether “myclass” has been applied. The selector will be more efficient if we qualify it with a tag name, e.g. 1$(\"div.myclass\"); jQuery can now restrict the search to DIV elements only. 3. Keep it Simple! Avoid overly complex selectors. Unless you have an incredibly complex HTML document, it’s rare you’ll need any more than two or three qualifiers. Consider the following complex selector: 1$(\"body #page:first-child article.main p#intro em\"); p#intro must be unique so the selector can be simplified: 1$(\"p#intro em\"); 4. Increase Specificity from Left to Right A little knowledge of jQuery’s selector engine is useful. It works from the last selector first so, in older browsers, a query such as: 1$(\"p#intro em\"); loads every em element into an array. It then works up the parents of each node and rejects those where p#intro cannot be found. The query will be particularly inefficient if you have hundreds of em tags on the page. Depending on your document, the query can be optimized by retrieving the best-qualified selector first. It can then be used as a starting point for child selectors, e.g. 12$(\"em\", $(\"p#intro\")); // or$(\"p#intro\").find(\"em\"); 5. Avoid Selector Repetition It’s rarely necessary to use the same selector twice. The following code selects every p tag three times: 123$(\"p\").css(\"color\", \"blue\");$(\"p\").css(\"font-size\", \"1.2em\");$(\"p\").text(\"Text changed!\"); Remember jQuery offers chaining; multiple methods can be applied to the same collection. Therefore, the same code can be re-written so it applies to a single selector: 1$(\"p\").css(&#123; \"color\": \"blue\", \"font-size\": \"1.2em\"&#125;).text(\"Text changed!\"); You should cache the jQuery object in a variable if you need to use the same set of elements multiple times, e.g. 123var $p = $(\"p\");$p.css(\"color\", \"blue\");$p.text(\"Text changed!\"); Unlike standard DOM collections, jQuery collections aren’t live and the object is not updated when paragraph tags are added or removed from the document. You can code around this restriction by creating a DOM collection and passing it to the jQuery function when it’s required, e.g. 1234var p = document.getElementByTagName(\"p\");$(p).css(\"color\", \"blue\");// update the DOM$(p).text(\"Text changed!\"); 原文地址5 Tips for More Efficient jQuery Selectors","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"http://yoursite.com/tags/jquery/"}]},{"title":"几种布局方式（两栏布局，三栏布局，等高布局，流式布局）","date":"2014-11-17T05:26:23.000Z","path":"2014/11/17/Several-kinds-of-layout/","text":"最近面试的时候被问到了两栏或者三栏自适应等相关布局问题，现在总结一下一、左侧固定宽度，右侧自适应 1. float+margin（一侧定宽，一侧自动），代码如下 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"robots\" content=\"noindex\"&gt; &lt;title&gt;1\\. float+margin（一侧定宽，一侧自动）&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; html,body{margin:0; padding: 0;} .m-box{margin: 5px;} .m-box .left,.m-box .right { height: 200px; } .m-box .left{float:left; width:200px; background-color:#ccc; } .m-box .right{margin-left:210px; background-color:#666;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"m-box\"&gt; &lt;div class=\"left\"&gt;左&lt;/div&gt; &lt;div class=\"right\"&gt;右&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：float+margin（一侧定宽，一侧自动） 2.position: absolute+margin（一侧定宽，一侧自动），代码如下 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"robots\" content=\"noindex\"&gt; &lt;title&gt;2.position+margin（一侧定宽，一侧自动）&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; html,body{margin:0; padding: 0;} .m-box{margin: 5px;} .m-box .left,.m-box .right { height: 200px; } .m-box .left{position: absolute; width:200px; background-color:#ccc; } .m-box .right{margin-left:210px; background-color:#666;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"m-box\"&gt; &lt;div class=\"left\"&gt;左&lt;/div&gt; &lt;div class=\"right\"&gt;右&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：position+margin（一侧定宽，一侧自动） 3.float+负margin（一侧定宽，一侧自动），代码如下 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"robots\" content=\"noindex\"&gt; &lt;title&gt;3.float+负margin（一侧定宽，一侧自动）&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; html,body{margin:0; padding: 0;} .m-box .cont,.m-asider { height: 200px; } .m-box { float:left; width: 100%;} .m-box .cont {margin-left:210px;background-color: #ccc;} .m-asider {float: left; width: 200px; margin-left: -100%; background-color: #ccc;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"m-box\"&gt; &lt;div class=\"cont\"&gt;右&lt;/div&gt; &lt;/div&gt; &lt;div class=\"m-asider\"&gt;左&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：float+负margin（一侧定宽，一侧自动） 4.position: relative+margin（一侧定宽，一侧自动），代码如下 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"robots\" content=\"noindex\"&gt; &lt;title&gt;4.position: relative+margin（一侧定宽，一侧自动）&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; html,body{margin:0; padding: 0;} .g-bd1{margin:5px;} .g-sd1{position:relative;float:left;width:190px;margin-right:-190px;background: #002b36;height: 200px;} .g-mn1{float:right;width:100%;background: #116644;height: 200px;} .g-mn1c{margin-left:200px;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"g-bd1\"&gt; &lt;div class=\"g-sd1\"&gt; &lt;p&gt;左侧定宽&lt;/p&gt; &lt;/div&gt; &lt;div class=\"g-mn1\"&gt; &lt;div class=\"g-mn1c\"&gt; &lt;p&gt;右侧自适应&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：position: relative+margin（一侧定宽，一侧自动） 二、右侧固定宽度，左侧自适应 1. float+margin（一侧定宽，一侧自动），代码如下 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"robots\" content=\"noindex\"&gt; &lt;title&gt;1\\. float+margin（一侧定宽，一侧自动）&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; html,body{margin:0; padding: 0;} .m-box{margin: 5px;} .m-box .left,.m-box .right { height: 200px; line-height:200px; text-align:center; } .m-box .left{ margin-right:210px;background-color:#ccc; } .m-box .right{float:right;background-color:#666; width:200px;} p{color: #ff0000;font-weight: bolder;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"m-box\"&gt; &lt;div class=\"right\"&gt;右&lt;/div&gt; &lt;div class=\"left\"&gt;左&lt;/div&gt; &lt;/div&gt; &lt;p&gt;这里要注意两个div的顺序，一定是固定的div在前面!!!&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：float+margin（一侧定宽，一侧自动） 2.position: absolute+margin（一侧定宽，一侧自动），代码如下 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"robots\" content=\"noindex\"&gt; &lt;title&gt;2.position+margin（一侧定宽，一侧自动）&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; html,body{margin:0; padding: 0;} .m-box{margin: 5px;position: relative;} .m-box .left,.m-box .right { height: 200px;} .m-box .left{margin-right:210px; background-color:#ccc; } .m-box .right{ position: absolute; background-color:#666;width:200px;right: 0px; top: 0;} p{color: #ff0000;font-weight: bolder;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"m-box\"&gt; &lt;div class=\"left\"&gt;左&lt;/div&gt; &lt;div class=\"right\"&gt;右&lt;/div&gt; &lt;/div&gt; &lt;p&gt;这里要注意给m-box添加position: relative;属性，同时也注意给class right添加top和right属性&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：position+margin（一侧定宽，一侧自动） 3.float+负margin（一侧定宽，一侧自动），代码如下 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"robots\" content=\"noindex\"&gt; &lt;title&gt;3.float+负margin（一侧定宽，一侧自动）&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; html,body{margin:0; padding: 0;} .m-box .cont,.m-asider { height: 200px; } .m-box { float:left;margin-left: -210px; width: 100%;} .m-box .cont {background-color: #ccc;margin-left: 210px;} .m-asider {float: right; width: 200px; background-color: #ccc;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"m-box\"&gt; &lt;div class=\"cont\" &gt;左&lt;/div&gt; &lt;/div&gt; &lt;div class=\"m-asider\"&gt;右&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：float+负margin（一侧定宽，一侧自动） 4.position: relative+margin（一侧定宽，一侧自动），代码如下 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"robots\" content=\"noindex\"&gt; &lt;title&gt;4.position: relative+margin（一侧定宽，一侧自动）&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; html,body{margin:0; padding: 0;} .g-bd2{margin:5px;} .g-sd2{position:relative;float:right;width:230px;margin-left:-230px;background: #116644;height: 200px;} .g-mn2{float:left;width:100%;background: #002b36;height: 200px;} .g-mn2c{margin-right:240px;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"g-bd2\"&gt; &lt;div class=\"g-mn2\"&gt; &lt;div class=\"g-mn2c\"&gt; &lt;p&gt;左侧自适应&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"g-sd2\"&gt; &lt;p&gt;右侧定宽&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：position: relative+margin（一侧定宽，一侧自动） 三、两侧定宽，中间自适应 1.float+margin（两侧定宽，中间自适应），代码如下 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"robots\" content=\"noindex\"&gt; &lt;title&gt;1.float+margin（两侧定宽，中间自适应）&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; html,body{margin:0; padding: 0;} .left,.right,.center { height: 200px; } .left {float:left; width: 200px; background-color: #ccc;} .right {float:right; width: 200px; background-color: #ccc;} .center { margin: 0 210px; background-color: #666;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"left\"&gt;左&lt;/div&gt; &lt;div class=\"right\"&gt;右&lt;/div&gt; &lt;div class=\"center\"&gt;中&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：float+margin（两侧定宽，中间自适应） 2.position: absolute+margin（两侧定宽，中间自适应），代码如下 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"robots\" content=\"noindex\"&gt; &lt;title&gt;2.position+margin（两侧定宽，中间自适应）&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; html,body{margin:0; padding: 0;} .left,.right,.center { height: 200px;} .left {position:absolute; top:0; left:0; width: 200px; background-color: #ccc;} .right {position:absolute; top:0; right:0; width: 200px; background-color: #ccc;} .center { margin: 0 210px; background-color: #666;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"left\"&gt;左&lt;/div&gt; &lt;div class=\"right\"&gt;右&lt;/div&gt; &lt;div class=\"center\"&gt;中&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：position+margin（两侧定宽，中间自适应） 3.float+负margin（两侧定宽，中间自适应），代码如下 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"robots\" content=\"noindex\"&gt; &lt;title&gt;3.float+负margin（两侧定宽，中间自适应）&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; html,body{margin:0; padding: 0;} .left,.right,.m-box .center { height: 200px;} .m-box { float:left; width: 100%;} .m-box .center {margin:0 210px;background-color: #666;} .left,.right {float: left; width: 200px; margin-left: -100%; background-color: #ccc;} .right {margin-left: -200px;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"m-box\"&gt; &lt;div class=\"center\"&gt;中&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;左&lt;/div&gt; &lt;div class=\"right\"&gt;右&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：float+负margin（两侧定宽，中间自适应） 4.position: relative+margin（两侧定宽，中间自适应），代码如下 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"robots\" content=\"noindex\"&gt; &lt;title&gt;4.position: relative+margin（两侧定宽，中间自适应）&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; html,body{margin:0; padding: 0;} .g-bd5{margin:5px;} .g-sd51,.g-sd52{position:relative;float:left;width:230px;margin:0 -230px 0 0;background: #3e8f3e;height: 200px;} .g-sd52{float:right;width:190px;margin:0 0 0 -190px;} .g-mn5{float:left;width:100%;background: #7F9F7F;height: 200px;} .g-mn5c{margin:0 200px 0 240px;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"g-bd5\"&gt; &lt;div class=\"g-sd51\"&gt; &lt;p&gt;左侧定宽&lt;/p&gt; &lt;/div&gt; &lt;div class=\"g-mn5\"&gt; &lt;div class=\"g-mn5c\"&gt; &lt;p&gt;中间自适应&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"g-sd52\"&gt; &lt;p&gt;右侧定宽&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：position: relative+margin（两侧定宽，中间自适应） 四、左中定宽，右边自适应 1.float+margin（左中定宽，右边自适应），代码如下 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"robots\" content=\"noindex\"&gt; &lt;title&gt;1.float+margin（左中定宽，右边自适应）&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; html,body{margin:0; padding: 0;} .left,.right,.center { height: 200px; } .left {float:left; width: 200px; background-color: #ccc;} .center {float:left; width: 200px; background-color: #ccc;margin-left: 10px;} .right { margin: 0 0 0 420px;; background-color: #666;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"left\"&gt;左&lt;/div&gt; &lt;div class=\"center\"&gt;中&lt;/div&gt; &lt;div class=\"right\"&gt;右&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：float+margin（左中定宽，右边自适应） 2.position: absolute+margin（左中定宽，右边自适应），代码如下 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"robots\" content=\"noindex\"&gt; &lt;title&gt;2.position+margin（左中定宽，右边自适应）&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; html,body{margin:0; padding: 0;} .left,.right,.center { height: 200px;} .left {position:absolute; top:0; left:0; width: 200px; background-color: #ccc;} .center {position:absolute; top:0; left:210px; width: 200px; background-color: #ccc;} .right { margin-left: 420px; background-color: #666;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"left\"&gt;左&lt;/div&gt; &lt;div class=\"center\"&gt;中&lt;/div&gt; &lt;div class=\"right\"&gt;右&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：position+margin（左中定宽，右边自适应） 3.float+负margin（左中定宽，右边自适应），代码如下 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"robots\" content=\"noindex\"&gt; &lt;title&gt;3.float+负margin（左中定宽，右边自适应）&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; html,body{margin:0; padding: 0;} .left,.center,.m-box .right { height: 200px;} .m-box { float:left; width: 100%;} .m-box .right {margin-left:420px;background-color: #666;} .left,.center {float: left; width: 200px; margin-left: -100%; background-color: #ccc;} .center {margin-left: 210px;margin-top: -200px;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"m-box\"&gt; &lt;div class=\"right\"&gt;右&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;左&lt;/div&gt; &lt;div class=\"center\"&gt;中&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：float+负margin（左中定宽，右边自适应） 五、右中定宽，左边自适应 1.float+margin（右中定宽，左边自适应），代码如下 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"robots\" content=\"noindex\"&gt; &lt;title&gt;1.float+margin（右中定宽，左边自适应）&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; html,body{margin:0; padding: 0;} .left,.right,.center { height: 200px; } .center,.right {float:right; width: 200px; background-color: #ccc;} .center{margin-right: 10px;} .left { margin-right: 420px; background-color: #666;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"right\"&gt;右&lt;/div&gt; &lt;div class=\"center\"&gt;中&lt;/div&gt; &lt;div class=\"left\"&gt;左&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：float+margin（右中定宽，左边自适应） 2.position: absolute+margin（右中定宽，左边自适应），代码如下 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"robots\" content=\"noindex\"&gt; &lt;title&gt;2.position: absolute+margin（右中定宽，左边自适应）&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; html,body{margin:0; padding: 0;} .left,.right,.center { height: 200px;} .left {margin-right: 420px; background-color: #ccc;} .center {position:absolute; top:0; right:210px; width: 200px; background-color: #ccc;} .right { position:absolute;top:0; right:0;width: 200px; background-color: #666;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"left\"&gt;左&lt;/div&gt; &lt;div class=\"center\"&gt;中&lt;/div&gt; &lt;div class=\"right\"&gt;右&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：position: absolute+margin（右中定宽，左边自适应） 3.float+负margin（右中定宽，左边自适应），代码如下 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"robots\" content=\"noindex\"&gt; &lt;title&gt;3.float+负margin（右中定宽，左边自适应）&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; html,body{margin:0; padding: 0;} .right,.center,.m-box .left { height: 200px;} .m-box { float:left; width: 100%;} .m-box .left {background-color: #666;margin-right: 420px;} .right,.center {float: right; width: 200px; background-color: #ccc;margin-top: -200px;} .center {margin-right: 210px;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"m-box\"&gt; &lt;div class=\"left\"&gt;左&lt;/div&gt; &lt;/div&gt; &lt;div class=\"center\"&gt;中&lt;/div&gt; &lt;div class=\"right\"&gt;右&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：float+负margin（右中定宽，左边自适应） 未完，待续 参考资料： 老生长谈：css实现右侧固定宽度，左侧宽度自适应 两栏布局，三栏布局，等高布局，流式布局 我熟知的三种三栏网页宽度自适应布局方法 NEC代码库 note：display：flex，grid，table","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"layout","slug":"layout","permalink":"http://yoursite.com/tags/layout/"}]},{"title":"wordpress 插件-Easy FancyBox","date":"2014-11-10T03:39:06.000Z","path":"2014/11/10/wordpress-plugin-of-EasyFancyBox/","text":"今天写文章的时候，发现图片在生成的文章中实在是不忍直视，之前也碰到过这个问题，一直没管，今天实在是忍不了，所以上网查了下，最后选择了一个简单易操作的插件，Easy FancyBox 步骤一、写好文章后，在图片上编辑 步骤二、在图片编辑页面修改图片地址 最终效果如下 &nbsp;","tags":[{"name":"wordpress","slug":"wordpress","permalink":"http://yoursite.com/tags/wordpress/"},{"name":"plugin","slug":"plugin","permalink":"http://yoursite.com/tags/plugin/"}]},{"title":"nodejs资料收集","date":"2014-10-13T08:53:32.000Z","path":"2014/10/13/nodejs-learning-materials/","text":"从零开始nodejs系列文章","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"nodejs搭建静态文件的Web服务器","date":"2014-10-08T14:13:40.000Z","path":"2014/10/08/Nodejs-construct-WebServer/","text":"参考网址：Node.JS static file web server，代码在下面，默认打开的是index.html文件12345678910111213141516171819202122232425262728293031323334353637var http = require(\"http\"), url = require(\"url\"), path = require(\"path\"), fs = require(\"fs\") port = process.argv[2] || 8888;http.createServer(function(request, response) &#123; var uri = url.parse(request.url).pathname , filename = path.join(process.cwd(), uri); path.exists(filename, function(exists) &#123; if(!exists) &#123; response.writeHead(404, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"404 Not Found\\n\"); response.end(); return; &#125; if (fs.statSync(filename).isDirectory()) filename += '/index.html'; fs.readFile(filename, \"binary\", function(err, file) &#123; if(err) &#123; response.writeHead(500, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(err + \"\\n\"); response.end(); return; &#125; response.writeHead(200); response.write(file, \"binary\"); response.end(); &#125;); &#125;);&#125;).listen(parseInt(port, 10));console.log(\"Static file server running at\\n =&amp;gt; http://localhost:\" + port + \"/\\nCTRL + C to shutdown\"); &nbsp;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"css3学习之transform","date":"2014-09-16T05:48:12.000Z","path":"2014/09/16/css3-of-transform/","text":"transform属性适用于2D或3D变换的元素。这个属性允许你变形、旋转、缩放、倾斜元素。 transform的兼容情况: 对2D的兼容情况： 对3D的兼容情况： 对svg的兼容情况： 在CSS3中transform主要包括以下几种：旋转rotate、扭曲skew、缩放scale和移动translate以及矩阵变形matrix，语法如下： transform: none|transform-functions; none:表示不进行变换。transform-function表示一个或多个变换函数，以空格分开；换句话说就是我们同时对一个元素进行transform的多种属性操作，例如rotate、scale、translate三种，但这里需要提醒大家的，以往我们叠加效果都是用逗号（“，”）隔开，但transform中使用多个属性时却需要有空格隔开。transform-origin可以改变transform过程中相对的基点。 一、旋转（rotate） rotate(angle)定义 2D 旋转，在参数中规定角度。rotate3d(x,y,z,angle)定义 3D 旋转。rotateX(angle)定义沿着 X 轴的 3D 旋转。rotateY(angle)定义沿着 Y 轴的 3D 旋转。rotateZ(angle)定义沿着 Z 轴的 3D 旋转。 See the Pen ogNxwX by dsky . 二、移动（translate） translate(x,y)定义 2D 转换。translate3d(x,y,z)定义 3D 转换。(与translate效果类似)translateX(x)定义转换，只是用 X 轴的值。translateY(y)定义沿着 Y 轴的 3D 旋转。translateZ(z)定义 3D 转换，只是用 Z 轴的值。（无效果） See the Pen azbZqJ by dsky . 三、缩放（scale） scale(x,y) 定义 2D 缩放转换。 scale3d(x,y,z) 定义 3D 缩放转换。 scaleX(x) 通过设置 X 轴的值来定义缩放转换。 scaleY(y) 通过设置 Y 轴的值来定义缩放转换。 scaleZ(z) 通过设置 Z 轴的值来定义 3D 缩放转换。 See the Pen gbOMBZ by dsky . 四、扭曲（skew） scale(x,y) 定义 2D 缩放转换。 scale3d(x,y,z) 定义 3D 缩放转换。 scaleX(x) 通过设置 X 轴的值来定义缩放转换。 scaleY(y) 通过设置 Y 轴的值来定义缩放转换。 scaleZ(z) 通过设置 Z 轴的值来定义 3D 缩放转换。","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"},{"name":"transform","slug":"transform","permalink":"http://yoursite.com/tags/transform/"}]},{"title":"node 学习之路（1）- 安装","date":"2014-09-15T06:16:36.000Z","path":"2014/09/15/nodejs-learning-1/","text":"1、在官网http://nodejs.org/选择下载对应系统的安装文件后启动命令行npm，出现 Error: ENOENT, stat ‘C:\\Users\\duti\\AppData\\Roaming\\npm’错误， 解决办法：在对应文字新建npm文件夹就行，这是最新版node在win7中的错误 2、输入命令出现 npm ERR! install Couldn’t read dependenciesnpm ERR! package.json ENOENT, open ‘C:\\Users\\duti\\Desktop\\2048\\package.json’npm ERR! package.json This is most likely not a problem with npm itself.npm ERR! package.json npm can’t find a package.json file in your current directory. npm ERR! System Windows_NT 6.1.7601npm ERR! command “C:\\nodejs\\\\node.exe” “C:\\nodejs\\node_modules\\npm\\bin\\npm-cli.js” “install”npm ERR! cwd C:\\Users\\duti\\Desktop\\2048npm ERR! node -v v0.10.31npm ERR! npm -v 1.4.23npm ERR! path C:\\Users\\duti\\Desktop\\2048\\package.jsonnpm ERR! code ENOPACKAGEJSONnpm ERR! errno 34npm ERR!npm ERR! Additional logging details can be found in:npm ERR! C:\\Users\\duti\\Desktop\\2048\\npm-debug.lognpm ERR! not ok code 0 这是因为缺少package.json文件，这时候只要在项目根目录新建一个package.json文件，文件中包含安装的module和版本就行了","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"AngularJS 中文资料+工具+库+Demo 大搜集","date":"2014-08-28T02:53:20.000Z","path":"2014/08/28/angularJS-learning-materials/","text":"中文学习资料：中文资料且成系统的就这么多，优酷上有个中文视频。 http://www.cnblogs.com/lcllao/archive/2012/10/18/2728787.html 翻译的官方的Guide http://www.ituring.com.cn/minibook/303 翻译的官方的tutorial http://www.lovelucy.info/angularjs-best-practices.html Angular最佳实践 http://zouyesheng.com/angular.html angularjs的学习笔记 http://www.sunzhongwei.com/angularjs.html 另一个网友的笔记 https://github.com/jmcunningham/AngularJS-Learning/blob/master/ZH-CN.md github上的一个资料整理 AngularJS体验式编程系列文章2013年度最强AngularJS资源合集 工具：AngularJS WebInspector Extension for Chrome https://github.com/yeoman/generator-angular YeoMan的帮助创建angularjs APP https://github.com/johnlindquist/angularjs-plugin 适合Idea、WebStorm等Intellij平台的IDE插件 https://github.com/angular-ui/AngularJS-sublime-package Angularjs的Sublime插件 库：http://angular-ui.github.io/ AngularUI - The companion suite for AngularJS http://twilson63.github.io/ngUpload/ 上传文件的指令 http://binarymuse.github.io/ngInfiniteScroll/ 无限下拉 https://github.com/btford/angular-dragon-drop 拖拽的指令 Demo：可以参考参考怎么组织代码 https://github.com/tastejs/todomvc 帮助你选择MV* 框架，其中有一个angularjs的demo https://github.com/yearofmoo-articles/AngularJS-Animation-Article https://github.com/zensh/jsgen angularjs+nodejs开发的一套社区软件 https://github.com/btford/angular-express-seed angularjs + express 骨架，想用这两者结合开发的可以参考下怎么组织代码结构 https://github.com/btford/angular-express-blog 用上面的框架写的一个简单的Blog系统 https://github.com/bennadel/AngularJS-Routing AngularJS - Deep Routing Example https://github.com/GoogleChrome/wReader-app RSS Reader written using AngularJS https://github.com/btford/angular-socket-io-im angular + socket.io 开发的简单的Demo https://github.com/saberma/19wu 19屋源码 rails + angularjs https://github.com/curran/screencasts/tree/gh-pages/introToAngular Introduction to Angular.js in 50 Examples 视频：https://www.youtube.com/watch?v=TRrL5j3MIvo Introduction to Angular.js in 50 Examples (part 1) https://www.youtube.com/watch?v=6J08m1H2BME Introduction to Angular.js in 50 Examples (part 2) &nbsp; 文章转自[friskfly](http://www.cnblogs.com/friskfly/p/3176735.html)","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"angularjs","slug":"angularjs","permalink":"http://yoursite.com/tags/angularjs/"}]},{"title":"css3学习之transitions","date":"2014-08-12T16:17:42.000Z","path":"2014/08/13/css3-of-transitions/","text":"css的transition允许css的属性值在一定的时间区间内平滑地过渡。这种效果可以在鼠标单击、获得焦点、被点击或对元素任何改变中触发，并圆滑地以动画效果改变CSS的属性值。 transitions的兼容情况 css-transitions[/caption] transitions的属性： transition: [ transition-property || transition-duration || transition-timing-function || transition-delay ] transition-property：要改变的css属性； transition-duration：用来完成整个变化所需要的时间，单位是秒或则毫秒，默认是0，表示不会有变化； transition-timing-function：变化过程中的速度，默认是ease； transition-delay：开始变化所需要等待的时间，单位是秒或则毫秒，默认是0； 在上面的属性中，transition-timing-function需要注意一下它的属性： linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。ease 规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。ease-in 规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。ease-out 规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。ease-in-out 规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。 具体可以参考这篇文章A Look Into: Cubic-Bezier In CSS3 Transition JS Bin on jsbin.com 当属性值列表长度不一致时以 transition-property 的值列表长度为标准，如果某个属性值列表长度短于它的，则重复其值以长度一致， 例如:1234div &#123; transition-property: opacity, left, top, height; transition-duration: 3s, 5s;&#125; 将按下面这样处理:1234div &#123; transition-property: opacity, left, top, height; transition-duration: 3s, 5s, 3s, 5s;&#125; 类似地，如果某个属性的值列表长于 transition-property 的，将被截短。 例如:1234div &#123; transition-property: opacity, left; transition-duration: 3s, 5s, 2s, 1s;&#125; 将按下面这样处理:1234div &#123; transition-property: opacity, left; transition-duration: 3s, 5s;&#125;","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"},{"name":"transitions","slug":"transitions","permalink":"http://yoursite.com/tags/transitions/"}]},{"title":"禁用 Google Fonts，加快 WordPress 打开速度","date":"2014-07-30T11:28:24.000Z","path":"2014/07/30/enable-googlefont-to-speed-wordpress/","text":"最近google被墙，博客因为调用了google的font导致加载缓慢，检测速度为23s左右，所以上网搜了一下解决方法，解决办法如下 方法一： //移除google fonts api function remove_open_sans_from_wp_core() { // 移除 open-sans 字体 wp_deregister_style( 'open-sans' ); wp_register_style( 'open-sans', false ); wp_enqueue_style('open-sans',''); // 移除 bushwick-lato 字体 wp_deregister_style( 'bushwick-lato' ); wp_register_style( 'bushwick-lato', false ); wp_enqueue_style('bushwick-lato',''); } add_action( 'init', 'remove_open_sans_from_wp_core' ); 方法二： add_filter( 'gettext_with_context', 'wpjam_disable_google_fonts', 888, 4); function wpjam_disable_google_fonts($translations, $text, $context, $domain ) { $google_fonts_contexts = array('Open Sans font: on or off','Lato font: on or off','Source Sans Pro font: on or off','Bitter font: on or off'); if( $text == 'on' &amp;&amp; in_array($context, $google_fonts_contexts ) ){ $translations = 'off'; } return $translations; } 方法三： 经检测，上述方法不太有效，所以楼主综合了一下网上的方法，总结出了第三个方法 a、在页面点击右键，查看源码，找到googlefont的那段css源码 然后打开这段代码（需要翻墙，楼主把代码贴在这，仅供参考，不一定适合所有主题） @font-face { font-family: 'Bitter'; font-style: normal; font-weight: 400; src: local('Bitter-Regular'), url(http://fonts.gstatic.com/s/bitter/v6/X7ZHlbakqnL_pOH265Q8kg.woff2) format('woff2'), url(http://fonts.gstatic.com/s/bitter/v6/s9gJB935qk_YG8d-lnTdvA.woff) format('woff'); } @font-face { font-family: 'Lora'; font-style: normal; font-weight: 400; src: local('Lora'), local('Lora-Regular'), url(http://themes.googleusercontent.com/static/fonts/lora/v7/YQixcBt4h8DmZwK9P1bhEQ.woff) format('woff'); } @font-face { font-family: 'Lora'; font-style: normal; font-weight: 700; src: local('Lora Bold'), local('Lora-Bold'), url(http://themes.googleusercontent.com/static/fonts/lora/v7/ygC2Fp8ylofzQwABjiUjiA.woff) format('woff'); } @font-face { font-family: 'Lora'; font-style: italic; font-weight: 400; src: local('Lora Italic'), local('Lora-Italic'), url(http://themes.googleusercontent.com/static/fonts/lora/v7/dkGoamsR8Uep2XQql1FplA.woff) format('woff'); } @font-face { font-family: 'Lora'; font-style: italic; font-weight: 700; src: local('Lora Bold Italic'), local('Lora-BoldItalic'), url(http://themes.googleusercontent.com/static/fonts/lora/v7/1wR3aOJ69QwyZ9B-WDmIqT8E0i7KZn-EPnyo3HZu7kw.woff) format('woff'); } b、点开文中的font字体链接，下载font，将下载好的woff文件放在\\wp-includes\\fonts\\google 目录中， google是自建的，然后字体可能也需要翻墙，所以博主把字体链接也放在底下 百度云盘地址：http://pan.baidu.com/s/1hqqYm2o c、将上面的css代码保存，命名为google-font.css，并放在\\wp-includes\\css目录中，css代码如下 @font-face { font-family: 'Bitter'; font-style: normal; font-weight: 400; src: local('Bitter-Regular'), url(../fonts/google/X7ZHlbakqnL_pOH265Q8kg.woff2) format('woff2'), url(../fonts/google/s9gJB935qk_YG8d-lnTdvA.woff) format('woff'); } @font-face { font-family: 'Lora'; font-style: normal; font-weight: 400; src: local('Lora'), local('Lora-Regular'), url(../fonts/google/YQixcBt4h8DmZwK9P1bhEQ.woff) format('woff'); } @font-face { font-family: 'Lora'; font-style: normal; font-weight: 700; src: local('Lora Bold'), local('Lora-Bold'), url(../fonts/google/ygC2Fp8ylofzQwABjiUjiA.woff) format('woff'); } @font-face { font-family: 'Lora'; font-style: italic; font-weight: 400; src: local('Lora Italic'), local('Lora-Italic'), url(../fonts/google/dkGoamsR8Uep2XQql1FplA.woff) format('woff'); } @font-face { font-family: 'Lora'; font-style: italic; font-weight: 700; src: local('Lora Bold Italic'), local('Lora-BoldItalic'), url(../fonts/google/1wR3aOJ69QwyZ9B-WDmIqT8E0i7KZn-EPnyo3HZu7kw.woff) format('woff'); } d、修改 \\wp-includes\\script-loader.php 文件，找到 $open_sans_font_url = “//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,300,400,600&amp;subset=$subsets”; 换成： $open_sans_font_url = “/wp-includes/css/google-font.css”; e、最关键一步 在主题文件夹中，找到 $fonts_url = add_query_arg( $query_args, “//fonts.googleapis.com/css” ); 这段代码，将地址替换成你的google-font.css的地址 改完后博主用百度测速工具检测，页面打开速度3.6s，自此，问题解决 文章代码来源于：我爱水煮鱼，清风迅来，Qiengo &nbsp;","tags":[{"name":"wordpress","slug":"wordpress","permalink":"http://yoursite.com/tags/wordpress/"}]},{"title":"css学习之css选择器（3）","date":"2014-07-28T16:33:29.000Z","path":"2014/07/29/css-selector-3/","text":"1、CSS :first-child Selector版本：css2 用法：用于选择父级的第一个子元素 支持版本： pc：ie7+、all chrome versions、all firefox versions、all safair versions、all opera versions mobile：all ios safair versions、all opera mini versions、all Android Browser versions eg： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;dsky&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; p:first-child{background:#666;} div p:first-child{background:#ddd;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;body的第一个p&lt;/p&gt; &lt;p&gt;body的第二个p&lt;/p&gt; &lt;div&gt; &lt;p&gt;div的第一个p&lt;/p&gt; &lt;p&gt;div的第二个p&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：http://jsbin.com/malik/1 2、CSS3 :last-child Selector版本：css3 用法：用于选择父级的最后一个子元素 支持版本： pc：ie8+、all chrome versions、all firefox versions、all safair versions、all opera versions mobile：all ios safair versions、all opera mini versions、all Android Browser versions eg： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;dsky&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; p:last-child{background:#666;} div p:last-child{background:#ddd;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;div的第一个p,body的第一个p&lt;/p&gt; &lt;p&gt;div的第二个p,body的第二个p&lt;/p&gt; &lt;/div&gt; &lt;p&gt;body的第三个p&lt;/p&gt; &lt;p&gt;body的第四个p&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：http://jsbin.com/malik/3 3、CSS3 :not Selector版本：css3用法：用于选择除了选中元素以外的元素 支持版本： pc：ie8+、all chrome versions、all firefox versions、all safair versions、all opera versions mobile：all ios safair versions、all opera mini versions、all Android Browser versions eg： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;dsky&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; p{background:#ddd;} div:not(p){background:#666;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;body的p元素&lt;/p&gt; &lt;div&gt; &lt;span&gt;span元素&lt;/span&gt; &lt;ul&gt; &lt;li&gt;li元素&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;div的p元素&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：http://jsbin.com/yehile/1 4、CSS3 :nth-child() Selector版本：css3用法：th-child(n) selector matches every element that is the nth child, regardless of type, of its parent.n can be a number, a keyword, or a formula. 支持版本： pc：ie8+、all chrome versions、all firefox versions、all safair versions、all opera versions mobile：all ios safair versions、all opera mini versions、all Android Browser versions eg： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;dsky&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; p:nth-child(2){background:#ddd;} ul li:nth-child(odd){background:#333;} ul li:nth-child(even){background:red;} .div1span span:nth-child(2n+1){background:#666;} .div2span span:nth-child(2n+1){background:#f;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;第一个p&lt;/p&gt; &lt;p&gt;第二个p&lt;/p&gt; &lt;p&gt;第三个p&lt;/p&gt; &lt;ul&gt; &lt;li&gt;第一个li&lt;/li&gt; &lt;li&gt;第二个li&lt;/li&gt; &lt;li&gt;第三个li&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"div1span\"&gt; &lt;span&gt;第一个span&lt;/span&gt;&lt;br/&gt; &lt;span&gt;第二个span&lt;/span&gt;&lt;br/&gt; &lt;span&gt;第三个span&lt;/span&gt;&lt;br/&gt; &lt;span&gt;第四个span&lt;/span&gt;&lt;br/&gt; &lt;span&gt;第五个span&lt;/span&gt; &lt;/div&gt; &lt;div class=\"div2span\"&gt; &lt;span&gt;第一个span&lt;/span&gt; &lt;span&gt;第二个span&lt;/span&gt; &lt;span&gt;第三个span&lt;/span&gt; &lt;span&gt;第四个span&lt;/span&gt; &lt;span&gt;第五个span&lt;/span&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：http://jsbin.com/yehile/2","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"}]},{"title":"css学习之css选择器（2）","date":"2014-07-14T15:53:04.000Z","path":"2014/07/14/css-selector-2/","text":"1、CSS [attribute] Selector版本：css2 用法：用于选择具有指定属性的元素 支持版本： pc：ie7+、all chrome versions、all firefox versions、all safair versions、all opera versions mobile：all ios safair versions、all opera mini versions、all Android Browser versions eg: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;CSS [attribute] Selector&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; a[target] { background-color:yellow; } a[title] { background-color:red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"http://dsky.pw\" title=\"\"&gt;我没有target,我有title&lt;/a&gt; &lt;a href=\"http://dsky.pw\" target=\"_blank\"&gt;我有target，我没有title&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：http://jsbin.com/qiqoq/1 2、CSS [attribute=value] Selector版本：css2 用法：用于选择拥有指定属性的元素 支持版本： pc：ie7+、all chrome versions、all firefox versions、all safair versions、all opera versions mobile：all ios safair versions、all opera mini versions、all Android Browser versions eg： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;CSS [attribute=value] Selector&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; a[target] { background-color:yellow; } a[target=_blank] { background-color:red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"http://dsky.pw\"&gt;dsky的小屋&lt;/a&gt; &lt;a href=\"http://dsky.pw\" target=\"_blank\"&gt;我是target=\"_blank\"&lt;/a&gt; &lt;a href=\"http://dsky.pw\" target=\"_top\"&gt;我是target=\"_top\"&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：http://jsbin.com/qiqoq/2 3、CSS [attribute~=value] Selector版本：css2 用法：选择含有指定属性的元素 支持版本： pc：ie7+、all chrome versions、all firefox versions、all safair versions、all opera versions mobile：all ios safair versions、all opera mini versions、all Android Browser versions eg： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;CSS [attribute~=value] Selector&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; a[title~=dsky1] { background: yellow; } a[title~=dt2] { background: red; } a[title~=dsky3] { background: #666; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"http://dsky.pw\" title=\"dsky1 dt\"&gt;dsky的小屋1&lt;/a&gt; &lt;a href=\"http://dsky.pw\" title=\"dsky dt2\"&gt;dsky的小屋2&lt;/a&gt; &lt;a href=\"http://dsky.pw\" title=\"dsky3 dt\"&gt;dsky的小屋3&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 预览：http://jsbin.com/qiqoq/3 4、CSS [attribute|=value] Selector版本：css2 用法：选择元素属性值以指定值开始的元素 支持版本： pc：ie7+、all chrome versions、all firefox versions、all safair versions、all opera versions mobile：all ios safair versions、all opera mini versions、all Android Browser versions eg： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;CSS [attribute|=value] Selector&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; [lang|=en] { background:yellow; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p lang=\"en\"&gt;以en开头&lt;/p&gt; &lt;p lang=\"en-us\"&gt;以en开头&lt;/p&gt; &lt;p lang=\"en-gb\"&gt;以en开头&lt;/p&gt; &lt;p lang=\"us\"&gt;没有以en开头&lt;/p&gt; &lt;p lang=\"no\"&gt;没有以en开头&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; &lt;/body&gt; &lt;/html&gt; 预览：http://jsbin.com/qiqoq/4","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"css学习之css选择器（1）","date":"2014-07-07T15:21:00.000Z","path":"2014/07/07/css-selector-1/","text":"1、CSS element&gt;element Selector版本：css2 用法：选取当前父元素的直接子元素 支持版本： pc：ie7+、all chrome versions、all firefox versions、all safair versions、all opera versions mobile：all ios safair versions、all opera mini versions、all Android Browser versions eg： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;CSS element&gt;element Selector&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; div&gt;p { background-color:yellow; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Welcome to My Homepage&lt;/h1&gt; &lt;div&gt; &lt;h2&gt;My name is Donald&lt;/h2&gt; &lt;p&gt;yellow1&lt;/p&gt; &lt;p&gt;yellow2&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;&lt;p&gt;I will not be styled.&lt;/p&gt;&lt;/span&gt; &lt;/div&gt; &lt;p&gt;My best friend is Mickey.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：http://jsbin.com/yacoba/1 2、CSS element+element Selector版本：css2 用法：跟着第一个元素的下一个元素 支持版本： pc：ie7+、all chrome versions、all firefox versions、all safair versions、all opera versions mobile：all ios safair versions、all opera mini versions、all Android Browser versions eg： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;CSS element+element Selector&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; div&gt;p { background-color:yellow; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;I'm yellow.&lt;/p&gt; &lt;/div&gt; &lt;p&gt;I'm not yellow.&lt;/p&gt; &lt;p&gt;I'm not yellow.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：http://jsbin.com/yacoba/2 3、CSS3 element1~element2 Selector用法：跟着第一个元素的下面的所有元素 支持版本： pc：ie7+、all chrome versions、all firefox versions、all safair versions、all opera versions mobile：all ios safair versions、all opera mini versions、all Android Browser versions eg： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;CSS3 element1~element2 Selector&lt;/title&gt; &lt;style id=\"jsbin-css\"&gt; div~p { background-color:yellow; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;I'm not yellow.&lt;/p&gt; &lt;/div&gt; &lt;p&gt;I'm yellow.&lt;/p&gt; &lt;p&gt;I'm yellow.&lt;/p&gt; &lt;span&gt;I'm not yellow.&lt;/span&gt; &lt;div&gt; &lt;p&gt;I'm not yellow.&lt;/p&gt; &lt;/div&gt; &lt;p&gt;I'm yellow.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 预览地址：http://jsbin.com/yacoba/3","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"jquery 学习之toggle(),toggleClass(),fadeToggle()，slideToggle()","date":"2014-07-06T14:08:07.000Z","path":"2014/07/06/jquery-learning-of-toggle/","text":"toggle()功能：显示或隐藏匹配的元素 说明：匹配的元素将被揭示或立即隐藏，没有动画，通过改变CSS显示属性。如果在初始显示的元素，它会被隐藏;如果隐藏，它将会显示。 display属性被保存并在需要时恢复。如果元素具有内嵌的显示值，然后通过隐藏和显示，它会再次被内联显示。 持续时间是以毫秒为单位;值越高，动画越慢，不是越快。字符串’fast’和’慢’可分别提供给代表200持续时间和600毫秒。 如果提供，则回调被触发，一旦动画完成。这对于将不同的动画一起在序列是有用的。回调不发送任何参数，但它被设置为DOM元素被动画。如果多个元素的动画，需要注意的是回调执行每一次匹配的元素，没有一次为动画作为一个整体是很重要的。 $(selector).trigger(function)The toggle() method was deprecated in jQuery version 1.8, and removed in version 1.9. eg:123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"http://code.jquery.com/jquery-1.8.3.min.js\"&gt;&lt;/script&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;toggle&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;点击我试试&lt;/p&gt;&lt;script&gt;$(\"p\").toggle( function()&#123;$(\"p\").css(&#123;\"color\":\"red\"&#125;);&#125;, function()&#123;$(\"p\").css(&#123;\"color\":\"blue\"&#125;);&#125;, function()&#123;$(\"p\").css(&#123;\"color\":\"green\"&#125;);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 预览地址：http://jsbin.com/yedeku/1 $(selector).toggle(speed,easing,callback)eg：1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=”http://code.jquery.com/jquery-1.9.1.min.js\"&gt;&lt;/script&gt; &lt;meta charset=”utf-8”&gt; &lt;title&gt;toggle&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Hello&lt;/p&gt;&lt;p style=”display: none”&gt;Good Bye&lt;/p&gt;&lt;button&gt;click me&lt;/button&gt;&lt;script&gt;$(document).ready(function()&#123; $(“button”).click(function()&#123; $(“p”).toggle(300); &#125;);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代码地址：http://jsbin.com/yedeku/2 toggleClass()toggleClass,切换class(一个或多个)，这里有两种用法 toggleClass(Class),在一个Class间切换 $(ClassA,ClassB).toggleClass(ClassA,ClassB)，在两个ClassA,ClassB之前切换 查看DEMO fadeToggle().fadeToggle()方法执行匹配元素的不透明度动画。当被可见元素调用时，元素不透明度一旦达到0，display样式属性设置为none，所以元素不再影响页面的布局。 slideToggle().slideToggle()方法将给匹配元素的高度的动画，这会导致页面中，在这个元素下面的内容往下或往上滑。display属性值保存在jQuery的数据缓存中，所以display可以方便以后可以恢复到其初始值。如果一个元素的display属性值为inline，然后是隐藏和显示，这个元素将再次显示inline。当一个隐藏动画后，高度值达到0的时候，display 样式属性被设置为none，以确保该元素不再影响页面布局。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"http://yoursite.com/tags/jquery/"}]},{"title":"li隔行显示不同颜色","date":"2014-07-01T12:35:05.000Z","path":"2014/07/01/Li-interlaced-show-different-colors/","text":"css方法： 1 1 1 1 1 &nbsp; 预览地址：http://jsbin.com/pokan/2/ jquery方法： 1 1 1 1 1 // &nbsp; 预览地址：http://jsbin.com/pokan/1/","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"http://yoursite.com/tags/jquery/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"关于块级元素和行内元素","date":"2014-06-26T13:55:28.000Z","path":"2014/06/26/inline-an-block-element/","text":"常见的行内元素：a – 锚点，abbr – 缩写，acronym – 首字，b – 粗体(不推荐)，bdo – bidi override，big – 大字体，br – 换行，cite – 引用，code – 计算机代码(在引用源码的时候需要)，dfn – 定义字段，em – 强调，font – 字体设定(不推荐)，i – 斜体，img – 图片，input – 输入框，kbd – 定义键盘文本，label – 表格标签，q – 短引用，s – 中划线(不推荐)，samp – 定义范例计算机代码，select – 项目选择，small – 小字体文本，span – 常用内联容器，定义文本内区块，strike – 中划线，strong – 粗体强调，sub – 下标，sup – 上标，textarea – 多行文本输入框，tt – 电传文本，u – 下划线 常用的行内元素要记住：a、span、img、input、lable、select、strong、textarea 常见的块级元素：address – 地址，blockquote – 块引用，center – 举中对齐块，dir – 目录列表，div – 常用块级容器，也是CSS layout的主要标签，dl – 定义列表，fieldset – form控制组，form – 交互表单，h1 – 大标题，h2 – 副标题，h3 – 3级标题，h4 – 4级标题，h5 – 5级标题，h6 – 6级标题，hr – 水平分隔线，isindex – input prompt，menu – 菜单列表，noframes – frames可选内容，（对于不支持frame的浏览器显示此区块内容，noscript – 可选脚本内容（对于不支持script的浏览器显示此内容），ol – 有序表单，p – 段落，pre – 格式化文本，table – 表格，ul – 无序列表 常用的块级元素要记住：div、h1~h6、dl、ul、ol 行内元素与块级元素有什么不同？ 区别一：块级：块级元素会独占一行，默认情况下宽度自动填满其父元素宽度行内：行内元素不会独占一行，相邻的行内元素会排在同一行。其宽度随内容的变化而变化。 区别二：块级：块级元素可以设置宽高行内：行内元素不可以设置宽高 区别三：块级：块级元素可以设置margin，padding行内：行内元素水平方向的margin-left; margin-right; padding-left; padding-right;可以生效。但是竖直方向的margin-bottom; margin-top; padding-top; padding-bottom;却不能生效。 区别四：块级：块级元素可以容纳行内元素和其他块元素行内：行内元素只能容纳文本或者其他内联元素 至于为什么width属性对行内元素无效，可以参阅CSS2标准中关于width的定义 要解决行内元素宽度的问题，我们介绍一个属性，inline-block display:inline-block将对象呈递为内联对象，但是对象的内容作为块对象呈递。旁边的内联对象会被呈递在同一行内，允许空格。 inline-block的元素特点： 将对象呈递为内联对象，但是对象的内容作为块对象呈递。旁边的内联对象会被呈递在同一行内，允许空格。(准确地说，应用此特性的元素呈现为内联对象，周围元素保持在同一行，但可以设置宽度和高度地块元素的属性) 并不是所有浏览器都支持此属性，目前支持的浏览器有：Opera、Safari在IE中对内联元素使用display:inline-block，IE是不识别的，但使用display:inline-block在IE下会触发layout，从而使内联元素拥有了display:inline-block属性的表症。从上面的这个分析，也不难理解为什么IE下，对块元素设置display:inline-block属性无法实现inline-block的效果。这时块元素仅仅是被display:inline-block触发了layout，而它本就是行布局，所以触发后，块元素依然还是行布局，而不会如Opera中块元素呈递为内联对象。 IE下块元素如何实现display:inline-block的效果？ 有两种方法：1、先使用display:inline-block属性触发块元素，然后再定义display:inline，让块元素呈递为内联对象（两个display要先后放在两个CSS声明中才有效果，这是IE的一个经典bug，如果先定义了display:inline-block，然后再将display设回inline或block，layout不会消失）。代码如下（…为省略的其他属性内容）： div {display:inline-block;…}div {display:inline;} 2、直接让块元素设置为内联对象呈递（设置属性display:inline），然后触发块元素的layout（如：zoom:1等）。代码如下： div {display:inline; zoom:1;…} 下面附一张inline-block的支持情况 [caption id=”attachment_156” align=”aligncenter” width=”625”] CSS inline-blockd 的游览器支持情况[/caption] &nbsp;","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"css处理文字溢出显示为省略号，兼容ie,ff,chrome","date":"2014-06-25T14:03:19.000Z","path":"2014/06/25/css-overflow-with-ellipsis/","text":".limit1{ display:block;}.limit1,.limit2,.limit3{ max-width:100px; white-space:nowrap; text-overflow:ellipsis; -o-text-overflow:ellipsis; overflow:hidden;} &lt;span class=”limit1”&gt;文字溢出文字溢出文字溢出文字溢出&lt;/span&gt;&lt;p class=”limit2”&gt;文字溢出文字溢出文字溢出文字溢出&lt;/p&gt;&lt;span class=”limit3”&gt;文字溢出文字溢出文字溢出文字溢出&lt;/span&gt;注意：标签必须为block属性才行，不然不会隐藏，原因是width属性对行内元素span失效，至于失效原因，下次再另开一帖说明 *ff必须在28+ 预览地址：http://jsbin.com/seyaf/1/","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"bootstrap of .container，.row，.col-*","date":"2014-06-24T03:19:24.000Z","path":"2014/06/24/ement-of-bootstrap/","text":"“行（row）”必须包含在.container中，以便为其赋予合适的排列（aligment）和内补（padding）。 使用“行（row）”在水平方向创建一组“列（column）”。 你的内容应当放置于“列（column）”内，而且，只有“列（column）”可以作为行（row）”的直接子元素，例如.col-*。 类似Predefined grid classes like .row and .col-xs-4 这些预定义的栅格class可以用来快速创建栅格布局。Bootstrap源码中定义的mixin也可以用来创建语义化的布局。 通过设置padding从而创建“列（column）”之间的间隔（gutter）。然后通过为第一和最后一样设置负值的margin从而抵消掉padding的影响。 栅格系统中的列是通过指定1到12的值来表示其跨越的范围。例如，三个等宽的列可以使用三个.col-xs-4来创建，且同一个row中.col-*的数字和必为12。 &lt;div class=”row”&gt;&lt;div class=”col-md-1”&gt;.col-md-1&lt;/div&gt;&lt;div class=”col-md-1”&gt;.col-md-1&lt;/div&gt;&lt;div class=”col-md-1”&gt;.col-md-1&lt;/div&gt;&lt;div class=”col-md-1”&gt;.col-md-1&lt;/div&gt;&lt;div class=”col-md-1”&gt;.col-md-1&lt;/div&gt;&lt;div class=”col-md-1”&gt;.col-md-1&lt;/div&gt;&lt;div class=”col-md-1”&gt;.col-md-1&lt;/div&gt;&lt;div class=”col-md-1”&gt;.col-md-1&lt;/div&gt;&lt;div class=”col-md-1”&gt;.col-md-1&lt;/div&gt;&lt;div class=”col-md-1”&gt;.col-md-1&lt;/div&gt;&lt;div class=”col-md-1”&gt;.col-md-1&lt;/div&gt;&lt;div class=”col-md-1”&gt;.col-md-1&lt;/div&gt;&lt;/div&gt;&lt;div class=”row”&gt;&lt;div class=”col-md-8”&gt;.col-md-8&lt;/div&gt;&lt;div class=”col-md-4”&gt;.col-md-4&lt;/div&gt;&lt;/div&gt;&lt;div class=”row”&gt;&lt;div class=”col-md-4”&gt;.col-md-4&lt;/div&gt;&lt;div class=”col-md-4”&gt;.col-md-4&lt;/div&gt;&lt;div class=”col-md-4”&gt;.col-md-4&lt;/div&gt;&lt;/div&gt;&lt;div class=”row”&gt;&lt;div class=”col-md-6”&gt;.col-md-6&lt;/div&gt;&lt;div class=”col-md-6”&gt;.col-md-6&lt;/div&gt;&lt;/div&gt;&nbsp;","tags":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://yoursite.com/tags/bootstrap/"}]},{"title":"智慧新沟 - 湖北智慧农村网","date":"2014-04-18T07:55:01.000Z","path":"2014/04/18/project11/","text":"智慧新沟 - 湖北智慧农村网 项目简介：智慧新沟 - 湖北智慧农村网 开发工具：sublime text，chrome 开发环境：win7 测试环境：chrome，opera，firefox，ie6/7/8/9/10/11，360 职责：负责项目的整站前端制作，协助美工制作ui，利用公司后台框架搭建专题后台，适当的seo","tags":[{"name":"project","slug":"project","permalink":"http://yoursite.com/tags/project/"}]},{"title":"小池惠民网","date":"2014-04-18T07:50:24.000Z","path":"2014/04/18/project7/","text":"小池惠民网 项目简介：小池惠民网 开发工具：sublime text，chrome 开发环境：win7 测试环境：chrome，opera，firefox，ie6/7/8/9/10/11,360 职责：负责项目的整站前端制作，协助美工制作ui，利用公司后台框架搭建专题后台，适当的seo","tags":[{"name":"project","slug":"project","permalink":"http://yoursite.com/tags/project/"}]},{"title":"手机二维码导航页","date":"2014-04-18T07:36:01.000Z","path":"2014/04/18/project8/","text":"二维码导航页 项目简介：手机二维码导航页 开发工具：sublime text，chrome，opera，Firefox，ie，ietest 开发环境：win7 适配分辨率：480x800,640x960 职责：负责项目的前端制作，协助美工制作ui","tags":[{"name":"project","slug":"project","permalink":"http://yoursite.com/tags/project/"}]},{"title":"垄上行高薪招聘页面","date":"2014-04-18T07:33:27.000Z","path":"2014/04/18/project5/","text":"垄上行高薪招聘 项目简介：垄上行高薪招聘页面 开发工具：sublime text，chrome，opera，Firefox，ie，ietest 开发环境：win7 职责：负责项目的前端制作，协助美工制作ui","tags":[{"name":"project","slug":"project","permalink":"http://yoursite.com/tags/project/"}]},{"title":"企业会员-垄上中国","date":"2014-04-18T07:29:26.000Z","path":"2014/04/18/project4/","text":"企业会员-垄上中国 项目简介：垄上中国企业会员黄页 开发工具：sublime text，chrome，opera，Firefox，ie，ietest 开发环境：win7 职责：负责项目的前端制作，协助美工制作ui，适当的seo &nbsp;","tags":[{"name":"project","slug":"project","permalink":"http://yoursite.com/tags/project/"}]},{"title":"春风行动-2014活动专题","date":"2014-04-18T07:25:59.000Z","path":"2014/04/18/project10/","text":"春风行动-2014 项目简介：春风行动-2014活动专题页面 开发工具：sublime text，chrome，opera，Firefox，ie，ietest 开发环境：win7 职责：负责项目的前端制作，协助美工制作ui，适当的seo","tags":[{"name":"project","slug":"project","permalink":"http://yoursite.com/tags/project/"}]},{"title":"湖北农企看世界活动专题","date":"2014-04-18T07:23:26.000Z","path":"2014/04/18/project12/","text":"湖北农企看世界 项目简介：湖北农企看世界活动专题页面 开发工具：sublime text，chrome，opera，Firefox，ie，ietest 开发环境：win7 职责：负责项目的前端制作，协助美工制作ui，利用公司后台框架搭建专题后台，适当的seo","tags":[{"name":"project","slug":"project","permalink":"http://yoursite.com/tags/project/"}]},{"title":"第十一届中国国际农产品交易会暨第十届中国武汉农业博览会专题页面","date":"2014-04-18T07:18:19.000Z","path":"2014/04/18/project13/","text":"第十一届中国国际农产品交易会暨第十届中国武汉农业博览会 项目简介：第十一届中国国际农产品交易会暨第十届中国武汉农业博览会专题页面 开发工具：sublime text，chrome，opera，Firefox，ie，ietest 开发环境：win7 职责：负责项目的前端制作，协助美工制作ui，利用公司后台框架搭建专题后台，适当的seo","tags":[{"name":"project","slug":"project","permalink":"http://yoursite.com/tags/project/"}]},{"title":"打工服务社年薪20万寻找农民工当主播活动专题","date":"2014-04-18T07:14:55.000Z","path":"2014/04/18/project9/","text":"打工服务社年薪20万寻找农民工当主播 项目简介：打工服务社年薪20万寻找农民工当主播活动专题页面 开发工具：sublime text，chrome，opera，Firefox，ie，ietest 开发环境：win7 职责：负责项目的前端制作，协助美工制作ui，利用公司后台框架搭建专题后台，适当的seo","tags":[{"name":"project","slug":"project","permalink":"http://yoursite.com/tags/project/"}]},{"title":"农民梦，中国梦专题","date":"2014-04-18T07:08:07.000Z","path":"2014/04/18/project6/","text":"项目简介：农民梦，中国梦专题 开发工具：sublime text，chrome，opera，Firefox，ie，ietest 开发环境：win7 职责：负责项目的前端制作，协助美工制作ui，利用公司后台框架搭建专题后台","tags":[{"name":"project","slug":"project","permalink":"http://yoursite.com/tags/project/"}]},{"title":"中国移动湖北公司 垄上频道“网站有奖征集歌词-新浪官博有奖转发”活动专题页面","date":"2014-04-18T06:38:56.000Z","path":"2014/04/18/project3/","text":"中国移动湖北公司-垄上频道“网站有奖征集歌词-新浪官博有奖转发”活动 项目简介：中国移动湖北公司 垄上频道“网站有奖征集歌词-新浪官博有奖转发”活动专题页面 开发工具：sublime text，chrome，opera，Firefox，ie，ietest 开发环境：win7 职责：负责项目的前端制作，协助美工制作ui &nbsp;","tags":[{"name":"project","slug":"project","permalink":"http://yoursite.com/tags/project/"}]},{"title":"学生地带","date":"2014-04-18T03:24:42.000Z","path":"2014/04/18/stuzone/","text":"项目简介：大学做的第一个完整的网站，网站是为中南民族大学制作的校园门户网站 开发工具：notpad++，chrome 开发环境：win7 职责：负责项目的管理和整站的前端制作，代码规范制定 项目地址：http://www.stuzone.com/","tags":[{"name":"project","slug":"project","permalink":"http://yoursite.com/tags/project/"}]}]